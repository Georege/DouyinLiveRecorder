const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["./index-C3cmY9qv.js", "./index-BC75rb57.js", "./index-DQa3t2lH.js", "./index-CONiJ9Hx.js", "./index-TtXwd95I.css", "./index-C9sXTIUf.css", "./index-CtKXTFIL.css", "./index-BpIVIrmU.js", "./index-CCrGtDFI.css", "./index-z1EH7vsD.css", "./jumpDialog-DmU7v4kn.js", "./jumpDialog-DqFc-rCf.css", "./keyboardDialog-Bs0-erVg.js", "./close-BmWBFJNf.js", "./keyboardDialog-aMT1JU2z.css", "./ReportDialog-HmpFZx9y.js", "./LoadError-oTe54j6s.js", "./index-C9VrV7Ei.js", "./index-D3h8pZQH.css", "./LoadError-oX6GypMo.css", "./profileLog-CuLAX4XR.js", "./ReportDialog-CWVGPYXw.css", "./reco-CJplC6mL.js", "./SwiperFeed-ghFIyXJk.js", "./workbench-DfBMEtiD.js", "./workbench-lDK2ANUg.css", "./SwiperFeed-BaR4EdSb.css", "./index-D6LRARGJ.js", "./index-leIqeHFt.css", "./reco-DxnB05ku.css", "./profile-DEPE0XXc.js", "./more.svg-BBtgBH1W.js", "./more-CM914ej5.css", "./profile-BULQG3MN.css", "./error-QNS3FMl2.js", "./error-DDvUQK2V.css"]))) => i.map(i => d[i]);
var __defProp = Object.defineProperty, __typeError = e => {
    throw TypeError(e)
}
, __defNormalProp = (e, t, n) => t in e ? __defProp(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n, __publicField = (e, t, n) => __defNormalProp(e, "symbol" != typeof t ? t + "" : t, n), __accessCheck = (e, t, n) => t.has(e) || __typeError("Cannot " + n), __privateGet = (e, t, n) => (__accessCheck(e, t, "read from private field"),
n ? n.call(e) : t.get(e)), __privateAdd = (e, t, n) => t.has(e) ? __typeError("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), __privateSet = (e, t, n, r) => (__accessCheck(e, t, "write to private field"),
r ? r.call(e, n) : t.set(e, n),
n), __privateMethod = (e, t, n) => (__accessCheck(e, t, "access private method"),
n), _a, _b, _c, _d, _e2, _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
// function __vite_legacy_guard() {
//     "",
//     import("_").catch(( () => 1)),
//     async function*() {}().next()
// }
!function() {
    const e = document.createElement("link").relList;
    if (!(e && e.supports && e.supports("modulepreload"))) {
        for (const e of document.querySelectorAll('link[rel="modulepreload"]'))
            t(e);
        new MutationObserver((e => {
            for (const n of e)
                if ("childList" === n.type)
                    for (const e of n.addedNodes)
                        "LINK" === e.tagName && "modulepreload" === e.rel && t(e)
        }
        )).observe(document, {
            childList: !0,
            subtree: !0
        })
    }
    function t(e) {
        if (e.ep)
            return;
        e.ep = !0;
        const t = function(e) {
            const t = {};
            return e.integrity && (t.integrity = e.integrity),
            e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
            "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin",
            t
        }(e);
        fetch(e.href, t)
    }
}();
const scriptRel = "modulepreload"
  , assetsURL = function(e, t) {
    return new URL(e,t).href
}
  , seen = {}
  , __vitePreload = function(e, t, n) {
    let r = Promise.resolve();
    if (t && t.length > 0) {
        const e = document.getElementsByTagName("link")
          , o = document.querySelector("meta[property=csp-nonce]")
          , i = (null == o ? void 0 : o.nonce) || (null == o ? void 0 : o.getAttribute("nonce"));
        r = Promise.allSettled(t.map((t => {
            if ((t = assetsURL(t, n))in seen)
                return;
            seen[t] = !0;
            const r = t.endsWith(".css")
              , o = r ? '[rel="stylesheet"]' : "";
            if (!!n)
                for (let n = e.length - 1; n >= 0; n--) {
                    const o = e[n];
                    if (o.href === t && (!r || "stylesheet" === o.rel))
                        return
                }
            else if (document.querySelector('link[href="'.concat(t, '"]').concat(o)))
                return;
            const a = document.createElement("link");
            return a.rel = r ? "stylesheet" : scriptRel,
            r || (a.as = "script"),
            a.crossOrigin = "",
            a.href = t,
            i && a.setAttribute("nonce", i),
            document.head.appendChild(a),
            r ? new Promise(( (e, n) => {
                a.addEventListener("load", e),
                a.addEventListener("error", ( () => n(new Error("Unable to preload CSS for ".concat(t)))))
            }
            )) : void 0
        }
        )))
    }
    function o(e) {
        const t = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (t.payload = e,
        window.dispatchEvent(t),
        !t.defaultPrevented)
            throw e
    }
    return r.then((t => {
        for (const e of t || [])
            "rejected" === e.status && o(e.reason);
        return e().catch(o)
    }
    ))
};
var t$1 = function() {
    return t$1 = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ,
    t$1.apply(this, arguments)
};
function e$2(e, t, n, r) {
    return new (n || (n = Promise))((function(o, i) {
        function a(e) {
            try {
                c(r.next(e))
            } catch (t) {
                i(t)
            }
        }
        function s(e) {
            try {
                c(r.throw(e))
            } catch (t) {
                i(t)
            }
        }
        function c(e) {
            var t;
            e.done ? o(e.value) : (t = e.value,
            t instanceof n ? t : new n((function(e) {
                e(t)
            }
            ))).then(a, s)
        }
        c((r = r.apply(e, t || [])).next())
    }
    ))
}
function n$2(e, t) {
    var n, r, o, i = {
        label: 0,
        sent: function() {
            if (1 & o[0])
                throw o[1];
            return o[1]
        },
        trys: [],
        ops: []
    }, a = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
    return a.next = s(0),
    a.throw = s(1),
    a.return = s(2),
    "function" == typeof Symbol && (a[Symbol.iterator] = function() {
        return this
    }
    ),
    a;
    function s(s) {
        return function(c) {
            return function(s) {
                if (n)
                    throw new TypeError("Generator is already executing.");
                for (; a && (a = 0,
                s[0] && (i = 0)),
                i; )
                    try {
                        if (n = 1,
                        r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r),
                        0) : r.next) && !(o = o.call(r, s[1])).done)
                            return o;
                        switch (r = 0,
                        o && (s = [2 & s[0], o.value]),
                        s[0]) {
                        case 0:
                        case 1:
                            o = s;
                            break;
                        case 4:
                            return i.label++,
                            {
                                value: s[1],
                                done: !1
                            };
                        case 5:
                            i.label++,
                            r = s[1],
                            s = [0];
                            continue;
                        case 7:
                            s = i.ops.pop(),
                            i.trys.pop();
                            continue;
                        default:
                            if (!((o = (o = i.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                i = 0;
                                continue
                            }
                            if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {
                                i.label = s[1];
                                break
                            }
                            if (6 === s[0] && i.label < o[1]) {
                                i.label = o[1],
                                o = s;
                                break
                            }
                            if (o && i.label < o[2]) {
                                i.label = o[2],
                                i.ops.push(s);
                                break
                            }
                            o[2] && i.ops.pop(),
                            i.trys.pop();
                            continue
                        }
                        s = t.call(e, i)
                    } catch (c) {
                        s = [6, c],
                        r = 0
                    } finally {
                        n = o = 0
                    }
                if (5 & s[0])
                    throw s[1];
                return {
                    value: s[0] ? s[1] : void 0,
                    done: !0
                }
            }([s, c])
        }
    }
}
function s$4(e, t, n) {
    for (var r, o = 0, i = t.length; o < i; o++)
        !r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)),
        r[o] = t[o]);
    return e.concat(r || Array.prototype.slice.call(t))
}
"function" == typeof SuppressedError && SuppressedError;
var r$4 = {
    FINGERPRINT: "kwfv1"
}
  , o$4 = "/s/w/c"
  , c$4 = {
    test: "https://infra-gdfp.test.gifshow.com",
    production: "https://gdfp.gifshow.com",
    kwai: "https://g-gdfp.kwai-pro.com"
}
  , i$2 = "kwscode"
  , a$6 = "kwssectoken"
  , l$4 = "webweaponconfigs"
  , h$6 = "K8wm5PvY9nX7qJc2"
  , u$5 = "H4tL6rNd3vB9xM5k";
let p$5 = class {
    static create(...e) {
        return new this(...e)
    }
    mixIn(e) {
        return Object.assign(this, e)
    }
    clone() {
        const e = new this.constructor;
        return Object.assign(e, this),
        e
    }
}
  , d$4 = class e extends p$5 {
    constructor(e=[], t=4 * e.length) {
        super();
        let n = e;
        if (n instanceof ArrayBuffer && (n = new Uint8Array(n)),
        (n instanceof Int8Array || n instanceof Uint8ClampedArray || n instanceof Int16Array || n instanceof Uint16Array || n instanceof Int32Array || n instanceof Uint32Array || n instanceof Float32Array || n instanceof Float64Array) && (n = new Uint8Array(n.buffer,n.byteOffset,n.byteLength)),
        n instanceof Uint8Array) {
            const e = n.byteLength
              , t = [];
            for (let r = 0; r < e; r += 1)
                t[r >>> 2] |= n[r] << 24 - r % 4 * 8;
            this.words = t,
            this.sigBytes = e
        } else
            this.words = e,
            this.sigBytes = t
    }
    static random(t) {
        const n = []
          , r = e => {
            let t = e
              , n = 987654321;
            const r = 4294967295;
            return () => {
                n = 36969 * (65535 & n) + (n >> 16) & r,
                t = 18e3 * (65535 & t) + (t >> 16) & r;
                let e = (n << 16) + t & r;
                return e /= 4294967296,
                e += .5,
                e * (Math.random() > .5 ? 1 : -1)
            }
        }
        ;
        for (let e, o = 0; o < t; o += 4) {
            const t = r(4294967296 * (e || Math.random()));
            e = 987654071 * t(),
            n.push(4294967296 * t() | 0)
        }
        return new e(n,t)
    }
    toString(e=f$7) {
        return e.stringify(this)
    }
    concat(e) {
        const t = this.words
          , n = e.words
          , r = this.sigBytes
          , o = e.sigBytes;
        if (this.clamp(),
        r % 4)
            for (let i = 0; i < o; i += 1) {
                const e = n[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                t[r + i >>> 2] |= e << 24 - (r + i) % 4 * 8
            }
        else
            for (let i = 0; i < o; i += 4)
                t[r + i >>> 2] = n[i >>> 2];
        return this.sigBytes += o,
        this
    }
    clamp() {
        const {words: e, sigBytes: t} = this;
        e[t >>> 2] &= 4294967295 << 32 - t % 4 * 8,
        e.length = Math.ceil(t / 4)
    }
    clone() {
        const e = super.clone.call(this);
        return e.words = this.words.slice(0),
        e
    }
}
;
const f$7 = {
    stringify(e) {
        const {words: t, sigBytes: n} = e
          , r = [];
        for (let o = 0; o < n; o += 1) {
            const e = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;
            r.push((e >>> 4).toString(16)),
            r.push((15 & e).toString(16))
        }
        return r.join("")
    },
    parse(e) {
        const t = e.length
          , n = [];
        for (let r = 0; r < t; r += 2)
            n[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4;
        return new d$4(n,t / 2)
    }
}
  , y$6 = {
    stringify(e) {
        const {words: t, sigBytes: n} = e
          , r = [];
        for (let o = 0; o < n; o += 1) {
            const e = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;
            r.push(String.fromCharCode(e))
        }
        return r.join("")
    },
    parse(e) {
        const t = e.length
          , n = [];
        for (let r = 0; r < t; r += 1)
            n[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8;
        return new d$4(n,t)
    }
}
  , g$6 = {
    stringify(e) {
        try {
            return decodeURIComponent(escape(y$6.stringify(e)))
        } catch (t) {
            throw new Error("Malformed UTF-8 data")
        }
    },
    parse: e => y$6.parse(unescape(encodeURIComponent(e)))
};
let w$2 = class extends p$5 {
    constructor() {
        super(),
        this._minBufferSize = 0
    }
    reset() {
        this._data = new d$4,
        this._nDataBytes = 0
    }
    _append(e) {
        let t = e;
        "string" == typeof t && (t = g$6.parse(t)),
        this._data.concat(t),
        this._nDataBytes += t.sigBytes
    }
    _process(e) {
        let t;
        const {_data: n, blockSize: r} = this
          , o = n.words
          , i = n.sigBytes;
        let a = i / (4 * r);
        a = e ? Math.ceil(a) : Math.max((0 | a) - this._minBufferSize, 0);
        const s = a * r
          , c = Math.min(4 * s, i);
        if (s) {
            for (let e = 0; e < s; e += r)
                this._doProcessBlock(o, e);
            t = o.splice(0, s),
            n.sigBytes -= c
        }
        return new d$4(t,c)
    }
    clone() {
        const e = super.clone.call(this);
        return e._data = this._data.clone(),
        e
    }
}
  , _$5 = class extends w$2 {
    constructor(e) {
        super(),
        this.blockSize = 16,
        this.cfg = Object.assign(new p$5, e),
        this.reset()
    }
    static _createHelper(e) {
        return (t, n) => new e(n).finalize(t)
    }
    static _createHmacHelper(e) {
        return (t, n) => new v$5(e,n).finalize(t)
    }
    reset() {
        super.reset.call(this),
        this._doReset()
    }
    update(e) {
        return this._append(e),
        this._process(),
        this
    }
    finalize(e) {
        return e && this._append(e),
        this._doFinalize()
    }
}
  , v$5 = class extends p$5 {
    constructor(e, t) {
        super();
        const n = new e;
        this._hasher = n;
        let r = t;
        "string" == typeof r && (r = g$6.parse(r));
        const o = n.blockSize
          , i = 4 * o;
        r.sigBytes > i && (r = n.finalize(t)),
        r.clamp();
        const a = r.clone();
        this._oKey = a;
        const s = r.clone();
        this._iKey = s;
        const c = a.words
          , l = s.words;
        for (let u = 0; u < o; u += 1)
            c[u] ^= 1549556828,
            l[u] ^= 909522486;
        a.sigBytes = i,
        s.sigBytes = i,
        this.reset()
    }
    reset() {
        const e = this._hasher;
        e.reset(),
        e.update(this._iKey)
    }
    update(e) {
        return this._hasher.update(e),
        this
    }
    finalize(e) {
        const t = this._hasher
          , n = t.finalize(e);
        return t.reset(),
        t.finalize(this._oKey.clone().concat(n))
    }
}
;
const m$4 = {
    stringify(e) {
        const {words: t, sigBytes: n} = e
          , r = this._map;
        e.clamp();
        const o = [];
        for (let a = 0; a < n; a += 3) {
            const e = (t[a >>> 2] >>> 24 - a % 4 * 8 & 255) << 16 | (t[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255) << 8 | t[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255;
            for (let t = 0; t < 4 && a + .75 * t < n; t += 1)
                o.push(r.charAt(e >>> 6 * (3 - t) & 63))
        }
        const i = r.charAt(64);
        if (i)
            for (; o.length % 4; )
                o.push(i);
        return o.join("")
    },
    parse(e) {
        let t = e.length;
        const n = this._map;
        let r = this._reverseMap;
        if (!r) {
            this._reverseMap = [],
            r = this._reverseMap;
            for (let e = 0; e < n.length; e += 1)
                r[n.charCodeAt(e)] = e
        }
        const o = n.charAt(64);
        if (o) {
            const n = e.indexOf(o);
            -1 !== n && (t = n)
        }
        return ( (e, t, n) => {
            const r = [];
            let o = 0;
            for (let i = 0; i < t; i += 1)
                if (i % 4) {
                    const t = n[e.charCodeAt(i - 1)] << i % 4 * 2 | n[e.charCodeAt(i)] >>> 6 - i % 4 * 2;
                    r[o >>> 2] |= t << 24 - o % 4 * 8,
                    o += 1
                }
            return d$4.create(r, o)
        }
        )(e, t, r)
    },
    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
}
  , k$3 = [];
for (let dt = 0; dt < 64; dt += 1)
    k$3[dt] = 4294967296 * Math.abs(Math.sin(dt + 1)) | 0;
const S$4 = (e, t, n, r, o, i, a) => {
    const s = e + (t & n | ~t & r) + o + a;
    return (s << i | s >>> 32 - i) + t
}
  , b$5 = (e, t, n, r, o, i, a) => {
    const s = e + (t & r | n & ~r) + o + a;
    return (s << i | s >>> 32 - i) + t
}
  , R$1 = (e, t, n, r, o, i, a) => {
    const s = e + (t ^ n ^ r) + o + a;
    return (s << i | s >>> 32 - i) + t
}
  , x$2 = (e, t, n, r, o, i, a) => {
    const s = e + (n ^ (t | ~r)) + o + a;
    return (s << i | s >>> 32 - i) + t
}
;
let B$1 = class extends _$5 {
    _doReset() {
        this._hash = new d$4([1732584193, 4023233417, 2562383102, 271733878])
    }
    _doProcessBlock(e, t) {
        const n = e;
        for (let O = 0; O < 16; O += 1) {
            const r = t + O
              , o = e[r];
            n[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
        }
        const r = this._hash.words
          , o = n[t + 0]
          , i = n[t + 1]
          , a = n[t + 2]
          , s = n[t + 3]
          , c = n[t + 4]
          , l = n[t + 5]
          , u = n[t + 6]
          , p = n[t + 7]
          , d = n[t + 8]
          , f = n[t + 9]
          , h = n[t + 10]
          , m = n[t + 11]
          , g = n[t + 12]
          , v = n[t + 13]
          , y = n[t + 14]
          , _ = n[t + 15];
        let b = r[0]
          , E = r[1]
          , w = r[2]
          , S = r[3];
        b = S$4(b, E, w, S, o, 7, k$3[0]),
        S = S$4(S, b, E, w, i, 12, k$3[1]),
        w = S$4(w, S, b, E, a, 17, k$3[2]),
        E = S$4(E, w, S, b, s, 22, k$3[3]),
        b = S$4(b, E, w, S, c, 7, k$3[4]),
        S = S$4(S, b, E, w, l, 12, k$3[5]),
        w = S$4(w, S, b, E, u, 17, k$3[6]),
        E = S$4(E, w, S, b, p, 22, k$3[7]),
        b = S$4(b, E, w, S, d, 7, k$3[8]),
        S = S$4(S, b, E, w, f, 12, k$3[9]),
        w = S$4(w, S, b, E, h, 17, k$3[10]),
        E = S$4(E, w, S, b, m, 22, k$3[11]),
        b = S$4(b, E, w, S, g, 7, k$3[12]),
        S = S$4(S, b, E, w, v, 12, k$3[13]),
        w = S$4(w, S, b, E, y, 17, k$3[14]),
        E = S$4(E, w, S, b, _, 22, k$3[15]),
        b = b$5(b, E, w, S, i, 5, k$3[16]),
        S = b$5(S, b, E, w, u, 9, k$3[17]),
        w = b$5(w, S, b, E, m, 14, k$3[18]),
        E = b$5(E, w, S, b, o, 20, k$3[19]),
        b = b$5(b, E, w, S, l, 5, k$3[20]),
        S = b$5(S, b, E, w, h, 9, k$3[21]),
        w = b$5(w, S, b, E, _, 14, k$3[22]),
        E = b$5(E, w, S, b, c, 20, k$3[23]),
        b = b$5(b, E, w, S, f, 5, k$3[24]),
        S = b$5(S, b, E, w, y, 9, k$3[25]),
        w = b$5(w, S, b, E, s, 14, k$3[26]),
        E = b$5(E, w, S, b, d, 20, k$3[27]),
        b = b$5(b, E, w, S, v, 5, k$3[28]),
        S = b$5(S, b, E, w, a, 9, k$3[29]),
        w = b$5(w, S, b, E, p, 14, k$3[30]),
        E = b$5(E, w, S, b, g, 20, k$3[31]),
        b = R$1(b, E, w, S, l, 4, k$3[32]),
        S = R$1(S, b, E, w, d, 11, k$3[33]),
        w = R$1(w, S, b, E, m, 16, k$3[34]),
        E = R$1(E, w, S, b, y, 23, k$3[35]),
        b = R$1(b, E, w, S, i, 4, k$3[36]),
        S = R$1(S, b, E, w, c, 11, k$3[37]),
        w = R$1(w, S, b, E, p, 16, k$3[38]),
        E = R$1(E, w, S, b, h, 23, k$3[39]),
        b = R$1(b, E, w, S, v, 4, k$3[40]),
        S = R$1(S, b, E, w, o, 11, k$3[41]),
        w = R$1(w, S, b, E, s, 16, k$3[42]),
        E = R$1(E, w, S, b, u, 23, k$3[43]),
        b = R$1(b, E, w, S, f, 4, k$3[44]),
        S = R$1(S, b, E, w, g, 11, k$3[45]),
        w = R$1(w, S, b, E, _, 16, k$3[46]),
        E = R$1(E, w, S, b, a, 23, k$3[47]),
        b = x$2(b, E, w, S, o, 6, k$3[48]),
        S = x$2(S, b, E, w, p, 10, k$3[49]),
        w = x$2(w, S, b, E, y, 15, k$3[50]),
        E = x$2(E, w, S, b, l, 21, k$3[51]),
        b = x$2(b, E, w, S, g, 6, k$3[52]),
        S = x$2(S, b, E, w, s, 10, k$3[53]),
        w = x$2(w, S, b, E, h, 15, k$3[54]),
        E = x$2(E, w, S, b, i, 21, k$3[55]),
        b = x$2(b, E, w, S, d, 6, k$3[56]),
        S = x$2(S, b, E, w, _, 10, k$3[57]),
        w = x$2(w, S, b, E, u, 15, k$3[58]),
        E = x$2(E, w, S, b, v, 21, k$3[59]),
        b = x$2(b, E, w, S, c, 6, k$3[60]),
        S = x$2(S, b, E, w, m, 10, k$3[61]),
        w = x$2(w, S, b, E, a, 15, k$3[62]),
        E = x$2(E, w, S, b, f, 21, k$3[63]),
        r[0] = r[0] + b | 0,
        r[1] = r[1] + E | 0,
        r[2] = r[2] + w | 0,
        r[3] = r[3] + S | 0
    }
    _doFinalize() {
        const e = this._data
          , t = e.words
          , n = 8 * this._nDataBytes
          , r = 8 * e.sigBytes;
        t[r >>> 5] |= 128 << 24 - r % 32;
        const o = Math.floor(n / 4294967296)
          , i = n;
        t[15 + (r + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
        t[14 + (r + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8),
        e.sigBytes = 4 * (t.length + 1),
        this._process();
        const a = this._hash
          , s = a.words;
        for (let c = 0; c < 4; c += 1) {
            const e = s[c];
            s[c] = 16711935 & (e << 8 | e >>> 24) | 4278255360 & (e << 24 | e >>> 8)
        }
        return a
    }
    clone() {
        const e = super.clone.call(this);
        return e._hash = this._hash.clone(),
        e
    }
}
  , I$2 = class extends p$5 {
    constructor(e) {
        super(),
        this.cfg = Object.assign(new p$5, {
            keySize: 4,
            hasher: B$1,
            iterations: 1
        }, e)
    }
    compute(e, t) {
        let n;
        const {cfg: r} = this
          , o = r.hasher.create()
          , i = d$4.create()
          , a = i.words
          , {keySize: s, iterations: c} = r;
        for (; a.length < s; ) {
            n && o.update(n),
            n = o.update(e).finalize(t),
            o.reset();
            for (let e = 1; e < c; e += 1)
                n = o.finalize(n),
                o.reset();
            i.concat(n)
        }
        return i.sigBytes = 4 * s,
        i
    }
}
  , E$2 = class extends w$2 {
    constructor(e, t, n) {
        super(),
        this.cfg = Object.assign(new p$5, n),
        this._xformMode = e,
        this._key = t,
        this.reset()
    }
    static createEncryptor(e, t) {
        return this.create(this._ENC_XFORM_MODE, e, t)
    }
    static createDecryptor(e, t) {
        return this.create(this._DEC_XFORM_MODE, e, t)
    }
    static _createHelper(e) {
        const t = e => "string" == typeof e ? A$3 : j$1;
        return {
            encrypt: (n, r, o) => t(r).encrypt(e, n, r, o),
            decrypt: (n, r, o) => t(r).decrypt(e, n, r, o)
        }
    }
    reset() {
        super.reset.call(this),
        this._doReset()
    }
    process(e) {
        return this._append(e),
        this._process()
    }
    finalize(e) {
        return e && this._append(e),
        this._doFinalize()
    }
}
;
E$2._ENC_XFORM_MODE = 1,
E$2._DEC_XFORM_MODE = 2,
E$2.keySize = 4,
E$2.ivSize = 4;
let z$3 = class extends p$5 {
    constructor(e, t) {
        super(),
        this._cipher = e,
        this._iv = t
    }
    static createEncryptor(e, t) {
        return this.Encryptor.create(e, t)
    }
    static createDecryptor(e, t) {
        return this.Decryptor.create(e, t)
    }
}
;
function O$3(e, t, n) {
    const r = e;
    let o;
    const i = this._iv;
    i ? (o = i,
    this._iv = void 0) : o = this._prevBlock;
    for (let a = 0; a < n; a += 1)
        r[t + a] ^= o[a]
}
let N$3 = class extends z$3 {
}
;
N$3.Encryptor = class extends N$3 {
    processBlock(e, t) {
        const n = this._cipher
          , {blockSize: r} = n;
        O$3.call(this, e, t, r),
        n.encryptBlock(e, t),
        this._prevBlock = e.slice(t, t + r)
    }
}
,
N$3.Decryptor = class extends N$3 {
    processBlock(e, t) {
        const n = this._cipher
          , {blockSize: r} = n
          , o = e.slice(t, t + r);
        n.decryptBlock(e, t),
        O$3.call(this, e, t, r),
        this._prevBlock = o
    }
}
;
const C$1 = {
    pad(e, t) {
        const n = 4 * t
          , r = n - e.sigBytes % n
          , o = r << 24 | r << 16 | r << 8 | r
          , i = [];
        for (let s = 0; s < r; s += 4)
            i.push(o);
        const a = d$4.create(i, r);
        e.concat(a)
    },
    unpad(e) {
        const t = e
          , n = 255 & t.words[t.sigBytes - 1 >>> 2];
        t.sigBytes -= n
    }
};
let F$3 = class extends E$2 {
    constructor(e, t, n) {
        super(e, t, Object.assign({
            mode: N$3,
            padding: C$1
        }, n)),
        this.blockSize = 4
    }
    reset() {
        let e;
        super.reset.call(this);
        const {cfg: t} = this
          , {iv: n, mode: r} = t;
        this._xformMode === this.constructor._ENC_XFORM_MODE ? e = r.createEncryptor : (e = r.createDecryptor,
        this._minBufferSize = 1),
        this._mode = e.call(r, this, n && n.words),
        this._mode.__creator = e
    }
    _doProcessBlock(e, t) {
        this._mode.processBlock(e, t)
    }
    _doFinalize() {
        let e;
        const {padding: t} = this.cfg;
        return this._xformMode === this.constructor._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize),
        e = this._process(!0)) : (e = this._process(!0),
        t.unpad(e)),
        e
    }
}
  , M$2 = class extends p$5 {
    constructor(e) {
        super(),
        this.mixIn(e)
    }
    toString(e) {
        return (e || this.formatter).stringify(this)
    }
}
;
const D$1 = {
    stringify(e) {
        let t;
        const {ciphertext: n, salt: r} = e;
        return t = r ? d$4.create([1398893684, 1701076831]).concat(r).concat(n) : n,
        t.toString(m$4)
    },
    parse(e) {
        let t;
        const n = m$4.parse(e)
          , r = n.words;
        return 1398893684 === r[0] && 1701076831 === r[1] && (t = d$4.create(r.slice(2, 4)),
        r.splice(0, 4),
        n.sigBytes -= 16),
        M$2.create({
            ciphertext: n,
            salt: t
        })
    }
};
let j$1 = class extends p$5 {
    static encrypt(e, t, n, r) {
        const o = Object.assign(new p$5, this.cfg, r)
          , i = e.createEncryptor(n, o)
          , a = i.finalize(t)
          , s = i.cfg;
        return M$2.create({
            ciphertext: a,
            key: n,
            iv: s.iv,
            algorithm: e,
            mode: s.mode,
            padding: s.padding,
            blockSize: i.blockSize,
            formatter: o.format
        })
    }
    static decrypt(e, t, n, r) {
        let o = t;
        const i = Object.assign(new p$5, this.cfg, r);
        return o = this._parse(o, i.format),
        e.createDecryptor(n, i).finalize(o.ciphertext)
    }
    static _parse(e, t) {
        return "string" == typeof e ? t.parse(e, this) : e
    }
}
;
j$1.cfg = Object.assign(new p$5, {
    format: D$1
});
const P$4 = {
    execute(e, t, n, r) {
        let o = r;
        o || (o = d$4.random(8));
        const i = I$2.create({
            keySize: t + n
        }).compute(e, o)
          , a = d$4.create(i.words.slice(t), 4 * n);
        return i.sigBytes = 4 * t,
        M$2.create({
            key: i,
            iv: a,
            salt: o
        })
    }
};
let A$3 = class extends j$1 {
    static encrypt(e, t, n, r) {
        const o = Object.assign(new p$5, this.cfg, r)
          , i = o.kdf.execute(n, e.keySize, e.ivSize);
        o.iv = i.iv;
        const a = j$1.encrypt.call(this, e, t, i.key, o);
        return a.mixIn(i),
        a
    }
    static decrypt(e, t, n, r) {
        let o = t;
        const i = Object.assign(new p$5, this.cfg, r);
        o = this._parse(o, i.format);
        const a = i.kdf.execute(n, e.keySize, e.ivSize, o.salt);
        return i.iv = a.iv,
        j$1.decrypt.call(this, e, o, a.key, i)
    }
}
;
A$3.cfg = Object.assign(j$1.cfg, {
    kdf: P$4
});
const U$1 = []
  , T$1 = []
  , G$1 = []
  , K$1 = []
  , H$1 = []
  , X$2 = []
  , q$2 = []
  , J$2 = []
  , L$3 = []
  , W$1 = []
  , Y$2 = [];
for (let dt = 0; dt < 256; dt += 1)
    Y$2[dt] = dt < 128 ? dt << 1 : dt << 1 ^ 283;
let Q$2 = 0
  , V$2 = 0;
for (let dt = 0; dt < 256; dt += 1) {
    let e = V$2 ^ V$2 << 1 ^ V$2 << 2 ^ V$2 << 3 ^ V$2 << 4;
    e = e >>> 8 ^ 255 & e ^ 99,
    U$1[Q$2] = e,
    T$1[e] = Q$2;
    const t = Y$2[Q$2]
      , n = Y$2[t]
      , r = Y$2[n];
    let o = 257 * Y$2[e] ^ 16843008 * e;
    G$1[Q$2] = o << 24 | o >>> 8,
    K$1[Q$2] = o << 16 | o >>> 16,
    H$1[Q$2] = o << 8 | o >>> 24,
    X$2[Q$2] = o,
    o = 16843009 * r ^ 65537 * n ^ 257 * t ^ 16843008 * Q$2,
    q$2[e] = o << 24 | o >>> 8,
    J$2[e] = o << 16 | o >>> 16,
    L$3[e] = o << 8 | o >>> 24,
    W$1[e] = o,
    Q$2 ? (Q$2 = t ^ Y$2[Y$2[Y$2[r ^ t]]],
    V$2 ^= Y$2[Y$2[V$2]]) : (V$2 = 1,
    Q$2 = V$2)
}
const Z$2 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
let $$2 = class extends F$3 {
    _doReset() {
        let e;
        if (this._nRounds && this._keyPriorReset === this._key)
            return;
        this._keyPriorReset = this._key;
        const t = this._keyPriorReset
          , n = t.words
          , r = t.sigBytes / 4;
        this._nRounds = r + 6;
        const o = 4 * (this._nRounds + 1);
        this._keySchedule = [];
        const i = this._keySchedule;
        for (let s = 0; s < o; s += 1)
            s < r ? i[s] = n[s] : (e = i[s - 1],
            s % r ? r > 6 && s % r == 4 && (e = U$1[e >>> 24] << 24 | U$1[e >>> 16 & 255] << 16 | U$1[e >>> 8 & 255] << 8 | U$1[255 & e]) : (e = e << 8 | e >>> 24,
            e = U$1[e >>> 24] << 24 | U$1[e >>> 16 & 255] << 16 | U$1[e >>> 8 & 255] << 8 | U$1[255 & e],
            e ^= Z$2[s / r | 0] << 24),
            i[s] = i[s - r] ^ e);
        this._invKeySchedule = [];
        const a = this._invKeySchedule;
        for (let s = 0; s < o; s += 1) {
            const t = o - s;
            e = s % 4 ? i[t] : i[t - 4],
            a[s] = s < 4 || t <= 4 ? e : q$2[U$1[e >>> 24]] ^ J$2[U$1[e >>> 16 & 255]] ^ L$3[U$1[e >>> 8 & 255]] ^ W$1[U$1[255 & e]]
        }
    }
    encryptBlock(e, t) {
        this._doCryptBlock(e, t, this._keySchedule, G$1, K$1, H$1, X$2, U$1)
    }
    decryptBlock(e, t) {
        const n = e;
        let r = n[t + 1];
        n[t + 1] = n[t + 3],
        n[t + 3] = r,
        this._doCryptBlock(n, t, this._invKeySchedule, q$2, J$2, L$3, W$1, T$1),
        r = n[t + 1],
        n[t + 1] = n[t + 3],
        n[t + 3] = r
    }
    _doCryptBlock(e, t, n, r, o, i, a, s) {
        const c = e
          , l = this._nRounds;
        let u = c[t] ^ n[0]
          , p = c[t + 1] ^ n[1]
          , d = c[t + 2] ^ n[2]
          , f = c[t + 3] ^ n[3]
          , h = 4;
        for (let _ = 1; _ < l; _ += 1) {
            const e = r[u >>> 24] ^ o[p >>> 16 & 255] ^ i[d >>> 8 & 255] ^ a[255 & f] ^ n[h];
            h += 1;
            const t = r[p >>> 24] ^ o[d >>> 16 & 255] ^ i[f >>> 8 & 255] ^ a[255 & u] ^ n[h];
            h += 1;
            const s = r[d >>> 24] ^ o[f >>> 16 & 255] ^ i[u >>> 8 & 255] ^ a[255 & p] ^ n[h];
            h += 1;
            const c = r[f >>> 24] ^ o[u >>> 16 & 255] ^ i[p >>> 8 & 255] ^ a[255 & d] ^ n[h];
            h += 1,
            u = e,
            p = t,
            d = s,
            f = c
        }
        const m = (s[u >>> 24] << 24 | s[p >>> 16 & 255] << 16 | s[d >>> 8 & 255] << 8 | s[255 & f]) ^ n[h];
        h += 1;
        const g = (s[p >>> 24] << 24 | s[d >>> 16 & 255] << 16 | s[f >>> 8 & 255] << 8 | s[255 & u]) ^ n[h];
        h += 1;
        const v = (s[d >>> 24] << 24 | s[f >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & p]) ^ n[h];
        h += 1;
        const y = (s[f >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[p >>> 8 & 255] << 8 | s[255 & d]) ^ n[h];
        h += 1,
        c[t] = m,
        c[t + 1] = g,
        c[t + 2] = v,
        c[t + 3] = y
    }
}
;
$$2.keySize = 8;
const tt$3 = F$3._createHelper($$2);
var et$1 = "undefined" == typeof window;
function nt$3(e) {
    return (null == e ? void 0 : e.did) || ct$1("did") || ""
}
function st$1(e, t) {
    var n = g$6.parse(t || l$4)
      , r = n;
    return tt$3.encrypt(e, n, {
        iv: r,
        mode: N$3,
        padding: C$1
    }).toString()
}
var rt$1 = function(e) {
    for (var t = "", n = 0; n < e; n++)
        t += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"[Math.floor(62 * Math.random())];
    return t
}
  , ot$1 = function() {
    var e = Date.now()
      , t = "".concat(e, "|").concat(rt$1(8))
      , n = "".concat(st$1(t, h$6));
    return "".concat(n, "###ssrd")
};
function ct$1(e) {
    for (var t = document.cookie.split(";"), n = 0; n < t.length; n++) {
        var r = t[n].split("=").map((function(e) {
            return e.trim()
        }
        ))
          , o = r[0]
          , i = r[1];
        if (o === e)
            return decodeURIComponent(i)
    }
    return null
}
function it$1(e, t, n) {
    void 0 === n && (n = {});
    var r = encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape)
      , o = encodeURIComponent(t).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
      , i = "".concat(r, "=").concat(o);
    if ("number" == typeof (n = Object.assign({
        path: "/",
        domain: location.hostname.split(".").slice(-2).join(".")
    }, n)).expires) {
        var a = new Date(Date.now() + 24 * n.expires * 60 * 60 * 1e3);
        i += "; expires=".concat(a.toUTCString())
    }
    n.path && (i += "; path=".concat(n.path)),
    n.domain && (i += "; domain=".concat(n.domain)),
    n.secure && (i += "; secure"),
    document.cookie = i
}
var at$1 = function() {
    function e(e) {
        var t = this;
        this.loadScript = function(e) {
            for (var n = [], r = 1; r < arguments.length; r++)
                n[r - 1] = arguments[r];
            return e$2(t, s$4([e], n), void 0, (function(e, t) {
                var n;
                return void 0 === t && (t = 0),
                n$2(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        return r.trys.push([0, 2, , 3]),
                        [4, new Promise((function(t, n) {
                            var r = document.createElement("script");
                            r.src = e,
                            r.type = "text/javascript",
                            r.crossOrigin = "anonymous",
                            r.onload = function() {
                                return t()
                            }
                            ,
                            r.onerror = n,
                            document.body.appendChild(r)
                        }
                        ))];
                    case 1:
                        return r.sent(),
                        [3, 3];
                    case 2:
                        if (n = r.sent(),
                        t < this.options.maxRetries)
                            return console.warn("Failed to load script, retrying... (".concat(t + 1, "/").concat(2, ")")),
                            [2, this.loadScript(e, t + 1)];
                        throw n;
                    case 3:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        this.initScript = function() {
            return e$2(t, void 0, void 0, (function() {
                var e, t, n, r;
                return n$2(this, (function(o) {
                    switch (o.label) {
                    case 0:
                        return [4, this.fetchConfig()];
                    case 1:
                        return e = o.sent(),
                        t = e.fpUrl,
                        n = e.signUrl,
                        r = e.secToken,
                        this.handleFingerprint(t),
                        this.handleSignature(n, r),
                        [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        this.handleFingerprint = function(e) {
            return e$2(t, void 0, void 0, (function() {
                var t;
                return n$2(this, (function(n) {
                    switch (n.label) {
                    case 0:
                        return n.trys.push([0, 2, , 3]),
                        [4, this.loadScript(e)];
                    case 1:
                        return n.sent(),
                        this.pollFpInterval = setInterval((function() {
                            var e;
                            null === (e = null === window || void 0 === window ? void 0 : window.kwpsec) || void 0 === e || e.getData()
                        }
                        ), 18e4),
                        [3, 3];
                    case 2:
                        return t = n.sent(),
                        console.error("Failed to init fingerprint:", t),
                        [3, 3];
                    case 3:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        this.pollSignature = function() {
            return e$2(t, void 0, void 0, (function() {
                var e, t, n, r;
                return n$2(this, (function(o) {
                    switch (o.label) {
                    case 0:
                        return o.trys.push([0, 2, , 3]),
                        [4, this.fetchConfig()];
                    case 1:
                        return e = o.sent(),
                        t = e.signUrl,
                        n = e.secToken,
                        this.handleSignature(t, n),
                        [3, 3];
                    case 2:
                        return r = o.sent(),
                        console.error("Failed to fetch signature config:", r),
                        [3, 3];
                    case 3:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        this.handleSignature = function(e, n) {
            return e$2(t, void 0, void 0, (function() {
                var t;
                return n$2(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        r.trys.push([0, 5, , 6]),
                        window.kwscb = function(e) {
                            it$1(a$6, n, {
                                expires: 6 / 1440
                            }),
                            it$1(i$2, e, {
                                expires: 6 / 1440
                            })
                        }
                        ,
                        r.label = 1;
                    case 1:
                        return r.trys.push([1, , 3, 4]),
                        [4, this.loadScript(e)];
                    case 2:
                        return r.sent(),
                        [3, 4];
                    case 3:
                        return delete window.kwscb,
                        [7];
                    case 4:
                        return [3, 6];
                    case 5:
                        return t = r.sent(),
                        console.error("Failed to fetch signature script:", t),
                        [3, 6];
                    case 6:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        this.fetchConfig = function() {
            for (var e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            return e$2(t, s$4([], e), void 0, (function(e) {
                var t, n, r, o, i;
                return void 0 === e && (e = 0),
                n$2(this, (function(a) {
                    switch (a.label) {
                    case 0:
                        t = new XMLHttpRequest,
                        s = this.options,
                        c = s.env || "production",
                        l = c$4[c],
                        "production" === c && s.host && (l = c$4[s.host] || s.host),
                        n = "".concat(l).concat(o$4),
                        r = {
                            productName: this.options.productName,
                            ts: Date.now(),
                            did: nt$3(this.options)
                        },
                        o = st$1(JSON.stringify(r)),
                        t.open("POST", n, !0),
                        t.setRequestHeader("Content-Type", "application/json"),
                        a.label = 1;
                    case 1:
                        return a.trys.push([1, 3, , 4]),
                        [4, new Promise((function(e, n) {
                            t.onload = function() {
                                if (200 === t.status) {
                                    var r = JSON.parse(t.responseText);
                                    if (1 === r.result) {
                                        var o = JSON.parse((i = r.dataRsp,
                                        a = g$6.parse(l$4),
                                        s = a,
                                        tt$3.decrypt(i, a, {
                                            iv: s,
                                            mode: N$3,
                                            padding: C$1
                                        }).toString(g$6))) || {};
                                        e(o)
                                    } else
                                        n(new Error(r.error_msg || "Request failed"))
                                } else
                                    n(new Error("Request failed with status ".concat(t.status)));
                                var i, a, s
                            }
                            ,
                            t.onerror = function() {
                                return n(new Error("Network error"))
                            }
                            ,
                            t.send(JSON.stringify({
                                data: o
                            }))
                        }
                        ))];
                    case 2:
                        return [2, a.sent()];
                    case 3:
                        if (i = a.sent(),
                        e < this.options.maxRetries)
                            return console.warn("获取配置失败，正在重试... (".concat(e + 1, "/2)")),
                            [2, this.fetchConfig(e + 1)];
                        throw i;
                    case 4:
                        return [2]
                    }
                    var s, c, l
                }
                ))
            }
            ))
        }
        ,
        this.getDefaultData = function() {
            var e = Date.now()
              , n = localStorage.getItem(r$4.FINGERPRINT)
              , r = ct$1(i$2)
              , o = ct$1(a$6)
              , i = location.href.slice(0, 80);
            if (!n) {
                var a = "".concat(encodeURI(i), "|").concat(nt$3(t.options), "|").concat(t.options.productName, "|").concat(e, "|").concat(rt$1(8))
                  , s = "".concat(st$1(a, h$6));
                n = "K".concat(s.slice(0, 4), "W").concat(s.slice(4, -2), "F").concat(s.slice(-2)),
                localStorage.setItem(r$4.FINGERPRINT, n)
            }
            if (!r || !o) {
                o = rt$1(64);
                var c = "".concat(encodeURI(i), "|").concat(nt$3(t.options), "|").concat(t.options.productName, "|").concat(e, "|").concat(o.slice(0, 8))
                  , l = "".concat(st$1(c, u$5));
                r = "K".concat(l.slice(0, 4), "W").concat(l.slice(4, -2), "S").concat(l.slice(-2)),
                it$1(a$6, o, {
                    expires: 6 / 1440
                }),
                it$1(i$2, r, {
                    expires: 6 / 1440
                })
            }
            return {
                encryptedFp: n,
                encryptedToken: r,
                secToken: o
            }
        }
        ,
        this.setProductName = function() {
            var e = t.options.productName;
            e && it$1("kwpsecproductname", e, {
                expires: 30
            })
        }
        ,
        this.options = t$1({
            maxRetries: 2,
            env: "production"
        }, e),
        window.webWeapon = {
            productName: this.options.productName
        },
        this.init()
    }
    return e.prototype.init = function() {
        this.setProductName(),
        this.getDefaultData(),
        this.initScript(),
        this.pollSignInterval = setInterval(this.pollSignature, 3e5)
    }
    ,
    e
}()
  , lt$1 = function(e) {
    return new at$1(e)
}
  , ut$1 = function(e) {
    var t = {}
      , n = "";
    et$1 ? n = ot$1() : !(n = localStorage.getItem(r$4.FINGERPRINT) || ct$1(r$4.FINGERPRINT) || "") && (null === window || void 0 === window ? void 0 : window.kwpsec) && (n = window.kwpsec.getData());
    return n && (t.kww = n),
    t
};
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function makeMap(e) {
    const t = Object.create(null);
    for (const n of e.split(","))
        t[n] = 1;
    return e => e in t
}
!function() {
    if ("object" == typeof window)
        if ("IntersectionObserver"in window && "IntersectionObserverEntry"in window && "intersectionRatio"in window.IntersectionObserverEntry.prototype)
            "isIntersecting"in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function() {
                    return this.intersectionRatio > 0
                }
            });
        else {
            var e = function() {
                for (var e = window.document, t = o(e); t; )
                    t = o(e = t.ownerDocument);
                return e
            }()
              , t = []
              , n = null
              , r = null;
            a.prototype.THROTTLE_TIMEOUT = 100,
            a.prototype.POLL_INTERVAL = null,
            a.prototype.USE_MUTATION_OBSERVER = !0,
            a._setupCrossOriginUpdater = function() {
                return n || (n = function(e, n) {
                    r = e && n ? p(e, n) : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    },
                    t.forEach((function(e) {
                        e._checkForIntersections()
                    }
                    ))
                }
                ),
                n
            }
            ,
            a._resetCrossOriginUpdater = function() {
                n = null,
                r = null
            }
            ,
            a.prototype.observe = function(e) {
                if (!this._observationTargets.some((function(t) {
                    return t.element == e
                }
                ))) {
                    if (!e || 1 != e.nodeType)
                        throw new Error("target must be an Element");
                    this._registerInstance(),
                    this._observationTargets.push({
                        element: e,
                        entry: null
                    }),
                    this._monitorIntersections(e.ownerDocument),
                    this._checkForIntersections()
                }
            }
            ,
            a.prototype.unobserve = function(e) {
                this._observationTargets = this._observationTargets.filter((function(t) {
                    return t.element != e
                }
                )),
                this._unmonitorIntersections(e.ownerDocument),
                0 == this._observationTargets.length && this._unregisterInstance()
            }
            ,
            a.prototype.disconnect = function() {
                this._observationTargets = [],
                this._unmonitorAllIntersections(),
                this._unregisterInstance()
            }
            ,
            a.prototype.takeRecords = function() {
                var e = this._queuedEntries.slice();
                return this._queuedEntries = [],
                e
            }
            ,
            a.prototype._initThresholds = function(e) {
                var t = e || [0];
                return Array.isArray(t) || (t = [t]),
                t.sort().filter((function(e, t, n) {
                    if ("number" != typeof e || isNaN(e) || e < 0 || e > 1)
                        throw new Error("threshold must be a number between 0 and 1 inclusively");
                    return e !== n[t - 1]
                }
                ))
            }
            ,
            a.prototype._parseRootMargin = function(e) {
                var t = (e || "0px").split(/\s+/).map((function(e) {
                    var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e);
                    if (!t)
                        throw new Error("rootMargin must be specified in pixels or percent");
                    return {
                        value: parseFloat(t[1]),
                        unit: t[2]
                    }
                }
                ));
                return t[1] = t[1] || t[0],
                t[2] = t[2] || t[0],
                t[3] = t[3] || t[1],
                t
            }
            ,
            a.prototype._monitorIntersections = function(t) {
                var n = t.defaultView;
                if (n && -1 == this._monitoringDocuments.indexOf(t)) {
                    var r = this._checkForIntersections
                      , i = null
                      , a = null;
                    this.POLL_INTERVAL ? i = n.setInterval(r, this.POLL_INTERVAL) : (s(n, "resize", r, !0),
                    s(t, "scroll", r, !0),
                    this.USE_MUTATION_OBSERVER && "MutationObserver"in n && (a = new n.MutationObserver(r)).observe(t, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    })),
                    this._monitoringDocuments.push(t),
                    this._monitoringUnsubscribes.push((function() {
                        var e = t.defaultView;
                        e && (i && e.clearInterval(i),
                        c(e, "resize", r, !0)),
                        c(t, "scroll", r, !0),
                        a && a.disconnect()
                    }
                    ));
                    var l = this.root && (this.root.ownerDocument || this.root) || e;
                    if (t != l) {
                        var u = o(t);
                        u && this._monitorIntersections(u.ownerDocument)
                    }
                }
            }
            ,
            a.prototype._unmonitorIntersections = function(t) {
                var n = this._monitoringDocuments.indexOf(t);
                if (-1 != n) {
                    var r = this.root && (this.root.ownerDocument || this.root) || e;
                    if (!this._observationTargets.some((function(e) {
                        var n = e.element.ownerDocument;
                        if (n == t)
                            return !0;
                        for (; n && n != r; ) {
                            var i = o(n);
                            if ((n = i && i.ownerDocument) == t)
                                return !0
                        }
                        return !1
                    }
                    ))) {
                        var i = this._monitoringUnsubscribes[n];
                        if (this._monitoringDocuments.splice(n, 1),
                        this._monitoringUnsubscribes.splice(n, 1),
                        i(),
                        t != r) {
                            var a = o(t);
                            a && this._unmonitorIntersections(a.ownerDocument)
                        }
                    }
                }
            }
            ,
            a.prototype._unmonitorAllIntersections = function() {
                var e = this._monitoringUnsubscribes.slice(0);
                this._monitoringDocuments.length = 0,
                this._monitoringUnsubscribes.length = 0;
                for (var t = 0; t < e.length; t++)
                    e[t]()
            }
            ,
            a.prototype._checkForIntersections = function() {
                if (this.root || !n || r) {
                    var e = this._rootIsInDom()
                      , t = e ? this._getRootRect() : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    };
                    this._observationTargets.forEach((function(r) {
                        var o = r.element
                          , a = l(o)
                          , s = this._rootContainsTarget(o)
                          , c = r.entry
                          , u = e && s && this._computeTargetAndRootIntersection(o, a, t)
                          , p = null;
                        this._rootContainsTarget(o) ? n && !this.root || (p = t) : p = {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        };
                        var d = r.entry = new i({
                            time: window.performance && performance.now && performance.now(),
                            target: o,
                            boundingClientRect: a,
                            rootBounds: p,
                            intersectionRect: u
                        });
                        c ? e && s ? this._hasCrossedThreshold(c, d) && this._queuedEntries.push(d) : c && c.isIntersecting && this._queuedEntries.push(d) : this._queuedEntries.push(d)
                    }
                    ), this),
                    this._queuedEntries.length && this._callback(this.takeRecords(), this)
                }
            }
            ,
            a.prototype._computeTargetAndRootIntersection = function(t, o, i) {
                if ("none" != window.getComputedStyle(t).display) {
                    for (var a, s, c, u, d, h, m, g, v = o, y = f(t), _ = !1; !_ && y; ) {
                        var b = null
                          , E = 1 == y.nodeType ? window.getComputedStyle(y) : {};
                        if ("none" == E.display)
                            return null;
                        if (y == this.root || 9 == y.nodeType)
                            if (_ = !0,
                            y == this.root || y == e)
                                n && !this.root ? !r || 0 == r.width && 0 == r.height ? (y = null,
                                b = null,
                                v = null) : b = r : b = i;
                            else {
                                var w = f(y)
                                  , S = w && l(w)
                                  , O = w && this._computeTargetAndRootIntersection(w, S, i);
                                S && O ? (y = w,
                                b = p(S, O)) : (y = null,
                                v = null)
                            }
                        else {
                            var T = y.ownerDocument;
                            y != T.body && y != T.documentElement && "visible" != E.overflow && (b = l(y))
                        }
                        if (b && (a = b,
                        s = v,
                        c = void 0,
                        u = void 0,
                        d = void 0,
                        h = void 0,
                        m = void 0,
                        g = void 0,
                        c = Math.max(a.top, s.top),
                        u = Math.min(a.bottom, s.bottom),
                        d = Math.max(a.left, s.left),
                        h = Math.min(a.right, s.right),
                        g = u - c,
                        v = (m = h - d) >= 0 && g >= 0 && {
                            top: c,
                            bottom: u,
                            left: d,
                            right: h,
                            width: m,
                            height: g
                        } || null),
                        !v)
                            break;
                        y = y && f(y)
                    }
                    return v
                }
            }
            ,
            a.prototype._getRootRect = function() {
                var t;
                if (this.root && !h(this.root))
                    t = l(this.root);
                else {
                    var n = h(this.root) ? this.root : e
                      , r = n.documentElement
                      , o = n.body;
                    t = {
                        top: 0,
                        left: 0,
                        right: r.clientWidth || o.clientWidth,
                        width: r.clientWidth || o.clientWidth,
                        bottom: r.clientHeight || o.clientHeight,
                        height: r.clientHeight || o.clientHeight
                    }
                }
                return this._expandRectByRootMargin(t)
            }
            ,
            a.prototype._expandRectByRootMargin = function(e) {
                var t = this._rootMarginValues.map((function(t, n) {
                    return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100
                }
                ))
                  , n = {
                    top: e.top - t[0],
                    right: e.right + t[1],
                    bottom: e.bottom + t[2],
                    left: e.left - t[3]
                };
                return n.width = n.right - n.left,
                n.height = n.bottom - n.top,
                n
            }
            ,
            a.prototype._hasCrossedThreshold = function(e, t) {
                var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1
                  , r = t.isIntersecting ? t.intersectionRatio || 0 : -1;
                if (n !== r)
                    for (var o = 0; o < this.thresholds.length; o++) {
                        var i = this.thresholds[o];
                        if (i == n || i == r || i < n != i < r)
                            return !0
                    }
            }
            ,
            a.prototype._rootIsInDom = function() {
                return !this.root || d(e, this.root)
            }
            ,
            a.prototype._rootContainsTarget = function(t) {
                var n = this.root && (this.root.ownerDocument || this.root) || e;
                return d(n, t) && (!this.root || n == t.ownerDocument)
            }
            ,
            a.prototype._registerInstance = function() {
                t.indexOf(this) < 0 && t.push(this)
            }
            ,
            a.prototype._unregisterInstance = function() {
                var e = t.indexOf(this);
                -1 != e && t.splice(e, 1)
            }
            ,
            window.IntersectionObserver = a,
            window.IntersectionObserverEntry = i
        }
    function o(e) {
        try {
            return e.defaultView && e.defaultView.frameElement || null
        } catch (e2) {
            return null
        }
    }
    function i(e) {
        this.time = e.time,
        this.target = e.target,
        this.rootBounds = u(e.rootBounds),
        this.boundingClientRect = u(e.boundingClientRect),
        this.intersectionRect = u(e.intersectionRect || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        }),
        this.isIntersecting = !!e.intersectionRect;
        var t = this.boundingClientRect
          , n = t.width * t.height
          , r = this.intersectionRect
          , o = r.width * r.height;
        this.intersectionRatio = n ? Number((o / n).toFixed(4)) : this.isIntersecting ? 1 : 0
    }
    function a(e, t) {
        var n, r, o, i = t || {};
        if ("function" != typeof e)
            throw new Error("callback must be a function");
        if (i.root && 1 != i.root.nodeType && 9 != i.root.nodeType)
            throw new Error("root must be a Document or Element");
        this._checkForIntersections = (n = this._checkForIntersections.bind(this),
        r = this.THROTTLE_TIMEOUT,
        o = null,
        function() {
            o || (o = setTimeout((function() {
                n(),
                o = null
            }
            ), r))
        }
        ),
        this._callback = e,
        this._observationTargets = [],
        this._queuedEntries = [],
        this._rootMarginValues = this._parseRootMargin(i.rootMargin),
        this.thresholds = this._initThresholds(i.threshold),
        this.root = i.root || null,
        this.rootMargin = this._rootMarginValues.map((function(e) {
            return e.value + e.unit
        }
        )).join(" "),
        this._monitoringDocuments = [],
        this._monitoringUnsubscribes = []
    }
    function s(e, t, n, r) {
        "function" == typeof e.addEventListener ? e.addEventListener(t, n, r) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n)
    }
    function c(e, t, n, r) {
        "function" == typeof e.removeEventListener ? e.removeEventListener(t, n, r) : "function" == typeof e.detachEvent && e.detachEvent("on" + t, n)
    }
    function l(e) {
        var t;
        try {
            t = e.getBoundingClientRect()
        } catch (n) {}
        return t ? (t.width && t.height || (t = {
            top: t.top,
            right: t.right,
            bottom: t.bottom,
            left: t.left,
            width: t.right - t.left,
            height: t.bottom - t.top
        }),
        t) : {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        }
    }
    function u(e) {
        return !e || "x"in e ? e : {
            top: e.top,
            y: e.top,
            bottom: e.bottom,
            left: e.left,
            x: e.left,
            right: e.right,
            width: e.width,
            height: e.height
        }
    }
    function p(e, t) {
        var n = t.top - e.top
          , r = t.left - e.left;
        return {
            top: n,
            left: r,
            height: t.height,
            width: t.width,
            bottom: n + t.height,
            right: r + t.width
        }
    }
    function d(e, t) {
        for (var n = t; n; ) {
            if (n == e)
                return !0;
            n = f(n)
        }
        return !1
    }
    function f(t) {
        var n = t.parentNode;
        return 9 == t.nodeType && t != e ? o(t) : (n && n.assignedSlot && (n = n.assignedSlot.parentNode),
        n && 11 == n.nodeType && n.host ? n.host : n)
    }
    function h(e) {
        return e && 9 === e.nodeType
    }
}();
const EMPTY_OBJ = {}
  , EMPTY_ARR = []
  , NOOP = () => {}
  , NO = () => !1
  , isOn = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
  , isModelListener = e => e.startsWith("onUpdate:")
  , extend$2 = Object.assign
  , remove = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
  , hasOwnProperty$3 = Object.prototype.hasOwnProperty
  , hasOwn$1 = (e, t) => hasOwnProperty$3.call(e, t)
  , isArray$2 = Array.isArray
  , isMap = e => "[object Map]" === toTypeString(e)
  , isSet = e => "[object Set]" === toTypeString(e)
  , isDate$1 = e => "[object Date]" === toTypeString(e)
  , isRegExp$1 = e => "[object RegExp]" === toTypeString(e)
  , isFunction$3 = e => "function" == typeof e
  , isString$2 = e => "string" == typeof e
  , isSymbol = e => "symbol" == typeof e
  , isObject$1 = e => null !== e && "object" == typeof e
  , isPromise$1 = e => (isObject$1(e) || isFunction$3(e)) && isFunction$3(e.then) && isFunction$3(e.catch)
  , objectToString = Object.prototype.toString
  , toTypeString = e => objectToString.call(e)
  , toRawType = e => toTypeString(e).slice(8, -1)
  , isPlainObject$1 = e => "[object Object]" === toTypeString(e)
  , isIntegerKey = e => isString$2(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e
  , isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , cacheStringFunction = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
}
  , camelizeRE = /-(\w)/g
  , camelize = cacheStringFunction((e => e.replace(camelizeRE, ( (e, t) => t ? t.toUpperCase() : ""))))
  , hyphenateRE = /\B([A-Z])/g
  , hyphenate = cacheStringFunction((e => e.replace(hyphenateRE, "-$1").toLowerCase()))
  , capitalize = cacheStringFunction((e => e.charAt(0).toUpperCase() + e.slice(1)))
  , toHandlerKey = cacheStringFunction((e => e ? "on".concat(capitalize(e)) : ""))
  , hasChanged = (e, t) => !Object.is(e, t)
  , invokeArrayFns = (e, ...t) => {
    for (let n = 0; n < e.length; n++)
        e[n](...t)
}
  , def = (e, t, n, r=!1) => {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        writable: r,
        value: n
    })
}
  , looseToNumber = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
  , toNumber = e => {
    const t = isString$2(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
}
;
let _globalThis;
const getGlobalThis = () => _globalThis || (_globalThis = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
function normalizeStyle(e) {
    if (isArray$2(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
              , o = isString$2(r) ? parseStringStyle(r) : normalizeStyle(r);
            if (o)
                for (const e in o)
                    t[e] = o[e]
        }
        return t
    }
    if (isString$2(e) || isObject$1(e))
        return e
}
const listDelimiterRE = /;(?![^(]*\))/g
  , propertyDelimiterRE = /:([^]+)/
  , styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(e) {
    const t = {};
    return e.replace(styleCommentRE, "").split(listDelimiterRE).forEach((e => {
        if (e) {
            const n = e.split(propertyDelimiterRE);
            n.length > 1 && (t[n[0].trim()] = n[1].trim())
        }
    }
    )),
    t
}
function normalizeClass(e) {
    let t = "";
    if (isString$2(e))
        t = e;
    else if (isArray$2(e))
        for (let n = 0; n < e.length; n++) {
            const r = normalizeClass(e[n]);
            r && (t += r + " ")
        }
    else if (isObject$1(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function normalizeProps(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !isString$2(t) && (e.class = normalizeClass(t)),
    n && (e.style = normalizeStyle(n)),
    e
}
const specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
function includeBooleanAttr(e) {
    return !!e || "" === e
}
function looseCompareArrays(e, t) {
    if (e.length !== t.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++)
        n = looseEqual(e[r], t[r]);
    return n
}
function looseEqual(e, t) {
    if (e === t)
        return !0;
    let n = isDate$1(e)
      , r = isDate$1(t);
    if (n || r)
        return !(!n || !r) && e.getTime() === t.getTime();
    if (n = isSymbol(e),
    r = isSymbol(t),
    n || r)
        return e === t;
    if (n = isArray$2(e),
    r = isArray$2(t),
    n || r)
        return !(!n || !r) && looseCompareArrays(e, t);
    if (n = isObject$1(e),
    r = isObject$1(t),
    n || r) {
        if (!n || !r)
            return !1;
        if (Object.keys(e).length !== Object.keys(t).length)
            return !1;
        for (const n in e) {
            const r = e.hasOwnProperty(n)
              , o = t.hasOwnProperty(n);
            if (r && !o || !r && o || !looseEqual(e[n], t[n]))
                return !1
        }
    }
    return String(e) === String(t)
}
const isRef$1 = e => !(!e || !0 !== e.__v_isRef)
  , toDisplayString = e => isString$2(e) ? e : null == e ? "" : isArray$2(e) || isObject$1(e) && (e.toString === objectToString || !isFunction$3(e.toString)) ? isRef$1(e) ? toDisplayString(e.value) : JSON.stringify(e, replacer, 2) : String(e)
  , replacer = (e, t) => isRef$1(t) ? replacer(e, t.value) : isMap(t) ? {
    ["Map(".concat(t.size, ")")]: [...t.entries()].reduce(( (e, [t,n], r) => (e[stringifySymbol(t, r) + " =>"] = n,
    e)), {})
} : isSet(t) ? {
    ["Set(".concat(t.size, ")")]: [...t.values()].map((e => stringifySymbol(e)))
} : isSymbol(t) ? stringifySymbol(t) : !isObject$1(t) || isArray$2(t) || isPlainObject$1(t) ? t : String(t)
  , stringifySymbol = (e, t="") => {
    var n;
    return isSymbol(e) ? "Symbol(".concat(null != (n = e.description) ? n : t, ")") : e
}
;
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope, activeSub;
class EffectScope {
    constructor(e=!1) {
        this.detached = e,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = activeEffectScope,
        !e && activeEffectScope && (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            let e, t;
            if (this._isPaused = !0,
            this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].pause();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            let e, t;
            if (this._isPaused = !1,
            this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].resume();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].resume()
        }
    }
    run(e) {
        if (this._active) {
            const t = activeEffectScope;
            try {
                return activeEffectScope = this,
                e()
            } finally {
                activeEffectScope = t
            }
        }
    }
    on() {
        activeEffectScope = this
    }
    off() {
        activeEffectScope = this.parent
    }
    stop(e) {
        if (this._active) {
            let t, n;
            for (this._active = !1,
            t = 0,
            n = this.effects.length; t < n; t++)
                this.effects[t].stop();
            for (this.effects.length = 0,
            t = 0,
            n = this.cleanups.length; t < n; t++)
                this.cleanups[t]();
            if (this.cleanups.length = 0,
            this.scopes) {
                for (t = 0,
                n = this.scopes.length; t < n; t++)
                    this.scopes[t].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !e) {
                const e = this.parent.scopes.pop();
                e && e !== this && (this.parent.scopes[this.index] = e,
                e.index = this.index)
            }
            this.parent = void 0
        }
    }
}
function effectScope(e) {
    return new EffectScope(e)
}
function getCurrentScope() {
    return activeEffectScope
}
function onScopeDispose(e, t=!1) {
    activeEffectScope && activeEffectScope.cleanups.push(e)
}
const pausedQueueEffects = new WeakSet;
class ReactiveEffect {
    constructor(e) {
        this.fn = e,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        activeEffectScope && activeEffectScope.active && activeEffectScope.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        64 & this.flags && (this.flags &= -65,
        pausedQueueEffects.has(this) && (pausedQueueEffects.delete(this),
        this.trigger()))
    }
    notify() {
        2 & this.flags && !(32 & this.flags) || 8 & this.flags || batch(this)
    }
    run() {
        if (!(1 & this.flags))
            return this.fn();
        this.flags |= 2,
        cleanupEffect(this),
        prepareDeps(this);
        const e = activeSub
          , t = shouldTrack;
        activeSub = this,
        shouldTrack = !0;
        try {
            return this.fn()
        } finally {
            cleanupDeps(this),
            activeSub = e,
            shouldTrack = t,
            this.flags &= -3
        }
    }
    stop() {
        if (1 & this.flags) {
            for (let e = this.deps; e; e = e.nextDep)
                removeSub(e);
            this.deps = this.depsTail = void 0,
            cleanupEffect(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger() {
        64 & this.flags ? pausedQueueEffects.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        isDirty(this) && this.run()
    }
    get dirty() {
        return isDirty(this)
    }
}
let batchDepth = 0, batchedSub, batchedComputed;
function batch(e, t=!1) {
    if (e.flags |= 8,
    t)
        return e.next = batchedComputed,
        void (batchedComputed = e);
    e.next = batchedSub,
    batchedSub = e
}
function startBatch() {
    batchDepth++
}
function endBatch() {
    if (--batchDepth > 0)
        return;
    if (batchedComputed) {
        let e = batchedComputed;
        for (batchedComputed = void 0; e; ) {
            const t = e.next;
            e.next = void 0,
            e.flags &= -9,
            e = t
        }
    }
    let e;
    for (; batchedSub; ) {
        let n = batchedSub;
        for (batchedSub = void 0; n; ) {
            const r = n.next;
            if (n.next = void 0,
            n.flags &= -9,
            1 & n.flags)
                try {
                    n.trigger()
                } catch (t) {
                    e || (e = t)
                }
            n = r
        }
    }
    if (e)
        throw e
}
function prepareDeps(e) {
    for (let t = e.deps; t; t = t.nextDep)
        t.version = -1,
        t.prevActiveLink = t.dep.activeLink,
        t.dep.activeLink = t
}
function cleanupDeps(e) {
    let t, n = e.depsTail, r = n;
    for (; r; ) {
        const e = r.prevDep;
        -1 === r.version ? (r === n && (n = e),
        removeSub(r),
        removeDep(r)) : t = r,
        r.dep.activeLink = r.prevActiveLink,
        r.prevActiveLink = void 0,
        r = e
    }
    e.deps = t,
    e.depsTail = n
}
function isDirty(e) {
    for (let t = e.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || t.dep.computed && (refreshComputed(t.dep.computed) || t.dep.version !== t.version))
            return !0;
    return !!e._dirty
}
function refreshComputed(e) {
    if (4 & e.flags && !(16 & e.flags))
        return;
    if (e.flags &= -17,
    e.globalVersion === globalVersion)
        return;
    e.globalVersion = globalVersion;
    const t = e.dep;
    if (e.flags |= 2,
    t.version > 0 && !e.isSSR && e.deps && !isDirty(e))
        return void (e.flags &= -3);
    const n = activeSub
      , r = shouldTrack;
    activeSub = e,
    shouldTrack = !0;
    try {
        prepareDeps(e);
        const n = e.fn(e._value);
        (0 === t.version || hasChanged(n, e._value)) && (e._value = n,
        t.version++)
    } catch (o) {
        throw t.version++,
        o
    } finally {
        activeSub = n,
        shouldTrack = r,
        cleanupDeps(e),
        e.flags &= -3
    }
}
function removeSub(e, t=!1) {
    const {dep: n, prevSub: r, nextSub: o} = e;
    if (r && (r.nextSub = o,
    e.prevSub = void 0),
    o && (o.prevSub = r,
    e.nextSub = void 0),
    n.subs === e && (n.subs = r,
    !r && n.computed)) {
        n.computed.flags &= -5;
        for (let e = n.computed.deps; e; e = e.nextDep)
            removeSub(e, !0)
    }
    t || --n.sc || !n.map || n.map.delete(n.key)
}
function removeDep(e) {
    const {prevDep: t, nextDep: n} = e;
    t && (t.nextDep = n,
    e.prevDep = void 0),
    n && (n.prevDep = t,
    e.nextDep = void 0)
}
let shouldTrack = !0;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack),
    shouldTrack = !1
}
function resetTracking() {
    const e = trackStack.pop();
    shouldTrack = void 0 === e || e
}
function cleanupEffect(e) {
    const {cleanup: t} = e;
    if (e.cleanup = void 0,
    t) {
        const e = activeSub;
        activeSub = void 0;
        try {
            t()
        } finally {
            activeSub = e
        }
    }
}
let globalVersion = 0;
class Link {
    constructor(e, t) {
        this.sub = e,
        this.dep = t,
        this.version = t.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class Dep {
    constructor(e) {
        this.computed = e,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.map = void 0,
        this.key = void 0,
        this.sc = 0
    }
    track(e) {
        if (!activeSub || !shouldTrack || activeSub === this.computed)
            return;
        let t = this.activeLink;
        if (void 0 === t || t.sub !== activeSub)
            t = this.activeLink = new Link(activeSub,this),
            activeSub.deps ? (t.prevDep = activeSub.depsTail,
            activeSub.depsTail.nextDep = t,
            activeSub.depsTail = t) : activeSub.deps = activeSub.depsTail = t,
            addSub(t);
        else if (-1 === t.version && (t.version = this.version,
        t.nextDep)) {
            const e = t.nextDep;
            e.prevDep = t.prevDep,
            t.prevDep && (t.prevDep.nextDep = e),
            t.prevDep = activeSub.depsTail,
            t.nextDep = void 0,
            activeSub.depsTail.nextDep = t,
            activeSub.depsTail = t,
            activeSub.deps === t && (activeSub.deps = e)
        }
        return t
    }
    trigger(e) {
        this.version++,
        globalVersion++,
        this.notify(e)
    }
    notify(e) {
        startBatch();
        try {
            0;
            for (let e = this.subs; e; e = e.prevSub)
                e.sub.notify() && e.sub.dep.notify()
        } finally {
            endBatch()
        }
    }
}
function addSub(e) {
    if (e.dep.sc++,
    4 & e.sub.flags) {
        const t = e.dep.computed;
        if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let e = t.deps; e; e = e.nextDep)
                addSub(e)
        }
        const n = e.dep.subs;
        n !== e && (e.prevSub = n,
        n && (n.nextSub = e)),
        e.dep.subs = e
    }
}
const targetMap = new WeakMap
  , ITERATE_KEY = Symbol("")
  , MAP_KEY_ITERATE_KEY = Symbol("")
  , ARRAY_ITERATE_KEY = Symbol("");
function track(e, t, n) {
    if (shouldTrack && activeSub) {
        let t = targetMap.get(e);
        t || targetMap.set(e, t = new Map);
        let r = t.get(n);
        r || (t.set(n, r = new Dep),
        r.map = t,
        r.key = n),
        r.track()
    }
}
function trigger(e, t, n, r, o, i) {
    const a = targetMap.get(e);
    if (!a)
        return void globalVersion++;
    const s = e => {
        e && e.trigger()
    }
    ;
    if (startBatch(),
    "clear" === t)
        a.forEach(s);
    else {
        const o = isArray$2(e)
          , i = o && isIntegerKey(n);
        if (o && "length" === n) {
            const e = Number(r);
            a.forEach(( (t, n) => {
                ("length" === n || n === ARRAY_ITERATE_KEY || !isSymbol(n) && n >= e) && s(t)
            }
            ))
        } else
            switch ((void 0 !== n || a.has(void 0)) && s(a.get(n)),
            i && s(a.get(ARRAY_ITERATE_KEY)),
            t) {
            case "add":
                o ? i && s(a.get("length")) : (s(a.get(ITERATE_KEY)),
                isMap(e) && s(a.get(MAP_KEY_ITERATE_KEY)));
                break;
            case "delete":
                o || (s(a.get(ITERATE_KEY)),
                isMap(e) && s(a.get(MAP_KEY_ITERATE_KEY)));
                break;
            case "set":
                isMap(e) && s(a.get(ITERATE_KEY))
            }
    }
    endBatch()
}
function getDepFromReactive(e, t) {
    const n = targetMap.get(e);
    return n && n.get(t)
}
function reactiveReadArray(e) {
    const t = toRaw(e);
    return t === e ? t : (track(t, "iterate", ARRAY_ITERATE_KEY),
    isShallow(e) ? t : t.map(toReactive))
}
function shallowReadArray(e) {
    return track(e = toRaw(e), "iterate", ARRAY_ITERATE_KEY),
    e
}
const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
        return iterator$1(this, Symbol.iterator, toReactive)
    },
    concat(...e) {
        return reactiveReadArray(this).concat(...e.map((e => isArray$2(e) ? reactiveReadArray(e) : e)))
    },
    entries() {
        return iterator$1(this, "entries", (e => (e[1] = toReactive(e[1]),
        e)))
    },
    every(e, t) {
        return apply(this, "every", e, t, void 0, arguments)
    },
    filter(e, t) {
        return apply(this, "filter", e, t, (e => e.map(toReactive)), arguments)
    },
    find(e, t) {
        return apply(this, "find", e, t, toReactive, arguments)
    },
    findIndex(e, t) {
        return apply(this, "findIndex", e, t, void 0, arguments)
    },
    findLast(e, t) {
        return apply(this, "findLast", e, t, toReactive, arguments)
    },
    findLastIndex(e, t) {
        return apply(this, "findLastIndex", e, t, void 0, arguments)
    },
    forEach(e, t) {
        return apply(this, "forEach", e, t, void 0, arguments)
    },
    includes(...e) {
        return searchProxy(this, "includes", e)
    },
    indexOf(...e) {
        return searchProxy(this, "indexOf", e)
    },
    join(e) {
        return reactiveReadArray(this).join(e)
    },
    lastIndexOf(...e) {
        return searchProxy(this, "lastIndexOf", e)
    },
    map(e, t) {
        return apply(this, "map", e, t, void 0, arguments)
    },
    pop() {
        return noTracking(this, "pop")
    },
    push(...e) {
        return noTracking(this, "push", e)
    },
    reduce(e, ...t) {
        return reduce(this, "reduce", e, t)
    },
    reduceRight(e, ...t) {
        return reduce(this, "reduceRight", e, t)
    },
    shift() {
        return noTracking(this, "shift")
    },
    some(e, t) {
        return apply(this, "some", e, t, void 0, arguments)
    },
    splice(...e) {
        return noTracking(this, "splice", e)
    },
    toReversed() {
        return reactiveReadArray(this).toReversed()
    },
    toSorted(e) {
        return reactiveReadArray(this).toSorted(e)
    },
    toSpliced(...e) {
        return reactiveReadArray(this).toSpliced(...e)
    },
    unshift(...e) {
        return noTracking(this, "unshift", e)
    },
    values() {
        return iterator$1(this, "values", toReactive)
    }
};
function iterator$1(e, t, n) {
    const r = shallowReadArray(e)
      , o = r[t]();
    return r === e || isShallow(e) || (o._next = o.next,
    o.next = () => {
        const e = o._next();
        return e.value && (e.value = n(e.value)),
        e
    }
    ),
    o
}
const arrayProto = Array.prototype;
function apply(e, t, n, r, o, i) {
    const a = shallowReadArray(e)
      , s = a !== e && !isShallow(e)
      , c = a[t];
    if (c !== arrayProto[t]) {
        const t = c.apply(e, i);
        return s ? toReactive(t) : t
    }
    let l = n;
    a !== e && (s ? l = function(t, r) {
        return n.call(this, toReactive(t), r, e)
    }
    : n.length > 2 && (l = function(t, r) {
        return n.call(this, t, r, e)
    }
    ));
    const u = c.call(a, l, r);
    return s && o ? o(u) : u
}
function reduce(e, t, n, r) {
    const o = shallowReadArray(e);
    let i = n;
    return o !== e && (isShallow(e) ? n.length > 3 && (i = function(t, r, o) {
        return n.call(this, t, r, o, e)
    }
    ) : i = function(t, r, o) {
        return n.call(this, t, toReactive(r), o, e)
    }
    ),
    o[t](i, ...r)
}
function searchProxy(e, t, n) {
    const r = toRaw(e);
    track(r, "iterate", ARRAY_ITERATE_KEY);
    const o = r[t](...n);
    return -1 !== o && !1 !== o || !isProxy(n[0]) ? o : (n[0] = toRaw(n[0]),
    r[t](...n))
}
function noTracking(e, t, n=[]) {
    pauseTracking(),
    startBatch();
    const r = toRaw(e)[t].apply(e, n);
    return endBatch(),
    resetTracking(),
    r
}
const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue")
  , builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter((e => "arguments" !== e && "caller" !== e)).map((e => Symbol[e])).filter(isSymbol));
function hasOwnProperty$2(e) {
    isSymbol(e) || (e = String(e));
    const t = toRaw(this);
    return track(t, "has", e),
    t.hasOwnProperty(e)
}
class BaseReactiveHandler {
    constructor(e=!1, t=!1) {
        this._isReadonly = e,
        this._isShallow = t
    }
    get(e, t, n) {
        if ("__v_skip" === t)
            return e.__v_skip;
        const r = this._isReadonly
          , o = this._isShallow;
        if ("__v_isReactive" === t)
            return !r;
        if ("__v_isReadonly" === t)
            return r;
        if ("__v_isShallow" === t)
            return o;
        if ("__v_raw" === t)
            return n === (r ? o ? shallowReadonlyMap : readonlyMap : o ? shallowReactiveMap : reactiveMap).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
        const i = isArray$2(e);
        if (!r) {
            let e;
            if (i && (e = arrayInstrumentations[t]))
                return e;
            if ("hasOwnProperty" === t)
                return hasOwnProperty$2
        }
        const a = Reflect.get(e, t, isRef(e) ? e : n);
        return (isSymbol(t) ? builtInSymbols.has(t) : isNonTrackableKeys(t)) ? a : (r || track(e, "get", t),
        o ? a : isRef(a) ? i && isIntegerKey(t) ? a : a.value : isObject$1(a) ? r ? readonly(a) : reactive(a) : a)
    }
}
class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(e=!1) {
        super(!1, e)
    }
    set(e, t, n, r) {
        let o = e[t];
        if (!this._isShallow) {
            const t = isReadonly(o);
            if (isShallow(n) || isReadonly(n) || (o = toRaw(o),
            n = toRaw(n)),
            !isArray$2(e) && isRef(o) && !isRef(n))
                return !t && (o.value = n,
                !0)
        }
        const i = isArray$2(e) && isIntegerKey(t) ? Number(t) < e.length : hasOwn$1(e, t)
          , a = Reflect.set(e, t, n, isRef(e) ? e : r);
        return e === toRaw(r) && (i ? hasChanged(n, o) && trigger(e, "set", t, n) : trigger(e, "add", t, n)),
        a
    }
    deleteProperty(e, t) {
        const n = hasOwn$1(e, t);
        e[t];
        const r = Reflect.deleteProperty(e, t);
        return r && n && trigger(e, "delete", t, void 0),
        r
    }
    has(e, t) {
        const n = Reflect.has(e, t);
        return isSymbol(t) && builtInSymbols.has(t) || track(e, "has", t),
        n
    }
    ownKeys(e) {
        return track(e, "iterate", isArray$2(e) ? "length" : ITERATE_KEY),
        Reflect.ownKeys(e)
    }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(e=!1) {
        super(!0, e)
    }
    set(e, t) {
        return !0
    }
    deleteProperty(e, t) {
        return !0
    }
}
const mutableHandlers = new MutableReactiveHandler
  , readonlyHandlers = new ReadonlyReactiveHandler
  , shallowReactiveHandlers = new MutableReactiveHandler(!0)
  , shallowReadonlyHandlers = new ReadonlyReactiveHandler(!0)
  , toShallow = e => e
  , getProto$1 = e => Reflect.getPrototypeOf(e);
function createIterableMethod(e, t, n) {
    return function(...r) {
        const o = this.__v_raw
          , i = toRaw(o)
          , a = isMap(i)
          , s = "entries" === e || e === Symbol.iterator && a
          , c = "keys" === e && a
          , l = o[e](...r)
          , u = n ? toShallow : t ? toReadonly : toReactive;
        return !t && track(i, "iterate", c ? MAP_KEY_ITERATE_KEY : ITERATE_KEY),
        {
            next() {
                const {value: e, done: t} = l.next();
                return t ? {
                    value: e,
                    done: t
                } : {
                    value: s ? [u(e[0]), u(e[1])] : u(e),
                    done: t
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function createReadonlyMethod(e) {
    return function(...t) {
        return "delete" !== e && ("clear" === e ? void 0 : this)
    }
}
function createInstrumentations(e, t) {
    const n = {
        get(n) {
            const r = this.__v_raw
              , o = toRaw(r)
              , i = toRaw(n);
            e || (hasChanged(n, i) && track(o, "get", n),
            track(o, "get", i));
            const {has: a} = getProto$1(o)
              , s = t ? toShallow : e ? toReadonly : toReactive;
            return a.call(o, n) ? s(r.get(n)) : a.call(o, i) ? s(r.get(i)) : void (r !== o && r.get(n))
        },
        get size() {
            const t = this.__v_raw;
            return !e && track(toRaw(t), "iterate", ITERATE_KEY),
            Reflect.get(t, "size", t)
        },
        has(t) {
            const n = this.__v_raw
              , r = toRaw(n)
              , o = toRaw(t);
            return e || (hasChanged(t, o) && track(r, "has", t),
            track(r, "has", o)),
            t === o ? n.has(t) : n.has(t) || n.has(o)
        },
        forEach(n, r) {
            const o = this
              , i = o.__v_raw
              , a = toRaw(i)
              , s = t ? toShallow : e ? toReadonly : toReactive;
            return !e && track(a, "iterate", ITERATE_KEY),
            i.forEach(( (e, t) => n.call(r, s(e), s(t), o)))
        }
    };
    extend$2(n, e ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
    } : {
        add(e) {
            t || isShallow(e) || isReadonly(e) || (e = toRaw(e));
            const n = toRaw(this);
            return getProto$1(n).has.call(n, e) || (n.add(e),
            trigger(n, "add", e, e)),
            this
        },
        set(e, n) {
            t || isShallow(n) || isReadonly(n) || (n = toRaw(n));
            const r = toRaw(this)
              , {has: o, get: i} = getProto$1(r);
            let a = o.call(r, e);
            a || (e = toRaw(e),
            a = o.call(r, e));
            const s = i.call(r, e);
            return r.set(e, n),
            a ? hasChanged(n, s) && trigger(r, "set", e, n) : trigger(r, "add", e, n),
            this
        },
        delete(e) {
            const t = toRaw(this)
              , {has: n, get: r} = getProto$1(t);
            let o = n.call(t, e);
            o || (e = toRaw(e),
            o = n.call(t, e)),
            r && r.call(t, e);
            const i = t.delete(e);
            return o && trigger(t, "delete", e, void 0),
            i
        },
        clear() {
            const e = toRaw(this)
              , t = 0 !== e.size
              , n = e.clear();
            return t && trigger(e, "clear", void 0, void 0),
            n
        }
    });
    return ["keys", "values", "entries", Symbol.iterator].forEach((r => {
        n[r] = createIterableMethod(r, e, t)
    }
    )),
    n
}
function createInstrumentationGetter(e, t) {
    const n = createInstrumentations(e, t);
    return (t, r, o) => "__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(hasOwn$1(n, r) && r in t ? n : t, r, o)
}
const mutableCollectionHandlers = {
    get: createInstrumentationGetter(!1, !1)
}
  , shallowCollectionHandlers = {
    get: createInstrumentationGetter(!1, !0)
}
  , readonlyCollectionHandlers = {
    get: createInstrumentationGetter(!0, !1)
}
  , shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(!0, !0)
}
  , reactiveMap = new WeakMap
  , shallowReactiveMap = new WeakMap
  , readonlyMap = new WeakMap
  , shallowReadonlyMap = new WeakMap;
function targetTypeMap(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function getTargetType(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : targetTypeMap(toRawType(e))
}
function reactive(e) {
    return isReadonly(e) ? e : createReactiveObject(e, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap)
}
function shallowReactive(e) {
    return createReactiveObject(e, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap)
}
function readonly(e) {
    return createReactiveObject(e, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap)
}
function shallowReadonly(e) {
    return createReactiveObject(e, !0, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap)
}
function createReactiveObject(e, t, n, r, o) {
    if (!isObject$1(e))
        return e;
    if (e.__v_raw && (!t || !e.__v_isReactive))
        return e;
    const i = o.get(e);
    if (i)
        return i;
    const a = getTargetType(e);
    if (0 === a)
        return e;
    const s = new Proxy(e,2 === a ? r : n);
    return o.set(e, s),
    s
}
function isReactive(e) {
    return isReadonly(e) ? isReactive(e.__v_raw) : !(!e || !e.__v_isReactive)
}
function isReadonly(e) {
    return !(!e || !e.__v_isReadonly)
}
function isShallow(e) {
    return !(!e || !e.__v_isShallow)
}
function isProxy(e) {
    return !!e && !!e.__v_raw
}
function toRaw(e) {
    const t = e && e.__v_raw;
    return t ? toRaw(t) : e
}
function markRaw(e) {
    return !hasOwn$1(e, "__v_skip") && Object.isExtensible(e) && def(e, "__v_skip", !0),
    e
}
const toReactive = e => isObject$1(e) ? reactive(e) : e
  , toReadonly = e => isObject$1(e) ? readonly(e) : e;
function isRef(e) {
    return !!e && !0 === e.__v_isRef
}
function ref(e) {
    return createRef(e, !1)
}
function shallowRef(e) {
    return createRef(e, !0)
}
function createRef(e, t) {
    return isRef(e) ? e : new RefImpl(e,t)
}
class RefImpl {
    constructor(e, t) {
        this.dep = new Dep,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = t ? e : toRaw(e),
        this._value = t ? e : toReactive(e),
        this.__v_isShallow = t
    }
    get value() {
        return this.dep.track(),
        this._value
    }
    set value(e) {
        const t = this._rawValue
          , n = this.__v_isShallow || isShallow(e) || isReadonly(e);
        e = n ? e : toRaw(e),
        hasChanged(e, t) && (this._rawValue = e,
        this._value = n ? e : toReactive(e),
        this.dep.trigger())
    }
}
function unref(e) {
    return isRef(e) ? e.value : e
}
const shallowUnwrapHandlers = {
    get: (e, t, n) => "__v_raw" === t ? e : unref(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
        const o = e[t];
        return isRef(o) && !isRef(n) ? (o.value = n,
        !0) : Reflect.set(e, t, n, r)
    }
};
function proxyRefs(e) {
    return isReactive(e) ? e : new Proxy(e,shallowUnwrapHandlers)
}
class CustomRefImpl {
    constructor(e) {
        this.__v_isRef = !0,
        this._value = void 0;
        const t = this.dep = new Dep
          , {get: n, set: r} = e(t.track.bind(t), t.trigger.bind(t));
        this._get = n,
        this._set = r
    }
    get value() {
        return this._value = this._get()
    }
    set value(e) {
        this._set(e)
    }
}
function customRef(e) {
    return new CustomRefImpl(e)
}
function toRefs(e) {
    const t = isArray$2(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = propertyToRef(e, n);
    return t
}
class ObjectRefImpl {
    constructor(e, t, n) {
        this._object = e,
        this._key = t,
        this._defaultValue = n,
        this.__v_isRef = !0,
        this._value = void 0
    }
    get value() {
        const e = this._object[this._key];
        return this._value = void 0 === e ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key)
    }
}
function propertyToRef(e, t, n) {
    const r = e[t];
    return isRef(r) ? r : new ObjectRefImpl(e,t,n)
}
class ComputedRefImpl {
    constructor(e, t, n) {
        this.fn = e,
        this.setter = t,
        this._value = void 0,
        this.dep = new Dep(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = globalVersion - 1,
        this.next = void 0,
        this.effect = this,
        this.__v_isReadonly = !t,
        this.isSSR = n
    }
    notify() {
        if (this.flags |= 16,
        !(8 & this.flags) && activeSub !== this)
            return batch(this, !0),
            !0
    }
    get value() {
        const e = this.dep.track();
        return refreshComputed(this),
        e && (e.version = this.dep.version),
        this._value
    }
    set value(e) {
        this.setter && this.setter(e)
    }
}
function computed$1(e, t, n=!1) {
    let r, o;
    isFunction$3(e) ? r = e : (r = e.get,
    o = e.set);
    return new ComputedRefImpl(r,o,n)
}
const INITIAL_WATCHER_VALUE = {}
  , cleanupMap = new WeakMap;
let activeWatcher;
function onWatcherCleanup(e, t=!1, n=activeWatcher) {
    if (n) {
        let t = cleanupMap.get(n);
        t || cleanupMap.set(n, t = []),
        t.push(e)
    }
}
function watch$1(e, t, n=EMPTY_OBJ) {
    const {immediate: r, deep: o, once: i, scheduler: a, augmentJob: s, call: c} = n
      , l = e => o ? e : isShallow(e) || !1 === o || 0 === o ? traverse(e, 1) : traverse(e);
    let u, p, d, f, h = !1, m = !1;
    if (isRef(e) ? (p = () => e.value,
    h = isShallow(e)) : isReactive(e) ? (p = () => l(e),
    h = !0) : isArray$2(e) ? (m = !0,
    h = e.some((e => isReactive(e) || isShallow(e))),
    p = () => e.map((e => isRef(e) ? e.value : isReactive(e) ? l(e) : isFunction$3(e) ? c ? c(e, 2) : e() : void 0))) : p = isFunction$3(e) ? t ? c ? () => c(e, 2) : e : () => {
        if (d) {
            pauseTracking();
            try {
                d()
            } finally {
                resetTracking()
            }
        }
        const t = activeWatcher;
        activeWatcher = u;
        try {
            return c ? c(e, 3, [f]) : e(f)
        } finally {
            activeWatcher = t
        }
    }
    : NOOP,
    t && o) {
        const e = p
          , t = !0 === o ? 1 / 0 : o;
        p = () => traverse(e(), t)
    }
    const g = getCurrentScope()
      , v = () => {
        u.stop(),
        g && g.active && remove(g.effects, u)
    }
    ;
    if (i && t) {
        const e = t;
        t = (...t) => {
            e(...t),
            v()
        }
    }
    let y = m ? new Array(e.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const _ = e => {
        if (1 & u.flags && (u.dirty || e))
            if (t) {
                const e = u.run();
                if (o || h || (m ? e.some(( (e, t) => hasChanged(e, y[t]))) : hasChanged(e, y))) {
                    d && d();
                    const n = activeWatcher;
                    activeWatcher = u;
                    try {
                        const n = [e, y === INITIAL_WATCHER_VALUE ? void 0 : m && y[0] === INITIAL_WATCHER_VALUE ? [] : y, f];
                        c ? c(t, 3, n) : t(...n),
                        y = e
                    } finally {
                        activeWatcher = n
                    }
                }
            } else
                u.run()
    }
    ;
    return s && s(_),
    u = new ReactiveEffect(p),
    u.scheduler = a ? () => a(_, !1) : _,
    f = e => onWatcherCleanup(e, !1, u),
    d = u.onStop = () => {
        const e = cleanupMap.get(u);
        if (e) {
            if (c)
                c(e, 4);
            else
                for (const t of e)
                    t();
            cleanupMap.delete(u)
        }
    }
    ,
    t ? r ? _(!0) : y = u.run() : a ? a(_.bind(null, !0), !0) : u.run(),
    v.pause = u.pause.bind(u),
    v.resume = u.resume.bind(u),
    v.stop = v,
    v
}
function traverse(e, t=1 / 0, n) {
    if (t <= 0 || !isObject$1(e) || e.__v_skip)
        return e;
    if ((n = n || new Set).has(e))
        return e;
    if (n.add(e),
    t--,
    isRef(e))
        traverse(e.value, t, n);
    else if (isArray$2(e))
        for (let r = 0; r < e.length; r++)
            traverse(e[r], t, n);
    else if (isSet(e) || isMap(e))
        e.forEach((e => {
            traverse(e, t, n)
        }
        ));
    else if (isPlainObject$1(e)) {
        for (const r in e)
            traverse(e[r], t, n);
        for (const r of Object.getOwnPropertySymbols(e))
            Object.prototype.propertyIsEnumerable.call(e, r) && traverse(e[r], t, n)
    }
    return e
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = !1;
function warn$1(e, ...t) {
    if (isWarning)
        return;
    isWarning = !0,
    pauseTracking();
    const n = stack.length ? stack[stack.length - 1].component : null
      , r = n && n.appContext.config.warnHandler
      , o = getComponentTrace();
    if (r)
        callWithErrorHandling(r, n, 11, [e + t.map((e => {
            var t, n;
            return null != (n = null == (t = e.toString) ? void 0 : t.call(e)) ? n : JSON.stringify(e)
        }
        )).join(""), n && n.proxy, o.map(( ({vnode: e}) => "at <".concat(formatComponentName(n, e.type), ">"))).join("\n"), o]);
    else {
        const n = ["[Vue warn]: ".concat(e), ...t];
        o.length && n.push("\n", ...formatTrace(o)),
        console.warn(...n)
    }
    resetTracking(),
    isWarning = !1
}
function getComponentTrace() {
    let e = stack[stack.length - 1];
    if (!e)
        return [];
    const t = [];
    for (; e; ) {
        const n = t[0];
        n && n.vnode === e ? n.recurseCount++ : t.push({
            vnode: e,
            recurseCount: 0
        });
        const r = e.component && e.component.parent;
        e = r && r.vnode
    }
    return t
}
function formatTrace(e) {
    const t = [];
    return e.forEach(( (e, n) => {
        t.push(...0 === n ? [] : ["\n"], ...formatTraceEntry(e))
    }
    )),
    t
}
function formatTraceEntry({vnode: e, recurseCount: t}) {
    const n = t > 0 ? "... (".concat(t, " recursive calls)") : ""
      , r = !!e.component && null == e.component.parent
      , o = " at <".concat(formatComponentName(e.component, e.type, r))
      , i = ">" + n;
    return e.props ? [o, ...formatProps(e.props), i] : [o + i]
}
function formatProps(e) {
    const t = []
      , n = Object.keys(e);
    return n.slice(0, 3).forEach((n => {
        t.push(...formatProp(n, e[n]))
    }
    )),
    n.length > 3 && t.push(" ..."),
    t
}
function formatProp(e, t, n) {
    return isString$2(t) ? (t = JSON.stringify(t),
    n ? t : ["".concat(e, "=").concat(t)]) : "number" == typeof t || "boolean" == typeof t || null == t ? n ? t : ["".concat(e, "=").concat(t)] : isRef(t) ? (t = formatProp(e, toRaw(t.value), !0),
    n ? t : ["".concat(e, "=Ref<"), t, ">"]) : isFunction$3(t) ? ["".concat(e, "=fn").concat(t.name ? "<".concat(t.name, ">") : "")] : (t = toRaw(t),
    n ? t : ["".concat(e, "="), t])
}
function callWithErrorHandling(e, t, n, r) {
    try {
        return r ? e(...r) : e()
    } catch (o) {
        handleError(o, t, n)
    }
}
function callWithAsyncErrorHandling(e, t, n, r) {
    if (isFunction$3(e)) {
        const o = callWithErrorHandling(e, t, n, r);
        return o && isPromise$1(o) && o.catch((e => {
            handleError(e, t, n)
        }
        )),
        o
    }
    if (isArray$2(e)) {
        const o = [];
        for (let i = 0; i < e.length; i++)
            o.push(callWithAsyncErrorHandling(e[i], t, n, r));
        return o
    }
}
function handleError(e, t, n, r=!0) {
    const o = t ? t.vnode : null
      , {errorHandler: i, throwUnhandledErrorInProduction: a} = t && t.appContext.config || EMPTY_OBJ;
    if (t) {
        let r = t.parent;
        const o = t.proxy
          , a = "https://vuejs.org/error-reference/#runtime-".concat(n);
        for (; r; ) {
            const t = r.ec;
            if (t)
                for (let n = 0; n < t.length; n++)
                    if (!1 === t[n](e, o, a))
                        return;
            r = r.parent
        }
        if (i)
            return pauseTracking(),
            callWithErrorHandling(i, null, 10, [e, o, a]),
            void resetTracking()
    }
    logError(e, n, o, r, a)
}
function logError(e, t, n, r=!0, o=!1) {
    if (o)
        throw e;
    console.error(e)
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null
  , postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
function nextTick(e) {
    const t = currentFlushPromise || resolvedPromise;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function findInsertionIndex$1(e) {
    let t = flushIndex + 1
      , n = queue.length;
    for (; t < n; ) {
        const r = t + n >>> 1
          , o = queue[r]
          , i = getId(o);
        i < e || i === e && 2 & o.flags ? t = r + 1 : n = r
    }
    return t
}
function queueJob(e) {
    if (!(1 & e.flags)) {
        const t = getId(e)
          , n = queue[queue.length - 1];
        !n || !(2 & e.flags) && t >= getId(n) ? queue.push(e) : queue.splice(findInsertionIndex$1(t), 0, e),
        e.flags |= 1,
        queueFlush()
    }
}
function queueFlush() {
    currentFlushPromise || (currentFlushPromise = resolvedPromise.then(flushJobs))
}
function queuePostFlushCb(e) {
    isArray$2(e) ? pendingPostFlushCbs.push(...e) : activePostFlushCbs && -1 === e.id ? activePostFlushCbs.splice(postFlushIndex + 1, 0, e) : 1 & e.flags || (pendingPostFlushCbs.push(e),
    e.flags |= 1),
    queueFlush()
}
function flushPreFlushCbs(e, t, n=flushIndex + 1) {
    for (; n < queue.length; n++) {
        const t = queue[n];
        if (t && 2 & t.flags) {
            if (e && t.id !== e.uid)
                continue;
            queue.splice(n, 1),
            n--,
            4 & t.flags && (t.flags &= -2),
            t(),
            4 & t.flags || (t.flags &= -2)
        }
    }
}
function flushPostFlushCbs(e) {
    if (pendingPostFlushCbs.length) {
        const e = [...new Set(pendingPostFlushCbs)].sort(( (e, t) => getId(e) - getId(t)));
        if (pendingPostFlushCbs.length = 0,
        activePostFlushCbs)
            return void activePostFlushCbs.push(...e);
        for (activePostFlushCbs = e,
        postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            const e = activePostFlushCbs[postFlushIndex];
            4 & e.flags && (e.flags &= -2),
            8 & e.flags || e(),
            e.flags &= -2
        }
        activePostFlushCbs = null,
        postFlushIndex = 0
    }
}
const getId = e => null == e.id ? 2 & e.flags ? -1 : 1 / 0 : e.id;
function flushJobs(e) {
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const e = queue[flushIndex];
            !e || 8 & e.flags || (4 & e.flags && (e.flags &= -2),
            callWithErrorHandling(e, e.i, e.i ? 15 : 14),
            4 & e.flags || (e.flags &= -2))
        }
    } finally {
        for (; flushIndex < queue.length; flushIndex++) {
            const e = queue[flushIndex];
            e && (e.flags &= -2)
        }
        flushIndex = -1,
        queue.length = 0,
        flushPostFlushCbs(),
        currentFlushPromise = null,
        (queue.length || pendingPostFlushCbs.length) && flushJobs()
    }
}
let currentRenderingInstance = null
  , currentScopeId = null;
function setCurrentRenderingInstance(e) {
    const t = currentRenderingInstance;
    return currentRenderingInstance = e,
    currentScopeId = e && e.type.__scopeId || null,
    t
}
function pushScopeId(e) {
    currentScopeId = e
}
function popScopeId() {
    currentScopeId = null
}
function withCtx(e, t=currentRenderingInstance, n) {
    if (!t)
        return e;
    if (e._n)
        return e;
    const r = (...n) => {
        r._d && setBlockTracking(-1);
        const o = setCurrentRenderingInstance(t);
        let i;
        try {
            i = e(...n)
        } finally {
            setCurrentRenderingInstance(o),
            r._d && setBlockTracking(1)
        }
        return i
    }
    ;
    return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function withDirectives(e, t) {
    if (null === currentRenderingInstance)
        return e;
    const n = getComponentPublicInstance(currentRenderingInstance)
      , r = e.dirs || (e.dirs = []);
    for (let o = 0; o < t.length; o++) {
        let[e,i,a,s=EMPTY_OBJ] = t[o];
        e && (isFunction$3(e) && (e = {
            mounted: e,
            updated: e
        }),
        e.deep && traverse(i),
        r.push({
            dir: e,
            instance: n,
            value: i,
            oldValue: void 0,
            arg: a,
            modifiers: s
        }))
    }
    return e
}
function invokeDirectiveHook(e, t, n, r) {
    const o = e.dirs
      , i = t && t.dirs;
    for (let a = 0; a < o.length; a++) {
        const s = o[a];
        i && (s.oldValue = i[a].value);
        let c = s.dir[r];
        c && (pauseTracking(),
        callWithAsyncErrorHandling(c, n, 8, [e.el, s, e, t]),
        resetTracking())
    }
}
const TeleportEndKey = Symbol("_vte")
  , isTeleport = e => e.__isTeleport
  , isTeleportDisabled = e => e && (e.disabled || "" === e.disabled)
  , isTeleportDeferred = e => e && (e.defer || "" === e.defer)
  , isTargetSVG = e => "undefined" != typeof SVGElement && e instanceof SVGElement
  , isTargetMathML = e => "function" == typeof MathMLElement && e instanceof MathMLElement
  , resolveTarget = (e, t) => {
    const n = e && e.to;
    if (isString$2(n)) {
        if (t) {
            return t(n)
        }
        return null
    }
    return n
}
  , TeleportImpl = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, r, o, i, a, s, c, l) {
        const {mc: u, pc: p, pbc: d, o: {insert: f, querySelector: h, createText: m, createComment: g}} = l
          , v = isTeleportDisabled(t.props);
        let {shapeFlag: y, children: _, dynamicChildren: b} = t;
        if (null == e) {
            const e = t.el = m("")
              , l = t.anchor = m("");
            f(e, n, r),
            f(l, n, r);
            const p = (e, t) => {
                16 & y && (o && o.isCE && (o.ce._teleportTarget = e),
                u(_, e, t, o, i, a, s, c))
            }
              , d = () => {
                const e = t.target = resolveTarget(t.props, h)
                  , n = prepareAnchor(e, t, m, f);
                e && ("svg" !== a && isTargetSVG(e) ? a = "svg" : "mathml" !== a && isTargetMathML(e) && (a = "mathml"),
                v || (p(e, n),
                updateCssVars(t, !1)))
            }
            ;
            v && (p(n, l),
            updateCssVars(t, !0)),
            isTeleportDeferred(t.props) ? queuePostRenderEffect(( () => {
                d(),
                t.el.__isMounted = !0
            }
            ), i) : d()
        } else {
            if (isTeleportDeferred(t.props) && !e.el.__isMounted)
                return void queuePostRenderEffect(( () => {
                    TeleportImpl.process(e, t, n, r, o, i, a, s, c, l),
                    delete e.el.__isMounted
                }
                ), i);
            t.el = e.el,
            t.targetStart = e.targetStart;
            const u = t.anchor = e.anchor
              , f = t.target = e.target
              , m = t.targetAnchor = e.targetAnchor
              , g = isTeleportDisabled(e.props)
              , y = g ? n : f
              , _ = g ? u : m;
            if ("svg" === a || isTargetSVG(f) ? a = "svg" : ("mathml" === a || isTargetMathML(f)) && (a = "mathml"),
            b ? (d(e.dynamicChildren, b, y, o, i, a, s),
            traverseStaticChildren(e, t, !0)) : c || p(e, t, y, _, o, i, a, s, !1),
            v)
                g ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : moveTeleport(t, n, u, l, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const e = t.target = resolveTarget(t.props, h);
                e && moveTeleport(t, e, null, l, 0)
            } else
                g && moveTeleport(t, f, m, l, 1);
            updateCssVars(t, v)
        }
    },
    remove(e, t, n, {um: r, o: {remove: o}}, i) {
        const {shapeFlag: a, children: s, anchor: c, targetStart: l, targetAnchor: u, target: p, props: d} = e;
        if (p && (o(l),
        o(u)),
        i && o(c),
        16 & a) {
            const e = i || !isTeleportDisabled(d);
            for (let o = 0; o < s.length; o++) {
                const i = s[o];
                r(i, t, n, e, !!i.dynamicChildren)
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(e, t, n, {o: {insert: r}, m: o}, i=2) {
    0 === i && r(e.targetAnchor, t, n);
    const {el: a, anchor: s, shapeFlag: c, children: l, props: u} = e
      , p = 2 === i;
    if (p && r(a, t, n),
    (!p || isTeleportDisabled(u)) && 16 & c)
        for (let d = 0; d < l.length; d++)
            o(l[d], t, n, 2);
    p && r(s, t, n)
}
function hydrateTeleport(e, t, n, r, o, i, {o: {nextSibling: a, parentNode: s, querySelector: c, insert: l, createText: u}}, p) {
    const d = t.target = resolveTarget(t.props, c);
    if (d) {
        const c = isTeleportDisabled(t.props)
          , f = d._lpa || d.firstChild;
        if (16 & t.shapeFlag)
            if (c)
                t.anchor = p(a(e), t, s(e), n, r, o, i),
                t.targetStart = f,
                t.targetAnchor = f && a(f);
            else {
                t.anchor = a(e);
                let s = f;
                for (; s; ) {
                    if (s && 8 === s.nodeType)
                        if ("teleport start anchor" === s.data)
                            t.targetStart = s;
                        else if ("teleport anchor" === s.data) {
                            t.targetAnchor = s,
                            d._lpa = t.targetAnchor && a(t.targetAnchor);
                            break
                        }
                    s = a(s)
                }
                t.targetAnchor || prepareAnchor(d, t, u, l),
                p(f && a(f), t, d, n, r, o, i)
            }
        updateCssVars(t, c)
    }
    return t.anchor && a(t.anchor)
}
const Teleport = TeleportImpl;
function updateCssVars(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
        let r, o;
        for (t ? (r = e.el,
        o = e.anchor) : (r = e.targetStart,
        o = e.targetAnchor); r && r !== o; )
            1 === r.nodeType && r.setAttribute("data-v-owner", n.uid),
            r = r.nextSibling;
        n.ut()
    }
}
function prepareAnchor(e, t, n, r) {
    const o = t.targetStart = n("")
      , i = t.targetAnchor = n("");
    return o[TeleportEndKey] = i,
    e && (r(o, e),
    r(i, e)),
    i
}
const leaveCbKey = Symbol("_leaveCb")
  , enterCbKey = Symbol("_enterCb");
function useTransitionState() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return onMounted(( () => {
        e.isMounted = !0
    }
    )),
    onBeforeUnmount(( () => {
        e.isUnmounting = !0
    }
    )),
    e
}
const TransitionHookValidator = [Function, Array]
  , BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
}
  , recursiveGetSubtree = e => {
    const t = e.subTree;
    return t.component ? recursiveGetSubtree(t.component) : t
}
  , BaseTransitionImpl = {
    name: "BaseTransition",
    props: BaseTransitionPropsValidators,
    setup(e, {slots: t}) {
        const n = getCurrentInstance()
          , r = useTransitionState();
        return () => {
            const o = t.default && getTransitionRawChildren(t.default(), !0);
            if (!o || !o.length)
                return;
            const i = findNonCommentChild(o)
              , a = toRaw(e)
              , {mode: s} = a;
            if (r.isLeaving)
                return emptyPlaceholder(i);
            const c = getInnerChild$1(i);
            if (!c)
                return emptyPlaceholder(i);
            let l = resolveTransitionHooks(c, a, r, n, (e => l = e));
            c.type !== Comment && setTransitionHooks(c, l);
            let u = n.subTree && getInnerChild$1(n.subTree);
            if (u && u.type !== Comment && !isSameVNodeType(c, u) && recursiveGetSubtree(n).type !== Comment) {
                let e = resolveTransitionHooks(u, a, r, n);
                if (setTransitionHooks(u, e),
                "out-in" === s && c.type !== Comment)
                    return r.isLeaving = !0,
                    e.afterLeave = () => {
                        r.isLeaving = !1,
                        8 & n.job.flags || n.update(),
                        delete e.afterLeave,
                        u = void 0
                    }
                    ,
                    emptyPlaceholder(i);
                "in-out" === s && c.type !== Comment ? e.delayLeave = (e, t, n) => {
                    getLeavingNodesForType(r, u)[String(u.key)] = u,
                    e[leaveCbKey] = () => {
                        t(),
                        e[leaveCbKey] = void 0,
                        delete l.delayedLeave,
                        u = void 0
                    }
                    ,
                    l.delayedLeave = () => {
                        n(),
                        delete l.delayedLeave,
                        u = void 0
                    }
                }
                : u = void 0
            } else
                u && (u = void 0);
            return i
        }
    }
};
function findNonCommentChild(e) {
    let t = e[0];
    if (e.length > 1)
        for (const n of e)
            if (n.type !== Comment) {
                t = n;
                break
            }
    return t
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(e, t) {
    const {leavingVNodes: n} = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null),
    n.set(t.type, r)),
    r
}
function resolveTransitionHooks(e, t, n, r, o) {
    const {appear: i, mode: a, persisted: s=!1, onBeforeEnter: c, onEnter: l, onAfterEnter: u, onEnterCancelled: p, onBeforeLeave: d, onLeave: f, onAfterLeave: h, onLeaveCancelled: m, onBeforeAppear: g, onAppear: v, onAfterAppear: y, onAppearCancelled: _} = t
      , b = String(e.key)
      , E = getLeavingNodesForType(n, e)
      , w = (e, t) => {
        e && callWithAsyncErrorHandling(e, r, 9, t)
    }
      , S = (e, t) => {
        const n = t[1];
        w(e, t),
        isArray$2(e) ? e.every((e => e.length <= 1)) && n() : e.length <= 1 && n()
    }
      , O = {
        mode: a,
        persisted: s,
        beforeEnter(t) {
            let r = c;
            if (!n.isMounted) {
                if (!i)
                    return;
                r = g || c
            }
            t[leaveCbKey] && t[leaveCbKey](!0);
            const o = E[b];
            o && isSameVNodeType(e, o) && o.el[leaveCbKey] && o.el[leaveCbKey](),
            w(r, [t])
        },
        enter(e) {
            let t = l
              , r = u
              , o = p;
            if (!n.isMounted) {
                if (!i)
                    return;
                t = v || l,
                r = y || u,
                o = _ || p
            }
            let a = !1;
            const s = e[enterCbKey] = t => {
                a || (a = !0,
                w(t ? o : r, [e]),
                O.delayedLeave && O.delayedLeave(),
                e[enterCbKey] = void 0)
            }
            ;
            t ? S(t, [e, s]) : s()
        },
        leave(t, r) {
            const o = String(e.key);
            if (t[enterCbKey] && t[enterCbKey](!0),
            n.isUnmounting)
                return r();
            w(d, [t]);
            let i = !1;
            const a = t[leaveCbKey] = n => {
                i || (i = !0,
                r(),
                w(n ? m : h, [t]),
                t[leaveCbKey] = void 0,
                E[o] === e && delete E[o])
            }
            ;
            E[o] = e,
            f ? S(f, [t, a]) : a()
        },
        clone(e) {
            const i = resolveTransitionHooks(e, t, n, r, o);
            return o && o(i),
            i
        }
    };
    return O
}
function emptyPlaceholder(e) {
    if (isKeepAlive(e))
        return (e = cloneVNode(e)).children = null,
        e
}
function getInnerChild$1(e) {
    if (!isKeepAlive(e))
        return isTeleport(e.type) && e.children ? findNonCommentChild(e.children) : e;
    const {shapeFlag: t, children: n} = e;
    if (n) {
        if (16 & t)
            return n[0];
        if (32 & t && isFunction$3(n.default))
            return n.default()
    }
}
function setTransitionHooks(e, t) {
    6 & e.shapeFlag && e.component ? (e.transition = t,
    setTransitionHooks(e.component.subTree, t)) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function getTransitionRawChildren(e, t=!1, n) {
    let r = []
      , o = 0;
    for (let i = 0; i < e.length; i++) {
        let a = e[i];
        const s = null == n ? a.key : String(n) + String(null != a.key ? a.key : i);
        a.type === Fragment ? (128 & a.patchFlag && o++,
        r = r.concat(getTransitionRawChildren(a.children, t, s))) : (t || a.type !== Comment) && r.push(null != s ? cloneVNode(a, {
            key: s
        }) : a)
    }
    if (o > 1)
        for (let i = 0; i < r.length; i++)
            r[i].patchFlag = -2;
    return r
}
/*! #__NO_SIDE_EFFECTS__ */
function defineComponent(e, t) {
    return isFunction$3(e) ? ( () => extend$2({
        name: e.name
    }, t, {
        setup: e
    }))() : e
}
function markAsyncBoundary(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}
function useTemplateRef(e) {
    const t = getCurrentInstance()
      , n = shallowRef(null);
    if (t) {
        const r = t.refs === EMPTY_OBJ ? t.refs = {} : t.refs;
        Object.defineProperty(r, e, {
            enumerable: !0,
            get: () => n.value,
            set: e => n.value = e
        })
    }
    return n
}
function setRef(e, t, n, r, o=!1) {
    if (isArray$2(e))
        return void e.forEach(( (e, i) => setRef(e, t && (isArray$2(t) ? t[i] : t), n, r, o)));
    if (isAsyncWrapper(r) && !o)
        return void (512 & r.shapeFlag && r.type.__asyncResolved && r.component.subTree.component && setRef(e, t, n, r.component.subTree));
    const i = 4 & r.shapeFlag ? getComponentPublicInstance(r.component) : r.el
      , a = o ? null : i
      , {i: s, r: c} = e
      , l = t && t.r
      , u = s.refs === EMPTY_OBJ ? s.refs = {} : s.refs
      , p = s.setupState
      , d = toRaw(p)
      , f = p === EMPTY_OBJ ? () => !1 : e => hasOwn$1(d, e);
    if (null != l && l !== c && (isString$2(l) ? (u[l] = null,
    f(l) && (p[l] = null)) : isRef(l) && (l.value = null)),
    isFunction$3(c))
        callWithErrorHandling(c, s, 12, [a, u]);
    else {
        const t = isString$2(c)
          , r = isRef(c);
        if (t || r) {
            const s = () => {
                if (e.f) {
                    const n = t ? f(c) ? p[c] : u[c] : c.value;
                    o ? isArray$2(n) && remove(n, i) : isArray$2(n) ? n.includes(i) || n.push(i) : t ? (u[c] = [i],
                    f(c) && (p[c] = u[c])) : (c.value = [i],
                    e.k && (u[e.k] = c.value))
                } else
                    t ? (u[c] = a,
                    f(c) && (p[c] = a)) : r && (c.value = a,
                    e.k && (u[e.k] = a))
            }
            ;
            a ? (s.id = -1,
            queuePostRenderEffect(s, n)) : s()
        }
    }
}
let hasLoggedMismatchError = !1;
const logMismatchError = () => {
    hasLoggedMismatchError || (console.error("Hydration completed but contains mismatches."),
    hasLoggedMismatchError = !0)
}
  , isSVGContainer = e => e.namespaceURI.includes("svg") && "foreignObject" !== e.tagName
  , isMathMLContainer = e => e.namespaceURI.includes("MathML")
  , getContainerType = e => {
    if (1 === e.nodeType)
        return isSVGContainer(e) ? "svg" : isMathMLContainer(e) ? "mathml" : void 0
}
  , isComment$1 = e => 8 === e.nodeType;
function createHydrationFunctions(e) {
    const {mt: t, p: n, o: {patchProp: r, createText: o, nextSibling: i, parentNode: a, remove: s, insert: c, createComment: l}} = e
      , u = (n, r, s, l, y, _=!1) => {
        _ = _ || !!r.dynamicChildren;
        const b = isComment$1(n) && "[" === n.data
          , E = () => h(n, r, s, l, y, b)
          , {type: w, ref: S, shapeFlag: O, patchFlag: T} = r;
        let A = n.nodeType;
        r.el = n,
        -2 === T && (_ = !1,
        r.dynamicChildren = null);
        let R = null;
        switch (w) {
        case Text:
            3 !== A ? "" === r.children ? (c(r.el = o(""), a(n), n),
            R = n) : R = E() : (n.data !== r.children && (logMismatchError(),
            n.data = r.children),
            R = i(n));
            break;
        case Comment:
            v(n) ? (R = i(n),
            g(r.el = n.content.firstChild, n, s)) : R = 8 !== A || b ? E() : i(n);
            break;
        case Static:
            if (b && (A = (n = i(n)).nodeType),
            1 === A || 3 === A) {
                R = n;
                const e = !r.children.length;
                for (let t = 0; t < r.staticCount; t++)
                    e && (r.children += 1 === R.nodeType ? R.outerHTML : R.data),
                    t === r.staticCount - 1 && (r.anchor = R),
                    R = i(R);
                return b ? i(R) : R
            }
            E();
            break;
        case Fragment:
            R = b ? f(n, r, s, l, y, _) : E();
            break;
        default:
            if (1 & O)
                R = 1 === A && r.type.toLowerCase() === n.tagName.toLowerCase() || v(n) ? p(n, r, s, l, y, _) : E();
            else if (6 & O) {
                r.slotScopeIds = y;
                const e = a(n);
                if (R = b ? m(n) : isComment$1(n) && "teleport start" === n.data ? m(n, n.data, "teleport end") : i(n),
                t(r, e, null, s, l, getContainerType(e), _),
                isAsyncWrapper(r) && !r.type.__asyncResolved) {
                    let t;
                    b ? (t = createVNode(Fragment),
                    t.anchor = R ? R.previousSibling : e.lastChild) : t = 3 === n.nodeType ? createTextVNode("") : createVNode("div"),
                    t.el = n,
                    r.component.subTree = t
                }
            } else
                64 & O ? R = 8 !== A ? E() : r.type.hydrate(n, r, s, l, y, _, e, d) : 128 & O && (R = r.type.hydrate(n, r, s, l, getContainerType(a(n)), y, _, e, u))
        }
        return null != S && setRef(S, null, l, r),
        R
    }
      , p = (e, t, n, o, i, a) => {
        a = a || !!t.dynamicChildren;
        const {type: c, props: l, patchFlag: u, shapeFlag: p, dirs: f, transition: h} = t
          , m = "input" === c || "option" === c;
        if (m || -1 !== u) {
            f && invokeDirectiveHook(t, null, n, "created");
            let c, y = !1;
            if (v(e)) {
                y = needTransition(null, h) && n && n.vnode.props && n.vnode.props.appear;
                const r = e.content.firstChild;
                y && h.beforeEnter(r),
                g(r, e, n),
                t.el = e = r
            }
            if (16 & p && (!l || !l.innerHTML && !l.textContent)) {
                let r = d(e.firstChild, t, e, n, o, i, a);
                for (; r; ) {
                    isMismatchAllowed(e, 1) || logMismatchError();
                    const t = r;
                    r = r.nextSibling,
                    s(t)
                }
            } else if (8 & p) {
                let n = t.children;
                "\n" !== n[0] || "PRE" !== e.tagName && "TEXTAREA" !== e.tagName || (n = n.slice(1)),
                e.textContent !== n && (isMismatchAllowed(e, 0) || logMismatchError(),
                e.textContent = t.children)
            }
            if (l)
                if (m || !a || 48 & u) {
                    const t = e.tagName.includes("-");
                    for (const o in l)
                        (m && (o.endsWith("value") || "indeterminate" === o) || isOn(o) && !isReservedProp(o) || "." === o[0] || t) && r(e, o, null, l[o], void 0, n)
                } else if (l.onClick)
                    r(e, "onClick", null, l.onClick, void 0, n);
                else if (4 & u && isReactive(l.style))
                    for (const e in l.style)
                        l.style[e];
            (c = l && l.onVnodeBeforeMount) && invokeVNodeHook(c, n, t),
            f && invokeDirectiveHook(t, null, n, "beforeMount"),
            ((c = l && l.onVnodeMounted) || f || y) && queueEffectWithSuspense(( () => {
                c && invokeVNodeHook(c, n, t),
                y && h.enter(e),
                f && invokeDirectiveHook(t, null, n, "mounted")
            }
            ), o)
        }
        return e.nextSibling
    }
      , d = (e, t, r, a, s, l, p) => {
        p = p || !!t.dynamicChildren;
        const d = t.children
          , f = d.length;
        for (let h = 0; h < f; h++) {
            const t = p ? d[h] : d[h] = normalizeVNode(d[h])
              , m = t.type === Text;
            e ? (m && !p && h + 1 < f && normalizeVNode(d[h + 1]).type === Text && (c(o(e.data.slice(t.children.length)), r, i(e)),
            e.data = t.children),
            e = u(e, t, a, s, l, p)) : m && !t.children ? c(t.el = o(""), r) : (isMismatchAllowed(r, 1) || logMismatchError(),
            n(null, t, r, null, a, s, getContainerType(r), l))
        }
        return e
    }
      , f = (e, t, n, r, o, s) => {
        const {slotScopeIds: u} = t;
        u && (o = o ? o.concat(u) : u);
        const p = a(e)
          , f = d(i(e), t, p, n, r, o, s);
        return f && isComment$1(f) && "]" === f.data ? i(t.anchor = f) : (logMismatchError(),
        c(t.anchor = l("]"), p, f),
        f)
    }
      , h = (e, t, r, o, c, l) => {
        if (isMismatchAllowed(e.parentElement, 1) || logMismatchError(),
        t.el = null,
        l) {
            const t = m(e);
            for (; ; ) {
                const n = i(e);
                if (!n || n === t)
                    break;
                s(n)
            }
        }
        const u = i(e)
          , p = a(e);
        return s(e),
        n(null, t, p, u, r, o, getContainerType(p), c),
        r && (r.vnode.el = t.el,
        updateHOCHostEl(r, t.el)),
        u
    }
      , m = (e, t="[", n="]") => {
        let r = 0;
        for (; e; )
            if ((e = i(e)) && isComment$1(e) && (e.data === t && r++,
            e.data === n)) {
                if (0 === r)
                    return i(e);
                r--
            }
        return e
    }
      , g = (e, t, n) => {
        const r = t.parentNode;
        r && r.replaceChild(e, t);
        let o = n;
        for (; o; )
            o.vnode.el === t && (o.vnode.el = o.subTree.el = e),
            o = o.parent
    }
      , v = e => 1 === e.nodeType && "TEMPLATE" === e.tagName;
    return [ (e, t) => {
        if (!t.hasChildNodes())
            return n(null, e, t),
            flushPostFlushCbs(),
            void (t._vnode = e);
        u(t.firstChild, e, null, null, null),
        flushPostFlushCbs(),
        t._vnode = e
    }
    , u]
}
const allowMismatchAttr = "data-allow-mismatch"
  , MismatchTypeString = {
    0: "text",
    1: "children",
    2: "class",
    3: "style",
    4: "attribute"
};
function isMismatchAllowed(e, t) {
    if (0 === t || 1 === t)
        for (; e && !e.hasAttribute(allowMismatchAttr); )
            e = e.parentElement;
    const n = e && e.getAttribute(allowMismatchAttr);
    if (null == n)
        return !1;
    if ("" === n)
        return !0;
    {
        const e = n.split(",");
        return !(0 !== t || !e.includes("children")) || n.split(",").includes(MismatchTypeString[t])
    }
}
function forEachElement(e, t) {
    if (isComment$1(e) && "[" === e.data) {
        let n = 1
          , r = e.nextSibling;
        for (; r; ) {
            if (1 === r.nodeType) {
                if (!1 === t(r))
                    break
            } else if (isComment$1(r))
                if ("]" === r.data) {
                    if (0 == --n)
                        break
                } else
                    "[" === r.data && n++;
            r = r.nextSibling
        }
    } else
        t(e)
}
getGlobalThis().requestIdleCallback,
getGlobalThis().cancelIdleCallback;
const isAsyncWrapper = e => !!e.type.__asyncLoader /*! #__NO_SIDE_EFFECTS__ */
;
function defineAsyncComponent(e) {
    isFunction$3(e) && (e = {
        loader: e
    });
    const {loader: t, loadingComponent: n, errorComponent: r, delay: o=200, hydrate: i, timeout: a, suspensible: s=!0, onError: c} = e;
    let l, u = null, p = 0;
    const d = () => {
        let e;
        return u || (e = u = t().catch((e => {
            if (e = e instanceof Error ? e : new Error(String(e)),
            c)
                return new Promise(( (t, n) => {
                    c(e, ( () => t((p++,
                    u = null,
                    d()))), ( () => n(e)), p + 1)
                }
                ));
            throw e
        }
        )).then((t => e !== u && u ? u : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default),
        l = t,
        t))))
    }
    ;
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: d,
        __asyncHydrate(e, t, n) {
            const r = i ? () => {
                const r = i(n, (t => forEachElement(e, t)));
                r && (t.bum || (t.bum = [])).push(r)
            }
            : n;
            l ? r() : d().then(( () => !t.isUnmounted && r()))
        },
        get __asyncResolved() {
            return l
        },
        setup() {
            const e = currentInstance;
            if (markAsyncBoundary(e),
            l)
                return () => createInnerComp(l, e);
            const t = t => {
                u = null,
                handleError(t, e, 13, !r)
            }
            ;
            if (s && e.suspense || isInSSRComponentSetup)
                return d().then((t => () => createInnerComp(t, e))).catch((e => (t(e),
                () => r ? createVNode(r, {
                    error: e
                }) : null)));
            const i = ref(!1)
              , c = ref()
              , p = ref(!!o);
            return o && setTimeout(( () => {
                p.value = !1
            }
            ), o),
            null != a && setTimeout(( () => {
                if (!i.value && !c.value) {
                    const e = new Error("Async component timed out after ".concat(a, "ms."));
                    t(e),
                    c.value = e
                }
            }
            ), a),
            d().then(( () => {
                i.value = !0,
                e.parent && isKeepAlive(e.parent.vnode) && e.parent.update()
            }
            )).catch((e => {
                t(e),
                c.value = e
            }
            )),
            () => i.value && l ? createInnerComp(l, e) : c.value && r ? createVNode(r, {
                error: c.value
            }) : n && !p.value ? createVNode(n) : void 0
        }
    })
}
function createInnerComp(e, t) {
    const {ref: n, props: r, children: o, ce: i} = t.vnode
      , a = createVNode(e, r, o);
    return a.ref = n,
    a.ce = i,
    delete t.vnode.ce,
    a
}
const isKeepAlive = e => e.type.__isKeepAlive
  , KeepAliveImpl = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const n = getCurrentInstance()
          , r = n.ctx;
        if (!r.renderer)
            return () => {
                const e = t.default && t.default();
                return e && 1 === e.length ? e[0] : e
            }
            ;
        const o = new Map
          , i = new Set;
        let a = null;
        const s = n.suspense
          , {renderer: {p: c, m: l, um: u, o: {createElement: p}}} = r
          , d = p("div");
        function f(e) {
            resetShapeFlag(e),
            u(e, n, s, !0)
        }
        function h(e) {
            o.forEach(( (t, n) => {
                const r = getComponentName(t.type);
                r && !e(r) && m(n)
            }
            ))
        }
        function m(e) {
            const t = o.get(e);
            !t || a && isSameVNodeType(t, a) ? a && resetShapeFlag(a) : f(t),
            o.delete(e),
            i.delete(e)
        }
        r.activate = (e, t, n, r, o) => {
            const i = e.component;
            l(e, t, n, 0, s),
            c(i.vnode, e, t, n, i, s, r, e.slotScopeIds, o),
            queuePostRenderEffect(( () => {
                i.isDeactivated = !1,
                i.a && invokeArrayFns(i.a);
                const t = e.props && e.props.onVnodeMounted;
                t && invokeVNodeHook(t, i.parent, e)
            }
            ), s)
        }
        ,
        r.deactivate = e => {
            const t = e.component;
            invalidateMount(t.m),
            invalidateMount(t.a),
            l(e, d, null, 1, s),
            queuePostRenderEffect(( () => {
                t.da && invokeArrayFns(t.da);
                const n = e.props && e.props.onVnodeUnmounted;
                n && invokeVNodeHook(n, t.parent, e),
                t.isDeactivated = !0
            }
            ), s)
        }
        ,
        watch(( () => [e.include, e.exclude]), ( ([e,t]) => {
            e && h((t => matches(e, t))),
            t && h((e => !matches(t, e)))
        }
        ), {
            flush: "post",
            deep: !0
        });
        let g = null;
        const v = () => {
            null != g && (isSuspense(n.subTree.type) ? queuePostRenderEffect(( () => {
                o.set(g, getInnerChild(n.subTree))
            }
            ), n.subTree.suspense) : o.set(g, getInnerChild(n.subTree)))
        }
        ;
        return onMounted(v),
        onUpdated(v),
        onBeforeUnmount(( () => {
            o.forEach((e => {
                const {subTree: t, suspense: r} = n
                  , o = getInnerChild(t);
                if (e.type !== o.type || e.key !== o.key)
                    f(e);
                else {
                    resetShapeFlag(o);
                    const e = o.component.da;
                    e && queuePostRenderEffect(e, r)
                }
            }
            ))
        }
        )),
        () => {
            if (g = null,
            !t.default)
                return a = null;
            const n = t.default()
              , r = n[0];
            if (n.length > 1)
                return a = null,
                n;
            if (!(isVNode(r) && (4 & r.shapeFlag || 128 & r.shapeFlag)))
                return a = null,
                r;
            let s = getInnerChild(r);
            if (s.type === Comment)
                return a = null,
                s;
            const c = s.type
              , l = getComponentName(isAsyncWrapper(s) ? s.type.__asyncResolved || {} : c)
              , {include: u, exclude: p, max: d} = e;
            if (u && (!l || !matches(u, l)) || p && l && matches(p, l))
                return s.shapeFlag &= -257,
                a = s,
                r;
            const f = null == s.key ? c : s.key
              , h = o.get(f);
            return s.el && (s = cloneVNode(s),
            128 & r.shapeFlag && (r.ssContent = s)),
            g = f,
            h ? (s.el = h.el,
            s.component = h.component,
            s.transition && setTransitionHooks(s, s.transition),
            s.shapeFlag |= 512,
            i.delete(f),
            i.add(f)) : (i.add(f),
            d && i.size > parseInt(d, 10) && m(i.values().next().value)),
            s.shapeFlag |= 256,
            a = s,
            isSuspense(r.type) ? r : s
        }
    }
}
  , KeepAlive = KeepAliveImpl;
function matches(e, t) {
    return isArray$2(e) ? e.some((e => matches(e, t))) : isString$2(e) ? e.split(",").includes(t) : !!isRegExp$1(e) && (e.lastIndex = 0,
    e.test(t))
}
function onActivated(e, t) {
    registerKeepAliveHook(e, "a", t)
}
function onDeactivated(e, t) {
    registerKeepAliveHook(e, "da", t)
}
function registerKeepAliveHook(e, t, n=currentInstance) {
    const r = e.__wdc || (e.__wdc = () => {
        let t = n;
        for (; t; ) {
            if (t.isDeactivated)
                return;
            t = t.parent
        }
        return e()
    }
    );
    if (injectHook(t, r, n),
    n) {
        let e = n.parent;
        for (; e && e.parent; )
            isKeepAlive(e.parent.vnode) && injectToKeepAliveRoot(r, t, n, e),
            e = e.parent
    }
}
function injectToKeepAliveRoot(e, t, n, r) {
    const o = injectHook(t, e, r, !0);
    onUnmounted(( () => {
        remove(r[t], o)
    }
    ), n)
}
function resetShapeFlag(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function getInnerChild(e) {
    return 128 & e.shapeFlag ? e.ssContent : e
}
function injectHook(e, t, n=currentInstance, r=!1) {
    if (n) {
        const o = n[e] || (n[e] = [])
          , i = t.__weh || (t.__weh = (...r) => {
            pauseTracking();
            const o = setCurrentInstance(n)
              , i = callWithAsyncErrorHandling(t, n, e, r);
            return o(),
            resetTracking(),
            i
        }
        );
        return r ? o.unshift(i) : o.push(i),
        i
    }
}
const createHook = e => (t, n=currentInstance) => {
    isInSSRComponentSetup && "sp" !== e || injectHook(e, ( (...e) => t(...e)), n)
}
  , onBeforeMount = createHook("bm")
  , onMounted = createHook("m")
  , onBeforeUpdate = createHook("bu")
  , onUpdated = createHook("u")
  , onBeforeUnmount = createHook("bum")
  , onUnmounted = createHook("um")
  , onServerPrefetch = createHook("sp")
  , onRenderTriggered = createHook("rtg")
  , onRenderTracked = createHook("rtc");
function onErrorCaptured(e, t=currentInstance) {
    injectHook("ec", e, t)
}
const COMPONENTS = "components"
  , DIRECTIVES = "directives";
function resolveComponent(e, t) {
    return resolveAsset(COMPONENTS, e, !0, t) || e
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(e) {
    return isString$2(e) ? resolveAsset(COMPONENTS, e, !1) || e : e || NULL_DYNAMIC_COMPONENT
}
function resolveDirective(e) {
    return resolveAsset(DIRECTIVES, e)
}
function resolveAsset(e, t, n=!0, r=!1) {
    const o = currentRenderingInstance || currentInstance;
    if (o) {
        const n = o.type;
        if (e === COMPONENTS) {
            const e = getComponentName(n, !1);
            if (e && (e === t || e === camelize(t) || e === capitalize(camelize(t))))
                return n
        }
        const i = resolve(o[e] || n[e], t) || resolve(o.appContext[e], t);
        return !i && r ? n : i
    }
}
function resolve(e, t) {
    return e && (e[t] || e[camelize(t)] || e[capitalize(camelize(t))])
}
function renderList(e, t, n, r) {
    let o;
    const i = n
      , a = isArray$2(e);
    if (a || isString$2(e)) {
        let n = !1;
        a && isReactive(e) && (n = !isShallow(e),
        e = shallowReadArray(e)),
        o = new Array(e.length);
        for (let r = 0, a = e.length; r < a; r++)
            o[r] = t(n ? toReactive(e[r]) : e[r], r, void 0, i)
    } else if ("number" == typeof e) {
        o = new Array(e);
        for (let n = 0; n < e; n++)
            o[n] = t(n + 1, n, void 0, i)
    } else if (isObject$1(e))
        if (e[Symbol.iterator])
            o = Array.from(e, ( (e, n) => t(e, n, void 0, i)));
        else {
            const n = Object.keys(e);
            o = new Array(n.length);
            for (let r = 0, a = n.length; r < a; r++) {
                const a = n[r];
                o[r] = t(e[a], a, r, i)
            }
        }
    else
        o = [];
    return o
}
function renderSlot(e, t, n={}, r, o) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce)
        return "default" !== t && (n.name = t),
        openBlock(),
        createBlock(Fragment, null, [createVNode("slot", n, r && r())], 64);
    let i = e[t];
    i && i._c && (i._d = !1),
    openBlock();
    const a = i && ensureValidVNode(i(n))
      , s = n.key || a && a.key
      , c = createBlock(Fragment, {
        key: (s && !isSymbol(s) ? s : "_".concat(t)) + (!a && r ? "_fb" : "")
    }, a || (r ? r() : []), a && 1 === e._ ? 64 : -2);
    return i && i._c && (i._d = !0),
    c
}
function ensureValidVNode(e) {
    return e.some((e => !isVNode(e) || e.type !== Comment && !(e.type === Fragment && !ensureValidVNode(e.children)))) ? e : null
}
const getPublicInstance = e => e ? isStatefulComponent(e) ? getComponentPublicInstance(e) : getPublicInstance(e.parent) : null
  , publicPropertiesMap = extend$2(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => getPublicInstance(e.parent),
    $root: e => getPublicInstance(e.root),
    $host: e => e.ce,
    $emit: e => e.emit,
    $options: e => resolveMergedOptions(e),
    $forceUpdate: e => e.f || (e.f = () => {
        queueJob(e.update)
    }
    ),
    $nextTick: e => e.n || (e.n = nextTick.bind(e.proxy)),
    $watch: e => instanceWatch.bind(e)
})
  , hasSetupBinding = (e, t) => e !== EMPTY_OBJ && !e.__isScriptSetup && hasOwn$1(e, t)
  , PublicInstanceProxyHandlers = {
    get({_: e}, t) {
        if ("__v_skip" === t)
            return !0;
        const {ctx: n, setupState: r, data: o, props: i, accessCache: a, type: s, appContext: c} = e;
        let l;
        if ("$" !== t[0]) {
            const s = a[t];
            if (void 0 !== s)
                switch (s) {
                case 1:
                    return r[t];
                case 2:
                    return o[t];
                case 4:
                    return n[t];
                case 3:
                    return i[t]
                }
            else {
                if (hasSetupBinding(r, t))
                    return a[t] = 1,
                    r[t];
                if (o !== EMPTY_OBJ && hasOwn$1(o, t))
                    return a[t] = 2,
                    o[t];
                if ((l = e.propsOptions[0]) && hasOwn$1(l, t))
                    return a[t] = 3,
                    i[t];
                if (n !== EMPTY_OBJ && hasOwn$1(n, t))
                    return a[t] = 4,
                    n[t];
                shouldCacheAccess && (a[t] = 0)
            }
        }
        const u = publicPropertiesMap[t];
        let p, d;
        return u ? ("$attrs" === t && track(e.attrs, "get", ""),
        u(e)) : (p = s.__cssModules) && (p = p[t]) ? p : n !== EMPTY_OBJ && hasOwn$1(n, t) ? (a[t] = 4,
        n[t]) : (d = c.config.globalProperties,
        hasOwn$1(d, t) ? d[t] : void 0)
    },
    set({_: e}, t, n) {
        const {data: r, setupState: o, ctx: i} = e;
        return hasSetupBinding(o, t) ? (o[t] = n,
        !0) : r !== EMPTY_OBJ && hasOwn$1(r, t) ? (r[t] = n,
        !0) : !hasOwn$1(e.props, t) && (("$" !== t[0] || !(t.slice(1)in e)) && (i[t] = n,
        !0))
    },
    has({_: {data: e, setupState: t, accessCache: n, ctx: r, appContext: o, propsOptions: i}}, a) {
        let s;
        return !!n[a] || e !== EMPTY_OBJ && hasOwn$1(e, a) || hasSetupBinding(t, a) || (s = i[0]) && hasOwn$1(s, a) || hasOwn$1(r, a) || hasOwn$1(publicPropertiesMap, a) || hasOwn$1(o.config.globalProperties, a)
    },
    defineProperty(e, t, n) {
        return null != n.get ? e._.accessCache[t] = 0 : hasOwn$1(n, "value") && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
    }
};
function useSlots() {
    return getContext$1().slots
}
function getContext$1() {
    const e = getCurrentInstance();
    return e.setupContext || (e.setupContext = createSetupContext(e))
}
function normalizePropsOrEmits(e) {
    return isArray$2(e) ? e.reduce(( (e, t) => (e[t] = null,
    e)), {}) : e
}
function mergeModels(e, t) {
    return e && t ? isArray$2(e) && isArray$2(t) ? e.concat(t) : extend$2({}, normalizePropsOrEmits(e), normalizePropsOrEmits(t)) : e || t
}
let shouldCacheAccess = !0;
function applyOptions(e) {
    const t = resolveMergedOptions(e)
      , n = e.proxy
      , r = e.ctx;
    shouldCacheAccess = !1,
    t.beforeCreate && callHook$1(t.beforeCreate, e, "bc");
    const {data: o, computed: i, methods: a, watch: s, provide: c, inject: l, created: u, beforeMount: p, mounted: d, beforeUpdate: f, updated: h, activated: m, deactivated: g, beforeDestroy: v, beforeUnmount: y, destroyed: _, unmounted: b, render: E, renderTracked: w, renderTriggered: S, errorCaptured: O, serverPrefetch: T, expose: A, inheritAttrs: R, components: k, directives: P, filters: $} = t;
    if (l && resolveInjections(l, r, null),
    a)
        for (const I in a) {
            const e = a[I];
            isFunction$3(e) && (r[I] = e.bind(n))
        }
    if (o) {
        const t = o.call(n, n);
        isObject$1(t) && (e.data = reactive(t))
    }
    if (shouldCacheAccess = !0,
    i)
        for (const I in i) {
            const e = i[I]
              , t = isFunction$3(e) ? e.bind(n, n) : isFunction$3(e.get) ? e.get.bind(n, n) : NOOP
              , o = !isFunction$3(e) && isFunction$3(e.set) ? e.set.bind(n) : NOOP
              , a = computed({
                get: t,
                set: o
            });
            Object.defineProperty(r, I, {
                enumerable: !0,
                configurable: !0,
                get: () => a.value,
                set: e => a.value = e
            })
        }
    if (s)
        for (const I in s)
            createWatcher(s[I], r, n, I);
    if (c) {
        const e = isFunction$3(c) ? c.call(n) : c;
        Reflect.ownKeys(e).forEach((t => {
            provide(t, e[t])
        }
        ))
    }
    function C(e, t) {
        isArray$2(t) ? t.forEach((t => e(t.bind(n)))) : t && e(t.bind(n))
    }
    if (u && callHook$1(u, e, "c"),
    C(onBeforeMount, p),
    C(onMounted, d),
    C(onBeforeUpdate, f),
    C(onUpdated, h),
    C(onActivated, m),
    C(onDeactivated, g),
    C(onErrorCaptured, O),
    C(onRenderTracked, w),
    C(onRenderTriggered, S),
    C(onBeforeUnmount, y),
    C(onUnmounted, b),
    C(onServerPrefetch, T),
    isArray$2(A))
        if (A.length) {
            const t = e.exposed || (e.exposed = {});
            A.forEach((e => {
                Object.defineProperty(t, e, {
                    get: () => n[e],
                    set: t => n[e] = t
                })
            }
            ))
        } else
            e.exposed || (e.exposed = {});
    E && e.render === NOOP && (e.render = E),
    null != R && (e.inheritAttrs = R),
    k && (e.components = k),
    P && (e.directives = P),
    T && markAsyncBoundary(e)
}
function resolveInjections(e, t, n=NOOP) {
    isArray$2(e) && (e = normalizeInject(e));
    for (const r in e) {
        const n = e[r];
        let o;
        o = isObject$1(n) ? "default"in n ? inject(n.from || r, n.default, !0) : inject(n.from || r) : inject(n),
        isRef(o) ? Object.defineProperty(t, r, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: e => o.value = e
        }) : t[r] = o
    }
}
function callHook$1(e, t, n) {
    callWithAsyncErrorHandling(isArray$2(e) ? e.map((e => e.bind(t.proxy))) : e.bind(t.proxy), t, n)
}
function createWatcher(e, t, n, r) {
    let o = r.includes(".") ? createPathGetter(n, r) : () => n[r];
    if (isString$2(e)) {
        const n = t[e];
        isFunction$3(n) && watch(o, n)
    } else if (isFunction$3(e))
        watch(o, e.bind(n));
    else if (isObject$1(e))
        if (isArray$2(e))
            e.forEach((e => createWatcher(e, t, n, r)));
        else {
            const r = isFunction$3(e.handler) ? e.handler.bind(n) : t[e.handler];
            isFunction$3(r) && watch(o, r, e)
        }
}
function resolveMergedOptions(e) {
    const t = e.type
      , {mixins: n, extends: r} = t
      , {mixins: o, optionsCache: i, config: {optionMergeStrategies: a}} = e.appContext
      , s = i.get(t);
    let c;
    return s ? c = s : o.length || n || r ? (c = {},
    o.length && o.forEach((e => mergeOptions$1(c, e, a, !0))),
    mergeOptions$1(c, t, a)) : c = t,
    isObject$1(t) && i.set(t, c),
    c
}
function mergeOptions$1(e, t, n, r=!1) {
    const {mixins: o, extends: i} = t;
    i && mergeOptions$1(e, i, n, !0),
    o && o.forEach((t => mergeOptions$1(e, t, n, !0)));
    for (const a in t)
        if (r && "expose" === a)
            ;
        else {
            const r = internalOptionMergeStrats[a] || n && n[a];
            e[a] = r ? r(e[a], t[a]) : t[a]
        }
    return e
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(e, t) {
    return t ? e ? function() {
        return extend$2(isFunction$3(e) ? e.call(this, this) : e, isFunction$3(t) ? t.call(this, this) : t)
    }
    : t : e
}
function mergeInject(e, t) {
    return mergeObjectOptions(normalizeInject(e), normalizeInject(t))
}
function normalizeInject(e) {
    if (isArray$2(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function mergeAsArray(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function mergeObjectOptions(e, t) {
    return e ? extend$2(Object.create(null), e, t) : t
}
function mergeEmitsOrPropsOptions(e, t) {
    return e ? isArray$2(e) && isArray$2(t) ? [...new Set([...e, ...t])] : extend$2(Object.create(null), normalizePropsOrEmits(e), normalizePropsOrEmits(null != t ? t : {})) : t
}
function mergeWatchOptions(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const n = extend$2(Object.create(null), e);
    for (const r in t)
        n[r] = mergeAsArray(e[r], t[r]);
    return n
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: NO,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let uid$1 = 0;
function createAppAPI(e, t) {
    return function(n, r=null) {
        isFunction$3(n) || (n = extend$2({}, n)),
        null == r || isObject$1(r) || (r = null);
        const o = createAppContext()
          , i = new WeakSet
          , a = [];
        let s = !1;
        const c = o.app = {
            _uid: uid$1++,
            _component: n,
            _props: r,
            _container: null,
            _context: o,
            _instance: null,
            version: version$1,
            get config() {
                return o.config
            },
            set config(e) {},
            use: (e, ...t) => (i.has(e) || (e && isFunction$3(e.install) ? (i.add(e),
            e.install(c, ...t)) : isFunction$3(e) && (i.add(e),
            e(c, ...t))),
            c),
            mixin: e => (o.mixins.includes(e) || o.mixins.push(e),
            c),
            component: (e, t) => t ? (o.components[e] = t,
            c) : o.components[e],
            directive: (e, t) => t ? (o.directives[e] = t,
            c) : o.directives[e],
            mount(i, a, l) {
                if (!s) {
                    const u = c._ceVNode || createVNode(n, r);
                    return u.appContext = o,
                    !0 === l ? l = "svg" : !1 === l && (l = void 0),
                    a && t ? t(u, i) : e(u, i, l),
                    s = !0,
                    c._container = i,
                    i.__vue_app__ = c,
                    getComponentPublicInstance(u.component)
                }
            },
            onUnmount(e) {
                a.push(e)
            },
            unmount() {
                s && (callWithAsyncErrorHandling(a, c._instance, 16),
                e(null, c._container),
                delete c._container.__vue_app__)
            },
            provide: (e, t) => (o.provides[e] = t,
            c),
            runWithContext(e) {
                const t = currentApp;
                currentApp = c;
                try {
                    return e()
                } finally {
                    currentApp = t
                }
            }
        };
        return c
    }
}
let currentApp = null;
function provide(e, t) {
    if (currentInstance) {
        let n = currentInstance.provides;
        const r = currentInstance.parent && currentInstance.parent.provides;
        r === n && (n = currentInstance.provides = Object.create(r)),
        n[e] = t
    } else
        ;
}
function inject(e, t, n=!1) {
    const r = currentInstance || currentRenderingInstance;
    if (r || currentApp) {
        const o = currentApp ? currentApp._context.provides : r ? null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
        if (o && e in o)
            return o[e];
        if (arguments.length > 1)
            return n && isFunction$3(t) ? t.call(r && r.proxy) : t
    }
}
const internalObjectProto = {}
  , createInternalObject = () => Object.create(internalObjectProto)
  , isInternalObject = e => Object.getPrototypeOf(e) === internalObjectProto;
function initProps(e, t, n, r=!1) {
    const o = {}
      , i = createInternalObject();
    e.propsDefaults = Object.create(null),
    setFullProps(e, t, o, i);
    for (const a in e.propsOptions[0])
        a in o || (o[a] = void 0);
    n ? e.props = r ? o : shallowReactive(o) : e.type.props ? e.props = o : e.props = i,
    e.attrs = i
}
function updateProps(e, t, n, r) {
    const {props: o, attrs: i, vnode: {patchFlag: a}} = e
      , s = toRaw(o)
      , [c] = e.propsOptions;
    let l = !1;
    if (!(r || a > 0) || 16 & a) {
        let r;
        setFullProps(e, t, o, i) && (l = !0);
        for (const i in s)
            t && (hasOwn$1(t, i) || (r = hyphenate(i)) !== i && hasOwn$1(t, r)) || (c ? !n || void 0 === n[i] && void 0 === n[r] || (o[i] = resolvePropValue(c, s, i, void 0, e, !0)) : delete o[i]);
        if (i !== s)
            for (const e in i)
                t && hasOwn$1(t, e) || (delete i[e],
                l = !0)
    } else if (8 & a) {
        const n = e.vnode.dynamicProps;
        for (let r = 0; r < n.length; r++) {
            let a = n[r];
            if (isEmitListener(e.emitsOptions, a))
                continue;
            const u = t[a];
            if (c)
                if (hasOwn$1(i, a))
                    u !== i[a] && (i[a] = u,
                    l = !0);
                else {
                    const t = camelize(a);
                    o[t] = resolvePropValue(c, s, t, u, e, !1)
                }
            else
                u !== i[a] && (i[a] = u,
                l = !0)
        }
    }
    l && trigger(e.attrs, "set", "")
}
function setFullProps(e, t, n, r) {
    const [o,i] = e.propsOptions;
    let a, s = !1;
    if (t)
        for (let c in t) {
            if (isReservedProp(c))
                continue;
            const l = t[c];
            let u;
            o && hasOwn$1(o, u = camelize(c)) ? i && i.includes(u) ? (a || (a = {}))[u] = l : n[u] = l : isEmitListener(e.emitsOptions, c) || c in r && l === r[c] || (r[c] = l,
            s = !0)
        }
    if (i) {
        const t = toRaw(n)
          , r = a || EMPTY_OBJ;
        for (let a = 0; a < i.length; a++) {
            const s = i[a];
            n[s] = resolvePropValue(o, t, s, r[s], e, !hasOwn$1(r, s))
        }
    }
    return s
}
function resolvePropValue(e, t, n, r, o, i) {
    const a = e[n];
    if (null != a) {
        const e = hasOwn$1(a, "default");
        if (e && void 0 === r) {
            const e = a.default;
            if (a.type !== Function && !a.skipFactory && isFunction$3(e)) {
                const {propsDefaults: i} = o;
                if (n in i)
                    r = i[n];
                else {
                    const a = setCurrentInstance(o);
                    r = i[n] = e.call(null, t),
                    a()
                }
            } else
                r = e;
            o.ce && o.ce._setProp(n, r)
        }
        a[0] && (i && !e ? r = !1 : !a[1] || "" !== r && r !== hyphenate(n) || (r = !0))
    }
    return r
}
const mixinPropsCache = new WeakMap;
function normalizePropsOptions(e, t, n=!1) {
    const r = n ? mixinPropsCache : t.propsCache
      , o = r.get(e);
    if (o)
        return o;
    const i = e.props
      , a = {}
      , s = [];
    let c = !1;
    if (!isFunction$3(e)) {
        const r = e => {
            c = !0;
            const [n,r] = normalizePropsOptions(e, t, !0);
            extend$2(a, n),
            r && s.push(...r)
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(r),
        e.extends && r(e.extends),
        e.mixins && e.mixins.forEach(r)
    }
    if (!i && !c)
        return isObject$1(e) && r.set(e, EMPTY_ARR),
        EMPTY_ARR;
    if (isArray$2(i))
        for (let u = 0; u < i.length; u++) {
            const e = camelize(i[u]);
            validatePropName(e) && (a[e] = EMPTY_OBJ)
        }
    else if (i)
        for (const u in i) {
            const e = camelize(u);
            if (validatePropName(e)) {
                const t = i[u]
                  , n = a[e] = isArray$2(t) || isFunction$3(t) ? {
                    type: t
                } : extend$2({}, t)
                  , r = n.type;
                let o = !1
                  , c = !0;
                if (isArray$2(r))
                    for (let e = 0; e < r.length; ++e) {
                        const t = r[e]
                          , n = isFunction$3(t) && t.name;
                        if ("Boolean" === n) {
                            o = !0;
                            break
                        }
                        "String" === n && (c = !1)
                    }
                else
                    o = isFunction$3(r) && "Boolean" === r.name;
                n[0] = o,
                n[1] = c,
                (o || hasOwn$1(n, "default")) && s.push(e)
            }
        }
    const l = [a, s];
    return isObject$1(e) && r.set(e, l),
    l
}
function validatePropName(e) {
    return "$" !== e[0] && !isReservedProp(e)
}
const isInternalKey = e => "_" === e[0] || "$stable" === e
  , normalizeSlotValue = e => isArray$2(e) ? e.map(normalizeVNode) : [normalizeVNode(e)]
  , normalizeSlot$1 = (e, t, n) => {
    if (t._n)
        return t;
    const r = withCtx(( (...e) => normalizeSlotValue(t(...e))), n);
    return r._c = !1,
    r
}
  , normalizeObjectSlots = (e, t, n) => {
    const r = e._ctx;
    for (const o in e) {
        if (isInternalKey(o))
            continue;
        const n = e[o];
        if (isFunction$3(n))
            t[o] = normalizeSlot$1(o, n, r);
        else if (null != n) {
            const e = normalizeSlotValue(n);
            t[o] = () => e
        }
    }
}
  , normalizeVNodeSlots = (e, t) => {
    const n = normalizeSlotValue(t);
    e.slots.default = () => n
}
  , assignSlots = (e, t, n) => {
    for (const r in t)
        (n || "_" !== r) && (e[r] = t[r])
}
  , initSlots = (e, t, n) => {
    const r = e.slots = createInternalObject();
    if (32 & e.vnode.shapeFlag) {
        const e = t._;
        e ? (assignSlots(r, t, n),
        n && def(r, "_", e, !0)) : normalizeObjectSlots(t, r)
    } else
        t && normalizeVNodeSlots(e, t)
}
  , updateSlots = (e, t, n) => {
    const {vnode: r, slots: o} = e;
    let i = !0
      , a = EMPTY_OBJ;
    if (32 & r.shapeFlag) {
        const e = t._;
        e ? n && 1 === e ? i = !1 : assignSlots(o, t, n) : (i = !t.$stable,
        normalizeObjectSlots(t, o)),
        a = t
    } else
        t && (normalizeVNodeSlots(e, t),
        a = {
            default: 1
        });
    if (i)
        for (const s in o)
            isInternalKey(s) || null != a[s] || delete o[s]
}
  , queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(e) {
    return baseCreateRenderer(e)
}
function createHydrationRenderer(e) {
    return baseCreateRenderer(e, createHydrationFunctions)
}
function baseCreateRenderer(e, t) {
    getGlobalThis().__VUE__ = !0;
    const {insert: n, remove: r, patchProp: o, createElement: i, createText: a, createComment: s, setText: c, setElementText: l, parentNode: u, nextSibling: p, setScopeId: d=NOOP, insertStaticContent: f} = e
      , h = (e, t, n, r=null, o=null, i=null, a=void 0, s=null, c=!!t.dynamicChildren) => {
        if (e === t)
            return;
        e && !isSameVNodeType(e, t) && (r = j(e),
        x(e, o, i, !0),
        e = null),
        -2 === t.patchFlag && (c = !1,
        t.dynamicChildren = null);
        const {type: l, ref: u, shapeFlag: p} = t;
        switch (l) {
        case Text:
            m(e, t, n, r);
            break;
        case Comment:
            g(e, t, n, r);
            break;
        case Static:
            null == e && v(t, n, r, a);
            break;
        case Fragment:
            T(e, t, n, r, o, i, a, s, c);
            break;
        default:
            1 & p ? y(e, t, n, r, o, i, a, s, c) : 6 & p ? A(e, t, n, r, o, i, a, s, c) : (64 & p || 128 & p) && l.process(e, t, n, r, o, i, a, s, c, V)
        }
        null != u && o && setRef(u, e && e.ref, i, t || e, !t)
    }
      , m = (e, t, r, o) => {
        if (null == e)
            n(t.el = a(t.children), r, o);
        else {
            const n = t.el = e.el;
            t.children !== e.children && c(n, t.children)
        }
    }
      , g = (e, t, r, o) => {
        null == e ? n(t.el = s(t.children || ""), r, o) : t.el = e.el
    }
      , v = (e, t, n, r) => {
        [e.el,e.anchor] = f(e.children, t, n, r, e.el, e.anchor)
    }
      , y = (e, t, n, r, o, i, a, s, c) => {
        "svg" === t.type ? a = "svg" : "math" === t.type && (a = "mathml"),
        null == e ? _(t, n, r, o, i, a, s, c) : w(e, t, o, i, a, s, c)
    }
      , _ = (e, t, r, a, s, c, u, p) => {
        let d, f;
        const {props: h, shapeFlag: m, transition: g, dirs: v} = e;
        if (d = e.el = i(e.type, c, h && h.is, h),
        8 & m ? l(d, e.children) : 16 & m && E(e.children, d, null, a, s, resolveChildrenNamespace(e, c), u, p),
        v && invokeDirectiveHook(e, null, a, "created"),
        b(d, e, e.scopeId, u, a),
        h) {
            for (const e in h)
                "value" === e || isReservedProp(e) || o(d, e, null, h[e], c, a);
            "value"in h && o(d, "value", null, h.value, c),
            (f = h.onVnodeBeforeMount) && invokeVNodeHook(f, a, e)
        }
        v && invokeDirectiveHook(e, null, a, "beforeMount");
        const y = needTransition(s, g);
        y && g.beforeEnter(d),
        n(d, t, r),
        ((f = h && h.onVnodeMounted) || y || v) && queuePostRenderEffect(( () => {
            f && invokeVNodeHook(f, a, e),
            y && g.enter(d),
            v && invokeDirectiveHook(e, null, a, "mounted")
        }
        ), s)
    }
      , b = (e, t, n, r, o) => {
        if (n && d(e, n),
        r)
            for (let i = 0; i < r.length; i++)
                d(e, r[i]);
        if (o) {
            let n = o.subTree;
            if (t === n || isSuspense(n.type) && (n.ssContent === t || n.ssFallback === t)) {
                const t = o.vnode;
                b(e, t, t.scopeId, t.slotScopeIds, o.parent)
            }
        }
    }
      , E = (e, t, n, r, o, i, a, s, c=0) => {
        for (let l = c; l < e.length; l++) {
            const c = e[l] = s ? cloneIfMounted(e[l]) : normalizeVNode(e[l]);
            h(null, c, t, n, r, o, i, a, s)
        }
    }
      , w = (e, t, n, r, i, a, s) => {
        const c = t.el = e.el;
        let {patchFlag: u, dynamicChildren: p, dirs: d} = t;
        u |= 16 & e.patchFlag;
        const f = e.props || EMPTY_OBJ
          , h = t.props || EMPTY_OBJ;
        let m;
        if (n && toggleRecurse(n, !1),
        (m = h.onVnodeBeforeUpdate) && invokeVNodeHook(m, n, t, e),
        d && invokeDirectiveHook(t, e, n, "beforeUpdate"),
        n && toggleRecurse(n, !0),
        (f.innerHTML && null == h.innerHTML || f.textContent && null == h.textContent) && l(c, ""),
        p ? S(e.dynamicChildren, p, c, n, r, resolveChildrenNamespace(t, i), a) : s || C(e, t, c, null, n, r, resolveChildrenNamespace(t, i), a, !1),
        u > 0) {
            if (16 & u)
                O(c, f, h, n, i);
            else if (2 & u && f.class !== h.class && o(c, "class", null, h.class, i),
            4 & u && o(c, "style", f.style, h.style, i),
            8 & u) {
                const e = t.dynamicProps;
                for (let t = 0; t < e.length; t++) {
                    const r = e[t]
                      , a = f[r]
                      , s = h[r];
                    s === a && "value" !== r || o(c, r, a, s, i, n)
                }
            }
            1 & u && e.children !== t.children && l(c, t.children)
        } else
            s || null != p || O(c, f, h, n, i);
        ((m = h.onVnodeUpdated) || d) && queuePostRenderEffect(( () => {
            m && invokeVNodeHook(m, n, t, e),
            d && invokeDirectiveHook(t, e, n, "updated")
        }
        ), r)
    }
      , S = (e, t, n, r, o, i, a) => {
        for (let s = 0; s < t.length; s++) {
            const c = e[s]
              , l = t[s]
              , p = c.el && (c.type === Fragment || !isSameVNodeType(c, l) || 70 & c.shapeFlag) ? u(c.el) : n;
            h(c, l, p, null, r, o, i, a, !0)
        }
    }
      , O = (e, t, n, r, i) => {
        if (t !== n) {
            if (t !== EMPTY_OBJ)
                for (const a in t)
                    isReservedProp(a) || a in n || o(e, a, t[a], null, i, r);
            for (const a in n) {
                if (isReservedProp(a))
                    continue;
                const s = n[a]
                  , c = t[a];
                s !== c && "value" !== a && o(e, a, c, s, i, r)
            }
            "value"in n && o(e, "value", t.value, n.value, i)
        }
    }
      , T = (e, t, r, o, i, s, c, l, u) => {
        const p = t.el = e ? e.el : a("")
          , d = t.anchor = e ? e.anchor : a("");
        let {patchFlag: f, dynamicChildren: h, slotScopeIds: m} = t;
        m && (l = l ? l.concat(m) : m),
        null == e ? (n(p, r, o),
        n(d, r, o),
        E(t.children || [], r, d, i, s, c, l, u)) : f > 0 && 64 & f && h && e.dynamicChildren ? (S(e.dynamicChildren, h, r, i, s, c, l),
        (null != t.key || i && t === i.subTree) && traverseStaticChildren(e, t, !0)) : C(e, t, r, d, i, s, c, l, u)
    }
      , A = (e, t, n, r, o, i, a, s, c) => {
        t.slotScopeIds = s,
        null == e ? 512 & t.shapeFlag ? o.ctx.activate(t, n, r, a, c) : R(t, n, r, o, i, a, c) : k(e, t, c)
    }
      , R = (e, t, n, r, o, i, a) => {
        const s = e.component = createComponentInstance(e, r, o);
        if (isKeepAlive(e) && (s.ctx.renderer = V),
        setupComponent(s, !1, a),
        s.asyncDep) {
            if (o && o.registerDep(s, P, a),
            !e.el) {
                const e = s.subTree = createVNode(Comment);
                g(null, e, t, n)
            }
        } else
            P(s, e, t, n, o, i, a)
    }
      , k = (e, t, n) => {
        const r = t.component = e.component;
        if (shouldUpdateComponent(e, t, n)) {
            if (r.asyncDep && !r.asyncResolved)
                return void $(r, t, n);
            r.next = t,
            r.update()
        } else
            t.el = e.el,
            r.vnode = t
    }
      , P = (e, t, n, r, o, i, a) => {
        const s = () => {
            if (e.isMounted) {
                let {next: t, bu: n, u: r, parent: c, vnode: l} = e;
                {
                    const n = locateNonHydratedAsyncRoot(e);
                    if (n)
                        return t && (t.el = l.el,
                        $(e, t, a)),
                        void n.asyncDep.then(( () => {
                            e.isUnmounted || s()
                        }
                        ))
                }
                let p, d = t;
                toggleRecurse(e, !1),
                t ? (t.el = l.el,
                $(e, t, a)) : t = l,
                n && invokeArrayFns(n),
                (p = t.props && t.props.onVnodeBeforeUpdate) && invokeVNodeHook(p, c, t, l),
                toggleRecurse(e, !0);
                const f = renderComponentRoot(e)
                  , m = e.subTree;
                e.subTree = f,
                h(m, f, u(m.el), j(m), e, o, i),
                t.el = f.el,
                null === d && updateHOCHostEl(e, f.el),
                r && queuePostRenderEffect(r, o),
                (p = t.props && t.props.onVnodeUpdated) && queuePostRenderEffect(( () => invokeVNodeHook(p, c, t, l)), o)
            } else {
                let a;
                const {el: s, props: c} = t
                  , {bm: l, m: u, parent: p, root: d, type: f} = e
                  , m = isAsyncWrapper(t);
                if (toggleRecurse(e, !1),
                l && invokeArrayFns(l),
                !m && (a = c && c.onVnodeBeforeMount) && invokeVNodeHook(a, p, t),
                toggleRecurse(e, !0),
                s && q) {
                    const t = () => {
                        e.subTree = renderComponentRoot(e),
                        q(s, e.subTree, e, o, null)
                    }
                    ;
                    m && f.__asyncHydrate ? f.__asyncHydrate(s, e, t) : t()
                } else {
                    d.ce && d.ce._injectChildStyle(f);
                    const a = e.subTree = renderComponentRoot(e);
                    h(null, a, n, r, e, o, i),
                    t.el = a.el
                }
                if (u && queuePostRenderEffect(u, o),
                !m && (a = c && c.onVnodeMounted)) {
                    const e = t;
                    queuePostRenderEffect(( () => invokeVNodeHook(a, p, e)), o)
                }
                (256 & t.shapeFlag || p && isAsyncWrapper(p.vnode) && 256 & p.vnode.shapeFlag) && e.a && queuePostRenderEffect(e.a, o),
                e.isMounted = !0,
                t = n = r = null
            }
        }
        ;
        e.scope.on();
        const c = e.effect = new ReactiveEffect(s);
        e.scope.off();
        const l = e.update = c.run.bind(c)
          , p = e.job = c.runIfDirty.bind(c);
        p.i = e,
        p.id = e.uid,
        c.scheduler = () => queueJob(p),
        toggleRecurse(e, !0),
        l()
    }
      , $ = (e, t, n) => {
        t.component = e;
        const r = e.vnode.props;
        e.vnode = t,
        e.next = null,
        updateProps(e, t.props, r, n),
        updateSlots(e, t.children, n),
        pauseTracking(),
        flushPreFlushCbs(e),
        resetTracking()
    }
      , C = (e, t, n, r, o, i, a, s, c=!1) => {
        const u = e && e.children
          , p = e ? e.shapeFlag : 0
          , d = t.children
          , {patchFlag: f, shapeFlag: h} = t;
        if (f > 0) {
            if (128 & f)
                return void N(u, d, n, r, o, i, a, s, c);
            if (256 & f)
                return void I(u, d, n, r, o, i, a, s, c)
        }
        8 & h ? (16 & p && F(u, o, i),
        d !== u && l(n, d)) : 16 & p ? 16 & h ? N(u, d, n, r, o, i, a, s, c) : F(u, o, i, !0) : (8 & p && l(n, ""),
        16 & h && E(d, n, r, o, i, a, s, c))
    }
      , I = (e, t, n, r, o, i, a, s, c) => {
        t = t || EMPTY_ARR;
        const l = (e = e || EMPTY_ARR).length
          , u = t.length
          , p = Math.min(l, u);
        let d;
        for (d = 0; d < p; d++) {
            const r = t[d] = c ? cloneIfMounted(t[d]) : normalizeVNode(t[d]);
            h(e[d], r, n, null, o, i, a, s, c)
        }
        l > u ? F(e, o, i, !0, !1, p) : E(t, n, r, o, i, a, s, c, p)
    }
      , N = (e, t, n, r, o, i, a, s, c) => {
        let l = 0;
        const u = t.length;
        let p = e.length - 1
          , d = u - 1;
        for (; l <= p && l <= d; ) {
            const r = e[l]
              , u = t[l] = c ? cloneIfMounted(t[l]) : normalizeVNode(t[l]);
            if (!isSameVNodeType(r, u))
                break;
            h(r, u, n, null, o, i, a, s, c),
            l++
        }
        for (; l <= p && l <= d; ) {
            const r = e[p]
              , l = t[d] = c ? cloneIfMounted(t[d]) : normalizeVNode(t[d]);
            if (!isSameVNodeType(r, l))
                break;
            h(r, l, n, null, o, i, a, s, c),
            p--,
            d--
        }
        if (l > p) {
            if (l <= d) {
                const e = d + 1
                  , p = e < u ? t[e].el : r;
                for (; l <= d; )
                    h(null, t[l] = c ? cloneIfMounted(t[l]) : normalizeVNode(t[l]), n, p, o, i, a, s, c),
                    l++
            }
        } else if (l > d)
            for (; l <= p; )
                x(e[l], o, i, !0),
                l++;
        else {
            const f = l
              , m = l
              , g = new Map;
            for (l = m; l <= d; l++) {
                const e = t[l] = c ? cloneIfMounted(t[l]) : normalizeVNode(t[l]);
                null != e.key && g.set(e.key, l)
            }
            let v, y = 0;
            const _ = d - m + 1;
            let b = !1
              , E = 0;
            const w = new Array(_);
            for (l = 0; l < _; l++)
                w[l] = 0;
            for (l = f; l <= p; l++) {
                const r = e[l];
                if (y >= _) {
                    x(r, o, i, !0);
                    continue
                }
                let u;
                if (null != r.key)
                    u = g.get(r.key);
                else
                    for (v = m; v <= d; v++)
                        if (0 === w[v - m] && isSameVNodeType(r, t[v])) {
                            u = v;
                            break
                        }
                void 0 === u ? x(r, o, i, !0) : (w[u - m] = l + 1,
                u >= E ? E = u : b = !0,
                h(r, t[u], n, null, o, i, a, s, c),
                y++)
            }
            const S = b ? getSequence(w) : EMPTY_ARR;
            for (v = S.length - 1,
            l = _ - 1; l >= 0; l--) {
                const e = m + l
                  , p = t[e]
                  , d = e + 1 < u ? t[e + 1].el : r;
                0 === w[l] ? h(null, p, n, d, o, i, a, s, c) : b && (v < 0 || l !== S[v] ? L(p, n, d, 2) : v--)
            }
        }
    }
      , L = (e, t, r, o, i=null) => {
        const {el: a, type: s, transition: c, children: l, shapeFlag: u} = e;
        if (6 & u)
            return void L(e.component.subTree, t, r, o);
        if (128 & u)
            return void e.suspense.move(t, r, o);
        if (64 & u)
            return void s.move(e, t, r, V);
        if (s === Fragment) {
            n(a, t, r);
            for (let e = 0; e < l.length; e++)
                L(l[e], t, r, o);
            return void n(e.anchor, t, r)
        }
        if (s === Static)
            return void ( ({el: e, anchor: t}, r, o) => {
                let i;
                for (; e && e !== t; )
                    i = p(e),
                    n(e, r, o),
                    e = i;
                n(t, r, o)
            }
            )(e, t, r);
        if (2 !== o && 1 & u && c)
            if (0 === o)
                c.beforeEnter(a),
                n(a, t, r),
                queuePostRenderEffect(( () => c.enter(a)), i);
            else {
                const {leave: e, delayLeave: o, afterLeave: i} = c
                  , s = () => n(a, t, r)
                  , l = () => {
                    e(a, ( () => {
                        s(),
                        i && i()
                    }
                    ))
                }
                ;
                o ? o(a, s, l) : l()
            }
        else
            n(a, t, r)
    }
      , x = (e, t, n, r=!1, o=!1) => {
        const {type: i, props: a, ref: s, children: c, dynamicChildren: l, shapeFlag: u, patchFlag: p, dirs: d, cacheIndex: f} = e;
        if (-2 === p && (o = !1),
        null != s && setRef(s, null, n, e, !0),
        null != f && (t.renderCache[f] = void 0),
        256 & u)
            return void t.ctx.deactivate(e);
        const h = 1 & u && d
          , m = !isAsyncWrapper(e);
        let g;
        if (m && (g = a && a.onVnodeBeforeUnmount) && invokeVNodeHook(g, t, e),
        6 & u)
            U(e.component, n, r);
        else {
            if (128 & u)
                return void e.suspense.unmount(n, r);
            h && invokeDirectiveHook(e, null, t, "beforeUnmount"),
            64 & u ? e.type.remove(e, t, n, V, r) : l && !l.hasOnce && (i !== Fragment || p > 0 && 64 & p) ? F(l, t, n, !1, !0) : (i === Fragment && 384 & p || !o && 16 & u) && F(c, t, n),
            r && M(e)
        }
        (m && (g = a && a.onVnodeUnmounted) || h) && queuePostRenderEffect(( () => {
            g && invokeVNodeHook(g, t, e),
            h && invokeDirectiveHook(e, null, t, "unmounted")
        }
        ), n)
    }
      , M = e => {
        const {type: t, el: n, anchor: o, transition: i} = e;
        if (t === Fragment)
            return void D(n, o);
        if (t === Static)
            return void ( ({el: e, anchor: t}) => {
                let n;
                for (; e && e !== t; )
                    n = p(e),
                    r(e),
                    e = n;
                r(t)
            }
            )(e);
        const a = () => {
            r(n),
            i && !i.persisted && i.afterLeave && i.afterLeave()
        }
        ;
        if (1 & e.shapeFlag && i && !i.persisted) {
            const {leave: t, delayLeave: r} = i
              , o = () => t(n, a);
            r ? r(e.el, a, o) : o()
        } else
            a()
    }
      , D = (e, t) => {
        let n;
        for (; e !== t; )
            n = p(e),
            r(e),
            e = n;
        r(t)
    }
      , U = (e, t, n) => {
        const {bum: r, scope: o, job: i, subTree: a, um: s, m: c, a: l} = e;
        invalidateMount(c),
        invalidateMount(l),
        r && invokeArrayFns(r),
        o.stop(),
        i && (i.flags |= 8,
        x(a, e, t, n)),
        s && queuePostRenderEffect(s, t),
        queuePostRenderEffect(( () => {
            e.isUnmounted = !0
        }
        ), t),
        t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--,
        0 === t.deps && t.resolve())
    }
      , F = (e, t, n, r=!1, o=!1, i=0) => {
        for (let a = i; a < e.length; a++)
            x(e[a], t, n, r, o)
    }
      , j = e => {
        if (6 & e.shapeFlag)
            return j(e.component.subTree);
        if (128 & e.shapeFlag)
            return e.suspense.next();
        const t = p(e.anchor || e.el)
          , n = t && t[TeleportEndKey];
        return n ? p(n) : t
    }
    ;
    let B = !1;
    const H = (e, t, n) => {
        null == e ? t._vnode && x(t._vnode, null, null, !0) : h(t._vnode || null, e, t, null, null, null, n),
        t._vnode = e,
        B || (B = !0,
        flushPreFlushCbs(),
        flushPostFlushCbs(),
        B = !1)
    }
      , V = {
        p: h,
        um: x,
        m: L,
        r: M,
        mt: R,
        mc: E,
        pc: C,
        pbc: S,
        n: j,
        o: e
    };
    let G, q;
    return t && ([G,q] = t(V)),
    {
        render: H,
        hydrate: G,
        createApp: createAppAPI(H, G)
    }
}
function resolveChildrenNamespace({type: e, props: t}, n) {
    return "svg" === n && "foreignObject" === e || "mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}
function toggleRecurse({effect: e, job: t}, n) {
    n ? (e.flags |= 32,
    t.flags |= 4) : (e.flags &= -33,
    t.flags &= -5)
}
function needTransition(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function traverseStaticChildren(e, t, n=!1) {
    const r = e.children
      , o = t.children;
    if (isArray$2(r) && isArray$2(o))
        for (let i = 0; i < r.length; i++) {
            const e = r[i];
            let t = o[i];
            1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = o[i] = cloneIfMounted(o[i]),
            t.el = e.el),
            n || -2 === t.patchFlag || traverseStaticChildren(e, t)),
            t.type === Text && (t.el = e.el)
        }
}
function getSequence(e) {
    const t = e.slice()
      , n = [0];
    let r, o, i, a, s;
    const c = e.length;
    for (r = 0; r < c; r++) {
        const c = e[r];
        if (0 !== c) {
            if (o = n[n.length - 1],
            e[o] < c) {
                t[r] = o,
                n.push(r);
                continue
            }
            for (i = 0,
            a = n.length - 1; i < a; )
                s = i + a >> 1,
                e[n[s]] < c ? i = s + 1 : a = s;
            c < e[n[i]] && (i > 0 && (t[r] = n[i - 1]),
            n[i] = r)
        }
    }
    for (i = n.length,
    a = n[i - 1]; i-- > 0; )
        n[i] = a,
        a = t[a];
    return n
}
function locateNonHydratedAsyncRoot(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : locateNonHydratedAsyncRoot(t)
}
function invalidateMount(e) {
    if (e)
        for (let t = 0; t < e.length; t++)
            e[t].flags |= 8
}
const ssrContextKey = Symbol.for("v-scx")
  , useSSRContext = () => inject(ssrContextKey);
function watchEffect(e, t) {
    return doWatch(e, null, t)
}
function watchSyncEffect(e, t) {
    return doWatch(e, null, {
        flush: "sync"
    })
}
function watch(e, t, n) {
    return doWatch(e, t, n)
}
function doWatch(e, t, n=EMPTY_OBJ) {
    const {immediate: r, deep: o, flush: i, once: a} = n
      , s = extend$2({}, n)
      , c = t && r || !t && "post" !== i;
    let l;
    if (isInSSRComponentSetup)
        if ("sync" === i) {
            const e = useSSRContext();
            l = e.__watcherHandles || (e.__watcherHandles = [])
        } else if (!c) {
            const e = () => {}
            ;
            return e.stop = NOOP,
            e.resume = NOOP,
            e.pause = NOOP,
            e
        }
    const u = currentInstance;
    s.call = (e, t, n) => callWithAsyncErrorHandling(e, u, t, n);
    let p = !1;
    "post" === i ? s.scheduler = e => {
        queuePostRenderEffect(e, u && u.suspense)
    }
    : "sync" !== i && (p = !0,
    s.scheduler = (e, t) => {
        t ? e() : queueJob(e)
    }
    ),
    s.augmentJob = e => {
        t && (e.flags |= 4),
        p && (e.flags |= 2,
        u && (e.id = u.uid,
        e.i = u))
    }
    ;
    const d = watch$1(e, t, s);
    return isInSSRComponentSetup && (l ? l.push(d) : c && d()),
    d
}
function instanceWatch(e, t, n) {
    const r = this.proxy
      , o = isString$2(e) ? e.includes(".") ? createPathGetter(r, e) : () => r[e] : e.bind(r, r);
    let i;
    isFunction$3(t) ? i = t : (i = t.handler,
    n = t);
    const a = setCurrentInstance(this)
      , s = doWatch(o, i.bind(r), n);
    return a(),
    s
}
function createPathGetter(e, t) {
    const n = t.split(".");
    return () => {
        let t = e;
        for (let e = 0; e < n.length && t; e++)
            t = t[n[e]];
        return t
    }
}
function useModel$1(e, t, n=EMPTY_OBJ) {
    const r = getCurrentInstance()
      , o = camelize(t)
      , i = hyphenate(t)
      , a = getModelModifiers(e, o)
      , s = customRef(( (a, s) => {
        let c, l, u = EMPTY_OBJ;
        return watchSyncEffect(( () => {
            const t = e[o];
            hasChanged(c, t) && (c = t,
            s())
        }
        )),
        {
            get: () => (a(),
            n.get ? n.get(c) : c),
            set(e) {
                const a = n.set ? n.set(e) : e;
                if (!(hasChanged(a, c) || u !== EMPTY_OBJ && hasChanged(e, u)))
                    return;
                const p = r.vnode.props;
                p && (t in p || o in p || i in p) && ("onUpdate:".concat(t)in p || "onUpdate:".concat(o)in p || "onUpdate:".concat(i)in p) || (c = e,
                s()),
                r.emit("update:".concat(t), a),
                hasChanged(e, a) && hasChanged(e, u) && !hasChanged(a, l) && s(),
                u = e,
                l = a
            }
        }
    }
    ));
    return s[Symbol.iterator] = () => {
        let e = 0;
        return {
            next: () => e < 2 ? {
                value: e++ ? a || EMPTY_OBJ : s,
                done: !1
            } : {
                done: !0
            }
        }
    }
    ,
    s
}
const getModelModifiers = (e, t) => "modelValue" === t || "model-value" === t ? e.modelModifiers : e["".concat(t, "Modifiers")] || e["".concat(camelize(t), "Modifiers")] || e["".concat(hyphenate(t), "Modifiers")];
function emit(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const r = e.vnode.props || EMPTY_OBJ;
    let o = n;
    const i = t.startsWith("update:")
      , a = i && getModelModifiers(r, t.slice(7));
    let s;
    a && (a.trim && (o = n.map((e => isString$2(e) ? e.trim() : e))),
    a.number && (o = n.map(looseToNumber)));
    let c = r[s = toHandlerKey(t)] || r[s = toHandlerKey(camelize(t))];
    !c && i && (c = r[s = toHandlerKey(hyphenate(t))]),
    c && callWithAsyncErrorHandling(c, e, 6, o);
    const l = r[s + "Once"];
    if (l) {
        if (e.emitted) {
            if (e.emitted[s])
                return
        } else
            e.emitted = {};
        e.emitted[s] = !0,
        callWithAsyncErrorHandling(l, e, 6, o)
    }
}
function normalizeEmitsOptions(e, t, n=!1) {
    const r = t.emitsCache
      , o = r.get(e);
    if (void 0 !== o)
        return o;
    const i = e.emits;
    let a = {}
      , s = !1;
    if (!isFunction$3(e)) {
        const r = e => {
            const n = normalizeEmitsOptions(e, t, !0);
            n && (s = !0,
            extend$2(a, n))
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(r),
        e.extends && r(e.extends),
        e.mixins && e.mixins.forEach(r)
    }
    return i || s ? (isArray$2(i) ? i.forEach((e => a[e] = null)) : extend$2(a, i),
    isObject$1(e) && r.set(e, a),
    a) : (isObject$1(e) && r.set(e, null),
    null)
}
function isEmitListener(e, t) {
    return !(!e || !isOn(t)) && (t = t.slice(2).replace(/Once$/, ""),
    hasOwn$1(e, t[0].toLowerCase() + t.slice(1)) || hasOwn$1(e, hyphenate(t)) || hasOwn$1(e, t))
}
function markAttrsAccessed() {}
function renderComponentRoot(e) {
    const {type: t, vnode: n, proxy: r, withProxy: o, propsOptions: [i], slots: a, attrs: s, emit: c, render: l, renderCache: u, props: p, data: d, setupState: f, ctx: h, inheritAttrs: m} = e
      , g = setCurrentRenderingInstance(e);
    let v, y;
    try {
        if (4 & n.shapeFlag) {
            const e = o || r
              , t = e;
            v = normalizeVNode(l.call(t, e, u, p, f, d, h)),
            y = s
        } else {
            const e = t;
            0,
            v = normalizeVNode(e.length > 1 ? e(p, {
                attrs: s,
                slots: a,
                emit: c
            }) : e(p, null)),
            y = t.props ? s : getFunctionalFallthrough(s)
        }
    } catch (b) {
        blockStack.length = 0,
        handleError(b, e, 1),
        v = createVNode(Comment)
    }
    let _ = v;
    if (y && !1 !== m) {
        const e = Object.keys(y)
          , {shapeFlag: t} = _;
        e.length && 7 & t && (i && e.some(isModelListener) && (y = filterModelListeners(y, i)),
        _ = cloneVNode(_, y, !1, !0))
    }
    return n.dirs && (_ = cloneVNode(_, null, !1, !0),
    _.dirs = _.dirs ? _.dirs.concat(n.dirs) : n.dirs),
    n.transition && setTransitionHooks(_, n.transition),
    v = _,
    setCurrentRenderingInstance(g),
    v
}
const getFunctionalFallthrough = e => {
    let t;
    for (const n in e)
        ("class" === n || "style" === n || isOn(n)) && ((t || (t = {}))[n] = e[n]);
    return t
}
  , filterModelListeners = (e, t) => {
    const n = {};
    for (const r in e)
        isModelListener(r) && r.slice(9)in t || (n[r] = e[r]);
    return n
}
;
function shouldUpdateComponent(e, t, n) {
    const {props: r, children: o, component: i} = e
      , {props: a, children: s, patchFlag: c} = t
      , l = i.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (!(n && c >= 0))
        return !(!o && !s || s && s.$stable) || r !== a && (r ? !a || hasPropsChanged(r, a, l) : !!a);
    if (1024 & c)
        return !0;
    if (16 & c)
        return r ? hasPropsChanged(r, a, l) : !!a;
    if (8 & c) {
        const e = t.dynamicProps;
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            if (a[n] !== r[n] && !isEmitListener(l, n))
                return !0
        }
    }
    return !1
}
function hasPropsChanged(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length)
        return !0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        if (t[i] !== e[i] && !isEmitListener(n, i))
            return !0
    }
    return !1
}
function updateHOCHostEl({vnode: e, parent: t}, n) {
    for (; t; ) {
        const r = t.subTree;
        if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el),
        r !== e)
            break;
        (e = t.vnode).el = n,
        t = t.parent
    }
}
const isSuspense = e => e.__isSuspense;
function queueEffectWithSuspense(e, t) {
    t && t.pendingBranch ? isArray$2(e) ? t.effects.push(...e) : t.effects.push(e) : queuePostFlushCb(e)
}
const Fragment = Symbol.for("v-fgt")
  , Text = Symbol.for("v-txt")
  , Comment = Symbol.for("v-cmt")
  , Static = Symbol.for("v-stc")
  , blockStack = [];
let currentBlock = null;
function openBlock(e=!1) {
    blockStack.push(currentBlock = e ? null : [])
}
function closeBlock() {
    blockStack.pop(),
    currentBlock = blockStack[blockStack.length - 1] || null
}
let isBlockTreeEnabled = 1;
function setBlockTracking(e, t=!1) {
    isBlockTreeEnabled += e,
    e < 0 && currentBlock && t && (currentBlock.hasOnce = !0)
}
function setupBlock(e) {
    return e.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null,
    closeBlock(),
    isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(e),
    e
}
function createElementBlock(e, t, n, r, o, i) {
    return setupBlock(createBaseVNode(e, t, n, r, o, i, !0))
}
function createBlock(e, t, n, r, o) {
    return setupBlock(createVNode(e, t, n, r, o, !0))
}
function isVNode(e) {
    return !!e && !0 === e.__v_isVNode
}
function isSameVNodeType(e, t) {
    return e.type === t.type && e.key === t.key
}
const normalizeKey = ({key: e}) => null != e ? e : null
  , normalizeRef = ({ref: e, ref_key: t, ref_for: n}) => ("number" == typeof e && (e = "" + e),
null != e ? isString$2(e) || isRef(e) || isFunction$3(e) ? {
    i: currentRenderingInstance,
    r: e,
    k: t,
    f: !!n
} : e : null);
function createBaseVNode(e, t=null, n=null, r=0, o=null, i=(e === Fragment ? 0 : 1), a=!1, s=!1) {
    const c = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && normalizeKey(t),
        ref: t && normalizeRef(t),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: r,
        dynamicProps: o,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    return s ? (normalizeChildren(c, n),
    128 & i && e.normalize(c)) : n && (c.shapeFlag |= isString$2(n) ? 8 : 16),
    isBlockTreeEnabled > 0 && !a && currentBlock && (c.patchFlag > 0 || 6 & i) && 32 !== c.patchFlag && currentBlock.push(c),
    c
}
const createVNode = _createVNode;
function _createVNode(e, t=null, n=null, r=0, o=null, i=!1) {
    if (e && e !== NULL_DYNAMIC_COMPONENT || (e = Comment),
    isVNode(e)) {
        const r = cloneVNode(e, t, !0);
        return n && normalizeChildren(r, n),
        isBlockTreeEnabled > 0 && !i && currentBlock && (6 & r.shapeFlag ? currentBlock[currentBlock.indexOf(e)] = r : currentBlock.push(r)),
        r.patchFlag = -2,
        r
    }
    if (isClassComponent(e) && (e = e.__vccOpts),
    t) {
        t = guardReactiveProps(t);
        let {class: e, style: n} = t;
        e && !isString$2(e) && (t.class = normalizeClass(e)),
        isObject$1(n) && (isProxy(n) && !isArray$2(n) && (n = extend$2({}, n)),
        t.style = normalizeStyle(n))
    }
    return createBaseVNode(e, t, n, r, o, isString$2(e) ? 1 : isSuspense(e) ? 128 : isTeleport(e) ? 64 : isObject$1(e) ? 4 : isFunction$3(e) ? 2 : 0, i, !0)
}
function guardReactiveProps(e) {
    return e ? isProxy(e) || isInternalObject(e) ? extend$2({}, e) : e : null
}
function cloneVNode(e, t, n=!1, r=!1) {
    const {props: o, ref: i, patchFlag: a, children: s, transition: c} = e
      , l = t ? mergeProps(o || {}, t) : o
      , u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: l,
        key: l && normalizeKey(l),
        ref: t && t.ref ? n && i ? isArray$2(i) ? i.concat(normalizeRef(t)) : [i, normalizeRef(t)] : normalizeRef(t) : i,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: s,
        target: e.target,
        targetStart: e.targetStart,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Fragment ? -1 === a ? 16 : 16 | a : a,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: c,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && cloneVNode(e.ssContent),
        ssFallback: e.ssFallback && cloneVNode(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    };
    return c && r && setTransitionHooks(u, c.clone(u)),
    u
}
function createTextVNode(e=" ", t=0) {
    return createVNode(Text, null, e, t)
}
function createStaticVNode(e, t) {
    const n = createVNode(Static, null, e);
    return n.staticCount = t,
    n
}
function createCommentVNode(e="", t=!1) {
    return t ? (openBlock(),
    createBlock(Comment, null, e)) : createVNode(Comment, null, e)
}
function normalizeVNode(e) {
    return null == e || "boolean" == typeof e ? createVNode(Comment) : isArray$2(e) ? createVNode(Fragment, null, e.slice()) : isVNode(e) ? cloneIfMounted(e) : createVNode(Text, null, String(e))
}
function cloneIfMounted(e) {
    return null === e.el && -1 !== e.patchFlag || e.memo ? e : cloneVNode(e)
}
function normalizeChildren(e, t) {
    let n = 0;
    const {shapeFlag: r} = e;
    if (null == t)
        t = null;
    else if (isArray$2(t))
        n = 16;
    else if ("object" == typeof t) {
        if (65 & r) {
            const n = t.default;
            return void (n && (n._c && (n._d = !1),
            normalizeChildren(e, n()),
            n._c && (n._d = !0)))
        }
        {
            n = 32;
            const r = t._;
            r || isInternalObject(t) ? 3 === r && currentRenderingInstance && (1 === currentRenderingInstance.slots._ ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024)) : t._ctx = currentRenderingInstance
        }
    } else
        isFunction$3(t) ? (t = {
            default: t,
            _ctx: currentRenderingInstance
        },
        n = 32) : (t = String(t),
        64 & r ? (n = 16,
        t = [createTextVNode(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function mergeProps(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const e in r)
            if ("class" === e)
                t.class !== r.class && (t.class = normalizeClass([t.class, r.class]));
            else if ("style" === e)
                t.style = normalizeStyle([t.style, r.style]);
            else if (isOn(e)) {
                const n = t[e]
                  , o = r[e];
                !o || n === o || isArray$2(n) && n.includes(o) || (t[e] = n ? [].concat(n, o) : o)
            } else
                "" !== e && (t[e] = r[e])
    }
    return t
}
function invokeVNodeHook(e, t, n, r=null) {
    callWithAsyncErrorHandling(e, t, 7, [n, r])
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(e, t, n) {
    const r = e.type
      , o = (t ? t.appContext : e.appContext) || emptyAppContext
      , i = {
        uid: uid++,
        vnode: e,
        type: r,
        parent: t,
        appContext: o,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new EffectScope(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(o.provides),
        ids: t ? t.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: normalizePropsOptions(r, o),
        emitsOptions: normalizeEmitsOptions(r, o),
        emit: null,
        emitted: null,
        propsDefaults: EMPTY_OBJ,
        inheritAttrs: r.inheritAttrs,
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return i.ctx = {
        _: i
    },
    i.root = t ? t.root : i,
    i.emit = emit.bind(null, i),
    e.ce && e.ce(i),
    i
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance, setInSSRSetupState;
{
    const e = getGlobalThis()
      , t = (t, n) => {
        let r;
        return (r = e[t]) || (r = e[t] = []),
        r.push(n),
        e => {
            r.length > 1 ? r.forEach((t => t(e))) : r[0](e)
        }
    }
    ;
    internalSetCurrentInstance = t("__VUE_INSTANCE_SETTERS__", (e => currentInstance = e)),
    setInSSRSetupState = t("__VUE_SSR_SETTERS__", (e => isInSSRComponentSetup = e))
}
const setCurrentInstance = e => {
    const t = currentInstance;
    return internalSetCurrentInstance(e),
    e.scope.on(),
    () => {
        e.scope.off(),
        internalSetCurrentInstance(t)
    }
}
  , unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off(),
    internalSetCurrentInstance(null)
}
;
function isStatefulComponent(e) {
    return 4 & e.vnode.shapeFlag
}
let isInSSRComponentSetup = !1, compile$1;
function setupComponent(e, t=!1, n=!1) {
    t && setInSSRSetupState(t);
    const {props: r, children: o} = e.vnode
      , i = isStatefulComponent(e);
    initProps(e, r, i, t),
    initSlots(e, o, n);
    const a = i ? setupStatefulComponent(e, t) : void 0;
    return t && setInSSRSetupState(!1),
    a
}
function setupStatefulComponent(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null),
    e.proxy = new Proxy(e.ctx,PublicInstanceProxyHandlers);
    const {setup: r} = n;
    if (r) {
        pauseTracking();
        const n = e.setupContext = r.length > 1 ? createSetupContext(e) : null
          , o = setCurrentInstance(e)
          , i = callWithErrorHandling(r, e, 0, [e.props, n])
          , a = isPromise$1(i);
        if (resetTracking(),
        o(),
        !a && !e.sp || isAsyncWrapper(e) || markAsyncBoundary(e),
        a) {
            if (i.then(unsetCurrentInstance, unsetCurrentInstance),
            t)
                return i.then((n => {
                    handleSetupResult(e, n, t)
                }
                )).catch((t => {
                    handleError(t, e, 0)
                }
                ));
            e.asyncDep = i
        } else
            handleSetupResult(e, i, t)
    } else
        finishComponentSetup(e, t)
}
function handleSetupResult(e, t, n) {
    isFunction$3(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : isObject$1(t) && (e.setupState = proxyRefs(t)),
    finishComponentSetup(e, n)
}
function finishComponentSetup(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && compile$1 && !r.render) {
            const t = r.template || resolveMergedOptions(e).template;
            if (t) {
                const {isCustomElement: n, compilerOptions: o} = e.appContext.config
                  , {delimiters: i, compilerOptions: a} = r
                  , s = extend$2(extend$2({
                    isCustomElement: n,
                    delimiters: i
                }, o), a);
                r.render = compile$1(t, s)
            }
        }
        e.render = r.render || NOOP
    }
    {
        const t = setCurrentInstance(e);
        pauseTracking();
        try {
            applyOptions(e)
        } finally {
            resetTracking(),
            t()
        }
    }
}
const attrsProxyHandlers = {
    get: (e, t) => (track(e, "get", ""),
    e[t])
};
function createSetupContext(e) {
    const t = t => {
        e.exposed = t || {}
    }
    ;
    return {
        attrs: new Proxy(e.attrs,attrsProxyHandlers),
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function getComponentPublicInstance(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(proxyRefs(markRaw(e.exposed)),{
        get: (t, n) => n in t ? t[n] : n in publicPropertiesMap ? publicPropertiesMap[n](e) : void 0,
        has: (e, t) => t in e || t in publicPropertiesMap
    })) : e.proxy
}
const classifyRE = /(?:^|[-_])(\w)/g
  , classify = e => e.replace(classifyRE, (e => e.toUpperCase())).replace(/[-_]/g, "");
function getComponentName(e, t=!0) {
    return isFunction$3(e) ? e.displayName || e.name : e.name || t && e.__name
}
function formatComponentName(e, t, n=!1) {
    let r = getComponentName(t);
    if (!r && t.__file) {
        const e = t.__file.match(/([^/\\]+)\.\w+$/);
        e && (r = e[1])
    }
    if (!r && e && e.parent) {
        const n = e => {
            for (const n in e)
                if (e[n] === t)
                    return n
        }
        ;
        r = n(e.components || e.parent.type.components) || n(e.appContext.components)
    }
    return r ? classify(r) : n ? "App" : "Anonymous"
}
function isClassComponent(e) {
    return isFunction$3(e) && "__vccOpts"in e
}
const computed = (e, t) => computed$1(e, t, isInSSRComponentSetup);
function h$5(e, t, n) {
    const r = arguments.length;
    return 2 === r ? isObject$1(t) && !isArray$2(t) ? isVNode(t) ? createVNode(e, null, [t]) : createVNode(e, t) : createVNode(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && isVNode(n) && (n = [n]),
    createVNode(e, t, n))
}
const version$1 = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy;
const tt$2 = "undefined" != typeof window && window.trustedTypes;
if (tt$2)
    try {
        policy = tt$2.createPolicy("vue", {
            createHTML: e => e
        })
    } catch (e2) {}
const unsafeToTrustedHTML = policy ? e => policy.createHTML(e) : e => e
  , svgNS = "http://www.w3.org/2000/svg"
  , mathmlNS = "http://www.w3.org/1998/Math/MathML"
  , doc = "undefined" != typeof document ? document : null
  , templateContainer = doc && doc.createElement("template")
  , nodeOps = {
    insert: (e, t, n) => {
        t.insertBefore(e, n || null)
    }
    ,
    remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e, t, n, r) => {
        const o = "svg" === t ? doc.createElementNS(svgNS, e) : "mathml" === t ? doc.createElementNS(mathmlNS, e) : n ? doc.createElement(e, {
            is: n
        }) : doc.createElement(e);
        return "select" === e && r && null != r.multiple && o.setAttribute("multiple", r.multiple),
        o
    }
    ,
    createText: e => doc.createTextNode(e),
    createComment: e => doc.createComment(e),
    setText: (e, t) => {
        e.nodeValue = t
    }
    ,
    setElementText: (e, t) => {
        e.textContent = t
    }
    ,
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => doc.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, r, o, i) {
        const a = n ? n.previousSibling : t.lastChild;
        if (o && (o === i || o.nextSibling))
            for (; t.insertBefore(o.cloneNode(!0), n),
            o !== i && (o = o.nextSibling); )
                ;
        else {
            templateContainer.innerHTML = unsafeToTrustedHTML("svg" === r ? "<svg>".concat(e, "</svg>") : "mathml" === r ? "<math>".concat(e, "</math>") : e);
            const o = templateContainer.content;
            if ("svg" === r || "mathml" === r) {
                const e = o.firstChild;
                for (; e.firstChild; )
                    o.appendChild(e.firstChild);
                o.removeChild(e)
            }
            t.insertBefore(o, n)
        }
        return [a ? a.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
}
  , TRANSITION = "transition"
  , ANIMATION = "animation"
  , vtcKey = Symbol("_vtc")
  , DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , TransitionPropsValidators = extend$2({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators)
  , decorate$1 = e => (e.displayName = "Transition",
e.props = TransitionPropsValidators,
e)
  , Transition = decorate$1(( (e, {slots: t}) => h$5(BaseTransition, resolveTransitionProps(e), t)))
  , callHook = (e, t=[]) => {
    isArray$2(e) ? e.forEach((e => e(...t))) : e && e(...t)
}
  , hasExplicitCallback = e => !!e && (isArray$2(e) ? e.some((e => e.length > 1)) : e.length > 1);
function resolveTransitionProps(e) {
    const t = {};
    for (const k in e)
        k in DOMTransitionPropsValidators || (t[k] = e[k]);
    if (!1 === e.css)
        return t;
    const {name: n="v", type: r, duration: o, enterFromClass: i="".concat(n, "-enter-from"), enterActiveClass: a="".concat(n, "-enter-active"), enterToClass: s="".concat(n, "-enter-to"), appearFromClass: c=i, appearActiveClass: l=a, appearToClass: u=s, leaveFromClass: p="".concat(n, "-leave-from"), leaveActiveClass: d="".concat(n, "-leave-active"), leaveToClass: f="".concat(n, "-leave-to")} = e
      , h = normalizeDuration(o)
      , m = h && h[0]
      , g = h && h[1]
      , {onBeforeEnter: v, onEnter: y, onEnterCancelled: _, onLeave: b, onLeaveCancelled: E, onBeforeAppear: w=v, onAppear: S=y, onAppearCancelled: O=_} = t
      , T = (e, t, n, r) => {
        e._enterCancelled = r,
        removeTransitionClass(e, t ? u : s),
        removeTransitionClass(e, t ? l : a),
        n && n()
    }
      , A = (e, t) => {
        e._isLeaving = !1,
        removeTransitionClass(e, p),
        removeTransitionClass(e, f),
        removeTransitionClass(e, d),
        t && t()
    }
      , R = e => (t, n) => {
        const o = e ? S : y
          , a = () => T(t, e, n);
        callHook(o, [t, a]),
        nextFrame(( () => {
            removeTransitionClass(t, e ? c : i),
            addTransitionClass(t, e ? u : s),
            hasExplicitCallback(o) || whenTransitionEnds(t, r, m, a)
        }
        ))
    }
    ;
    return extend$2(t, {
        onBeforeEnter(e) {
            callHook(v, [e]),
            addTransitionClass(e, i),
            addTransitionClass(e, a)
        },
        onBeforeAppear(e) {
            callHook(w, [e]),
            addTransitionClass(e, c),
            addTransitionClass(e, l)
        },
        onEnter: R(!1),
        onAppear: R(!0),
        onLeave(e, t) {
            e._isLeaving = !0;
            const n = () => A(e, t);
            addTransitionClass(e, p),
            e._enterCancelled ? (addTransitionClass(e, d),
            forceReflow()) : (forceReflow(),
            addTransitionClass(e, d)),
            nextFrame(( () => {
                e._isLeaving && (removeTransitionClass(e, p),
                addTransitionClass(e, f),
                hasExplicitCallback(b) || whenTransitionEnds(e, r, g, n))
            }
            )),
            callHook(b, [e, n])
        },
        onEnterCancelled(e) {
            T(e, !1, void 0, !0),
            callHook(_, [e])
        },
        onAppearCancelled(e) {
            T(e, !0, void 0, !0),
            callHook(O, [e])
        },
        onLeaveCancelled(e) {
            A(e),
            callHook(E, [e])
        }
    })
}
function normalizeDuration(e) {
    if (null == e)
        return null;
    if (isObject$1(e))
        return [NumberOf(e.enter), NumberOf(e.leave)];
    {
        const t = NumberOf(e);
        return [t, t]
    }
}
function NumberOf(e) {
    return toNumber(e)
}
function addTransitionClass(e, t) {
    t.split(/\s+/).forEach((t => t && e.classList.add(t))),
    (e[vtcKey] || (e[vtcKey] = new Set)).add(t)
}
function removeTransitionClass(e, t) {
    t.split(/\s+/).forEach((t => t && e.classList.remove(t)));
    const n = e[vtcKey];
    n && (n.delete(t),
    n.size || (e[vtcKey] = void 0))
}
function nextFrame(e) {
    requestAnimationFrame(( () => {
        requestAnimationFrame(e)
    }
    ))
}
let endId = 0;
function whenTransitionEnds(e, t, n, r) {
    const o = e._endId = ++endId
      , i = () => {
        o === e._endId && r()
    }
    ;
    if (null != n)
        return setTimeout(i, n);
    const {type: a, timeout: s, propCount: c} = getTransitionInfo(e, t);
    if (!a)
        return r();
    const l = a + "end";
    let u = 0;
    const p = () => {
        e.removeEventListener(l, d),
        i()
    }
      , d = t => {
        t.target === e && ++u >= c && p()
    }
    ;
    setTimeout(( () => {
        u < c && p()
    }
    ), s + 1),
    e.addEventListener(l, d)
}
function getTransitionInfo(e, t) {
    const n = window.getComputedStyle(e)
      , r = e => (n[e] || "").split(", ")
      , o = r("".concat(TRANSITION, "Delay"))
      , i = r("".concat(TRANSITION, "Duration"))
      , a = getTimeout(o, i)
      , s = r("".concat(ANIMATION, "Delay"))
      , c = r("".concat(ANIMATION, "Duration"))
      , l = getTimeout(s, c);
    let u = null
      , p = 0
      , d = 0;
    t === TRANSITION ? a > 0 && (u = TRANSITION,
    p = a,
    d = i.length) : t === ANIMATION ? l > 0 && (u = ANIMATION,
    p = l,
    d = c.length) : (p = Math.max(a, l),
    u = p > 0 ? a > l ? TRANSITION : ANIMATION : null,
    d = u ? u === TRANSITION ? i.length : c.length : 0);
    return {
        type: u,
        timeout: p,
        propCount: d,
        hasTransform: u === TRANSITION && /\b(transform|all)(,|$)/.test(r("".concat(TRANSITION, "Property")).toString())
    }
}
function getTimeout(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map(( (t, n) => toMs(t) + toMs(e[n]))))
}
function toMs(e) {
    return "auto" === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(",", "."))
}
function forceReflow() {
    return document.body.offsetHeight
}
function patchClass(e, t, n) {
    const r = e[vtcKey];
    r && (t = (t ? [t, ...r] : [...r]).join(" ")),
    null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const vShowOriginalDisplay = Symbol("_vod")
  , vShowHidden = Symbol("_vsh")
  , vShow = {
    beforeMount(e, {value: t}, {transition: n}) {
        e[vShowOriginalDisplay] = "none" === e.style.display ? "" : e.style.display,
        n && t ? n.beforeEnter(e) : setDisplay(e, t)
    },
    mounted(e, {value: t}, {transition: n}) {
        n && t && n.enter(e)
    },
    updated(e, {value: t, oldValue: n}, {transition: r}) {
        !t != !n && (r ? t ? (r.beforeEnter(e),
        setDisplay(e, !0),
        r.enter(e)) : r.leave(e, ( () => {
            setDisplay(e, !1)
        }
        )) : setDisplay(e, t))
    },
    beforeUnmount(e, {value: t}) {
        setDisplay(e, t)
    }
};
function setDisplay(e, t) {
    e.style.display = t ? e[vShowOriginalDisplay] : "none",
    e[vShowHidden] = !t
}
const CSS_VAR_TEXT = Symbol("")
  , displayRE = /(^|;)\s*display\s*:/;
function patchStyle(e, t, n) {
    const r = e.style
      , o = isString$2(n);
    let i = !1;
    if (n && !o) {
        if (t)
            if (isString$2(t))
                for (const e of t.split(";")) {
                    const t = e.slice(0, e.indexOf(":")).trim();
                    null == n[t] && setStyle(r, t, "")
                }
            else
                for (const e in t)
                    null == n[e] && setStyle(r, e, "");
        for (const e in n)
            "display" === e && (i = !0),
            setStyle(r, e, n[e])
    } else if (o) {
        if (t !== n) {
            const e = r[CSS_VAR_TEXT];
            e && (n += ";" + e),
            r.cssText = n,
            i = displayRE.test(n)
        }
    } else
        t && e.removeAttribute("style");
    vShowOriginalDisplay in e && (e[vShowOriginalDisplay] = i ? r.display : "",
    e[vShowHidden] && (r.display = "none"))
}
const importantRE = /\s*!important$/;
function setStyle(e, t, n) {
    if (isArray$2(n))
        n.forEach((n => setStyle(e, t, n)));
    else if (null == n && (n = ""),
    t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const r = autoPrefix(e, t);
        importantRE.test(n) ? e.setProperty(hyphenate(r), n.replace(importantRE, ""), "important") : e[r] = n
    }
}
const prefixes = ["Webkit", "Moz", "ms"]
  , prefixCache = {};
function autoPrefix(e, t) {
    const n = prefixCache[t];
    if (n)
        return n;
    let r = camelize(t);
    if ("filter" !== r && r in e)
        return prefixCache[t] = r;
    r = capitalize(r);
    for (let o = 0; o < prefixes.length; o++) {
        const n = prefixes[o] + r;
        if (n in e)
            return prefixCache[t] = n
    }
    return t
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(e, t, n, r, o, i=isSpecialBooleanAttr(t)) {
    r && t.startsWith("xlink:") ? null == n ? e.removeAttributeNS(xlinkNS, t.slice(6, t.length)) : e.setAttributeNS(xlinkNS, t, n) : null == n || i && !includeBooleanAttr(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : isSymbol(n) ? String(n) : n)
}
function patchDOMProp(e, t, n, r, o) {
    if ("innerHTML" === t || "textContent" === t)
        return void (null != n && (e[t] = "innerHTML" === t ? unsafeToTrustedHTML(n) : n));
    const i = e.tagName;
    if ("value" === t && "PROGRESS" !== i && !i.includes("-")) {
        const r = "OPTION" === i ? e.getAttribute("value") || "" : e.value
          , o = null == n ? "checkbox" === e.type ? "on" : "" : String(n);
        return r === o && "_value"in e || (e.value = o),
        null == n && e.removeAttribute(t),
        void (e._value = n)
    }
    let a = !1;
    if ("" === n || null == n) {
        const r = typeof e[t];
        "boolean" === r ? n = includeBooleanAttr(n) : null == n && "string" === r ? (n = "",
        a = !0) : "number" === r && (n = 0,
        a = !0)
    }
    try {
        e[t] = n
    } catch (e2) {}
    a && e.removeAttribute(o || t)
}
function addEventListener$2(e, t, n, r) {
    e.addEventListener(t, n, r)
}
function removeEventListener$1(e, t, n, r) {
    e.removeEventListener(t, n, r)
}
const veiKey = Symbol("_vei");
function patchEvent(e, t, n, r, o=null) {
    const i = e[veiKey] || (e[veiKey] = {})
      , a = i[t];
    if (r && a)
        a.value = r;
    else {
        const [n,s] = parseName(t);
        if (r) {
            addEventListener$2(e, n, i[t] = createInvoker(r, o), s)
        } else
            a && (removeEventListener$1(e, n, a, s),
            i[t] = void 0)
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(e) {
    let t;
    if (optionsModifierRE.test(e)) {
        let n;
        for (t = {}; n = e.match(optionsModifierRE); )
            e = e.slice(0, e.length - n[0].length),
            t[n[0].toLowerCase()] = !0
    }
    return [":" === e[2] ? e.slice(3) : hyphenate(e.slice(2)), t]
}
let cachedNow = 0;
const p$4 = Promise.resolve()
  , getNow = () => cachedNow || (p$4.then(( () => cachedNow = 0)),
cachedNow = Date.now());
function createInvoker(e, t) {
    const n = e => {
        if (e._vts) {
            if (e._vts <= n.attached)
                return
        } else
            e._vts = Date.now();
        callWithAsyncErrorHandling(patchStopImmediatePropagation(e, n.value), t, 5, [e])
    }
    ;
    return n.value = e,
    n.attached = getNow(),
    n
}
function patchStopImmediatePropagation(e, t) {
    if (isArray$2(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e),
            e._stopped = !0
        }
        ,
        t.map((e => t => !t._stopped && e && e(t)))
    }
    return t
}
const isNativeOn = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123
  , patchProp = (e, t, n, r, o, i) => {
    const a = "svg" === o;
    "class" === t ? patchClass(e, r, a) : "style" === t ? patchStyle(e, n, r) : isOn(t) ? isModelListener(t) || patchEvent(e, t, n, r, i) : ("." === t[0] ? (t = t.slice(1),
    1) : "^" === t[0] ? (t = t.slice(1),
    0) : shouldSetAsProp(e, t, r, a)) ? (patchDOMProp(e, t, r),
    e.tagName.includes("-") || "value" !== t && "checked" !== t && "selected" !== t || patchAttr(e, t, r, a, i, "value" !== t)) : !e._isVueCE || !/[A-Z]/.test(t) && isString$2(r) ? ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r),
    patchAttr(e, t, r, a)) : patchDOMProp(e, camelize(t), r, i, t)
}
;
function shouldSetAsProp(e, t, n, r) {
    if (r)
        return "innerHTML" === t || "textContent" === t || !!(t in e && isNativeOn(t) && isFunction$3(n));
    if ("spellcheck" === t || "draggable" === t || "translate" === t)
        return !1;
    if ("form" === t)
        return !1;
    if ("list" === t && "INPUT" === e.tagName)
        return !1;
    if ("type" === t && "TEXTAREA" === e.tagName)
        return !1;
    if ("width" === t || "height" === t) {
        const t = e.tagName;
        if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t)
            return !1
    }
    return (!isNativeOn(t) || !isString$2(n)) && t in e
}
const getModelAssigner = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return isArray$2(t) ? e => invokeArrayFns(t, e) : t
}
;
function onCompositionStart(e) {
    e.target.composing = !0
}
function onCompositionEnd(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const assignKey = Symbol("_assign")
  , vModelText = {
    created(e, {modifiers: {lazy: t, trim: n, number: r}}, o) {
        e[assignKey] = getModelAssigner(o);
        const i = r || o.props && "number" === o.props.type;
        addEventListener$2(e, t ? "change" : "input", (t => {
            if (t.target.composing)
                return;
            let r = e.value;
            n && (r = r.trim()),
            i && (r = looseToNumber(r)),
            e[assignKey](r)
        }
        )),
        n && addEventListener$2(e, "change", ( () => {
            e.value = e.value.trim()
        }
        )),
        t || (addEventListener$2(e, "compositionstart", onCompositionStart),
        addEventListener$2(e, "compositionend", onCompositionEnd),
        addEventListener$2(e, "change", onCompositionEnd))
    },
    mounted(e, {value: t}) {
        e.value = null == t ? "" : t
    },
    beforeUpdate(e, {value: t, oldValue: n, modifiers: {lazy: r, trim: o, number: i}}, a) {
        if (e[assignKey] = getModelAssigner(a),
        e.composing)
            return;
        const s = null == t ? "" : t;
        if ((!i && "number" !== e.type || /^0\d/.test(e.value) ? e.value : looseToNumber(e.value)) !== s) {
            if (document.activeElement === e && "range" !== e.type) {
                if (r && t === n)
                    return;
                if (o && e.value.trim() === s)
                    return
            }
            e.value = s
        }
    }
}
  , vModelRadio = {
    created(e, {value: t}, n) {
        e.checked = looseEqual(t, n.props.value),
        e[assignKey] = getModelAssigner(n),
        addEventListener$2(e, "change", ( () => {
            e[assignKey](getValue(e))
        }
        ))
    },
    beforeUpdate(e, {value: t, oldValue: n}, r) {
        e[assignKey] = getModelAssigner(r),
        t !== n && (e.checked = looseEqual(t, r.props.value))
    }
};
function getValue(e) {
    return "_value"in e ? e._value : e.value
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"]
  , modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button"in e && 0 !== e.button,
    middle: e => "button"in e && 1 !== e.button,
    right: e => "button"in e && 2 !== e.button,
    exact: (e, t) => systemModifiers.some((n => e["".concat(n, "Key")] && !t.includes(n)))
}
  , withModifiers = (e, t) => {
    const n = e._withMods || (e._withMods = {})
      , r = t.join(".");
    return n[r] || (n[r] = (n, ...r) => {
        for (let e = 0; e < t.length; e++) {
            const r = modifierGuards[t[e]];
            if (r && r(n, t))
                return
        }
        return e(n, ...r)
    }
    )
}
  , keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , withKeys = (e, t) => {
    const n = e._withKeys || (e._withKeys = {})
      , r = t.join(".");
    return n[r] || (n[r] = n => {
        if (!("key"in n))
            return;
        const r = hyphenate(n.key);
        return t.some((e => e === r || keyNames[e] === r)) ? e(n) : void 0
    }
    )
}
  , rendererOptions = extend$2({
    patchProp: patchProp
}, nodeOps);
let renderer, enabledHydration = !1;
function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions))
}
function ensureHydrationRenderer() {
    return renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions),
    enabledHydration = !0,
    renderer
}
const render = (...e) => {
    ensureRenderer().render(...e)
}
  , createApp$1 = (...e) => {
    const t = ensureRenderer().createApp(...e)
      , {mount: n} = t;
    return t.mount = e => {
        const r = normalizeContainer(e);
        if (!r)
            return;
        const o = t._component;
        isFunction$3(o) || o.render || o.template || (o.template = r.innerHTML),
        1 === r.nodeType && (r.textContent = "");
        const i = n(r, !1, resolveRootNamespace(r));
        return r instanceof Element && (r.removeAttribute("v-cloak"),
        r.setAttribute("data-v-app", "")),
        i
    }
    ,
    t
}
  , createSSRApp = (...e) => {
    const t = ensureHydrationRenderer().createApp(...e)
      , {mount: n} = t;
    return t.mount = e => {
        const t = normalizeContainer(e);
        if (t)
            return n(t, !0, resolveRootNamespace(t))
    }
    ,
    t
}
;
function resolveRootNamespace(e) {
    return e instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && e instanceof MathMLElement ? "mathml" : void 0
}
function normalizeContainer(e) {
    if (isString$2(e)) {
        return document.querySelector(e)
    }
    return e
}
/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = "undefined" != typeof document;
function isRouteComponent(e) {
    return "object" == typeof e || "displayName"in e || "props"in e || "__vccOpts"in e
}
function isESModule(e) {
    return e.__esModule || "Module" === e[Symbol.toStringTag] || e.default && isRouteComponent(e.default)
}
const assign$1 = Object.assign;
function applyToParams(e, t) {
    const n = {};
    for (const r in t) {
        const o = t[r];
        n[r] = isArray$1(o) ? o.map(e) : e(o)
    }
    return n
}
const noop$2 = () => {}
  , isArray$1 = Array.isArray
  , HASH_RE = /#/g
  , AMPERSAND_RE = /&/g
  , SLASH_RE = /\//g
  , EQUAL_RE = /=/g
  , IM_RE = /\?/g
  , PLUS_RE = /\+/g
  , ENC_BRACKET_OPEN_RE = /%5B/g
  , ENC_BRACKET_CLOSE_RE = /%5D/g
  , ENC_CARET_RE = /%5E/g
  , ENC_BACKTICK_RE = /%60/g
  , ENC_CURLY_OPEN_RE = /%7B/g
  , ENC_PIPE_RE = /%7C/g
  , ENC_CURLY_CLOSE_RE = /%7D/g
  , ENC_SPACE_RE = /%20/g;
function commonEncode(e) {
    return encodeURI("" + e).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]")
}
function encodeHash(e) {
    return commonEncode(e).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryValue(e) {
    return commonEncode(e).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryKey(e) {
    return encodeQueryValue(e).replace(EQUAL_RE, "%3D")
}
function encodePath(e) {
    return commonEncode(e).replace(HASH_RE, "%23").replace(IM_RE, "%3F")
}
function encodeParam(e) {
    return null == e ? "" : encodePath(e).replace(SLASH_RE, "%2F")
}
function decode(e) {
    try {
        return decodeURIComponent("" + e)
    } catch (t) {}
    return "" + e
}
const TRAILING_SLASH_RE = /\/$/
  , removeTrailingSlash = e => e.replace(TRAILING_SLASH_RE, "");
function parseURL(e, t, n="/") {
    let r, o = {}, i = "", a = "";
    const s = t.indexOf("#");
    let c = t.indexOf("?");
    return s < c && s >= 0 && (c = -1),
    c > -1 && (r = t.slice(0, c),
    i = t.slice(c + 1, s > -1 ? s : t.length),
    o = e(i)),
    s > -1 && (r = r || t.slice(0, s),
    a = t.slice(s, t.length)),
    r = resolveRelativePath(null != r ? r : t, n),
    {
        fullPath: r + (i && "?") + i + a,
        path: r,
        query: o,
        hash: decode(a)
    }
}
function stringifyURL(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}
function stripBase(e, t) {
    return t && e.toLowerCase().startsWith(t.toLowerCase()) ? e.slice(t.length) || "/" : e
}
function isSameRouteLocation(e, t, n) {
    const r = t.matched.length - 1
      , o = n.matched.length - 1;
    return r > -1 && r === o && isSameRouteRecord(t.matched[r], n.matched[o]) && isSameRouteLocationParams(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}
function isSameRouteRecord(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function isSameRouteLocationParams(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (!isSameRouteLocationParamsValue(e[n], t[n]))
            return !1;
    return !0
}
function isSameRouteLocationParamsValue(e, t) {
    return isArray$1(e) ? isEquivalentArray(e, t) : isArray$1(t) ? isEquivalentArray(t, e) : e === t
}
function isEquivalentArray(e, t) {
    return isArray$1(t) ? e.length === t.length && e.every(( (e, n) => e === t[n])) : 1 === e.length && e[0] === t
}
function resolveRelativePath(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const n = t.split("/")
      , r = e.split("/")
      , o = r[r.length - 1];
    ".." !== o && "." !== o || r.push("");
    let i, a, s = n.length - 1;
    for (i = 0; i < r.length; i++)
        if (a = r[i],
        "." !== a) {
            if (".." !== a)
                break;
            s > 1 && s--
        }
    return n.slice(0, s).join("/") + "/" + r.slice(i).join("/")
}
const START_LOCATION_NORMALIZED = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var NavigationType, NavigationType2, NavigationDirection, NavigationDirection2;
function normalizeBase(e) {
    if (!e)
        if (isBrowser) {
            const t = document.querySelector("base");
            e = (e = t && t.getAttribute("href") || "/").replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return "/" !== e[0] && "#" !== e[0] && (e = "/" + e),
    removeTrailingSlash(e)
}
NavigationType2 = NavigationType || (NavigationType = {}),
NavigationType2.pop = "pop",
NavigationType2.push = "push",
NavigationDirection2 = NavigationDirection || (NavigationDirection = {}),
NavigationDirection2.back = "back",
NavigationDirection2.forward = "forward",
NavigationDirection2.unknown = "";
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(e, t) {
    return e.replace(BEFORE_HASH_RE, "#") + t
}
function getElementPosition(e, t) {
    const n = document.documentElement.getBoundingClientRect()
      , r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const computeScrollPosition = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function scrollToPosition(e) {
    let t;
    if ("el"in e) {
        const n = e.el
          , r = "string" == typeof n && n.startsWith("#")
          , o = "string" == typeof n ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!o)
            return;
        t = getElementPosition(o, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.scrollX, null != t.top ? t.top : window.scrollY)
}
function getScrollKey(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const scrollPositions = new Map;
function saveScrollPosition(e, t) {
    scrollPositions.set(e, t)
}
function getSavedScrollPosition(e) {
    const t = scrollPositions.get(e);
    return scrollPositions.delete(e),
    t
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(e, t) {
    const {pathname: n, search: r, hash: o} = t
      , i = e.indexOf("#");
    if (i > -1) {
        let t = o.includes(e.slice(i)) ? e.slice(i).length : 1
          , n = o.slice(t);
        return "/" !== n[0] && (n = "/" + n),
        stripBase(n, "")
    }
    return stripBase(n, e) + r + o
}
function useHistoryListeners(e, t, n, r) {
    let o = []
      , i = []
      , a = null;
    const s = ({state: i}) => {
        const s = createCurrentLocation(e, location)
          , c = n.value
          , l = t.value;
        let u = 0;
        if (i) {
            if (n.value = s,
            t.value = i,
            a && a === c)
                return void (a = null);
            u = l ? i.position - l.position : 0
        } else
            r(s);
        o.forEach((e => {
            e(n.value, c, {
                delta: u,
                type: NavigationType.pop,
                direction: u ? u > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
            })
        }
        ))
    }
    ;
    function c() {
        const {history: e} = window;
        e.state && e.replaceState(assign$1({}, e.state, {
            scroll: computeScrollPosition()
        }), "")
    }
    return window.addEventListener("popstate", s),
    window.addEventListener("beforeunload", c, {
        passive: !0
    }),
    {
        pauseListeners: function() {
            a = n.value
        },
        listen: function(e) {
            o.push(e);
            const t = () => {
                const t = o.indexOf(e);
                t > -1 && o.splice(t, 1)
            }
            ;
            return i.push(t),
            t
        },
        destroy: function() {
            for (const e of i)
                e();
            i = [],
            window.removeEventListener("popstate", s),
            window.removeEventListener("beforeunload", c)
        }
    }
}
function buildState(e, t, n, r=!1, o=!1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: o ? computeScrollPosition() : null
    }
}
function useHistoryStateNavigation(e) {
    const {history: t, location: n} = window
      , r = {
        value: createCurrentLocation(e, n)
    }
      , o = {
        value: t.state
    };
    function i(r, i, a) {
        const s = e.indexOf("#")
          , c = s > -1 ? (n.host && document.querySelector("base") ? e : e.slice(s)) + r : createBaseLocation() + e + r;
        try {
            t[a ? "replaceState" : "pushState"](i, "", c),
            o.value = i
        } catch (l) {
            console.error(l),
            n[a ? "replace" : "assign"](c)
        }
    }
    return o.value || i(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0),
    {
        location: r,
        state: o,
        push: function(e, n) {
            const a = assign$1({}, o.value, t.state, {
                forward: e,
                scroll: computeScrollPosition()
            });
            i(a.current, a, !0),
            i(e, assign$1({}, buildState(r.value, e, null), {
                position: a.position + 1
            }, n), !1),
            r.value = e
        },
        replace: function(e, n) {
            i(e, assign$1({}, t.state, buildState(o.value.back, e, o.value.forward, !0), n, {
                position: o.value.position
            }), !0),
            r.value = e
        }
    }
}
function createWebHistory(e) {
    const t = useHistoryStateNavigation(e = normalizeBase(e))
      , n = useHistoryListeners(e, t.state, t.location, t.replace);
    const r = assign$1({
        location: "",
        base: e,
        go: function(e, t=!0) {
            t || n.pauseListeners(),
            history.go(e)
        },
        createHref: createHref.bind(null, e)
    }, t, n);
    return Object.defineProperty(r, "location", {
        enumerable: !0,
        get: () => t.location.value
    }),
    Object.defineProperty(r, "state", {
        enumerable: !0,
        get: () => t.state.value
    }),
    r
}
function isRouteLocation(e) {
    return "string" == typeof e || e && "object" == typeof e
}
function isRouteName(e) {
    return "string" == typeof e || "symbol" == typeof e
}
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType, NavigationFailureType2;
function createRouterError(e, t) {
    return assign$1(new Error, {
        type: e,
        [NavigationFailureSymbol]: !0
    }, t)
}
function isNavigationFailure(e, t) {
    return e instanceof Error && NavigationFailureSymbol in e && (null == t || !!(e.type & t))
}
NavigationFailureType2 = NavigationFailureType || (NavigationFailureType = {}),
NavigationFailureType2[NavigationFailureType2.aborted = 4] = "aborted",
NavigationFailureType2[NavigationFailureType2.cancelled = 8] = "cancelled",
NavigationFailureType2[NavigationFailureType2.duplicated = 16] = "duplicated";
const BASE_PARAM_PATTERN = "[^/]+?"
  , BASE_PATH_PARSER_OPTIONS = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(e, t) {
    const n = assign$1({}, BASE_PATH_PARSER_OPTIONS, t)
      , r = [];
    let o = n.start ? "^" : "";
    const i = [];
    for (const c of e) {
        const e = c.length ? [] : [90];
        n.strict && !c.length && (o += "/");
        for (let t = 0; t < c.length; t++) {
            const r = c[t];
            let a = 40 + (n.sensitive ? .25 : 0);
            if (0 === r.type)
                t || (o += "/"),
                o += r.value.replace(REGEX_CHARS_RE, "\\$&"),
                a += 40;
            else if (1 === r.type) {
                const {value: e, repeatable: n, optional: l, regexp: u} = r;
                i.push({
                    name: e,
                    repeatable: n,
                    optional: l
                });
                const p = u || BASE_PARAM_PATTERN;
                if (p !== BASE_PARAM_PATTERN) {
                    a += 10;
                    try {
                        new RegExp("(".concat(p, ")"))
                    } catch (s) {
                        throw new Error('Invalid custom RegExp for param "'.concat(e, '" (').concat(p, "): ") + s.message)
                    }
                }
                let d = n ? "((?:".concat(p, ")(?:/(?:").concat(p, "))*)") : "(".concat(p, ")");
                t || (d = l && c.length < 2 ? "(?:/".concat(d, ")") : "/" + d),
                l && (d += "?"),
                o += d,
                a += 20,
                l && (a += -8),
                n && (a += -20),
                ".*" === p && (a += -50)
            }
            e.push(a)
        }
        r.push(e)
    }
    if (n.strict && n.end) {
        const e = r.length - 1;
        r[e][r[e].length - 1] += .7000000000000001
    }
    n.strict || (o += "/?"),
    n.end ? o += "$" : n.strict && (o += "(?:/|$)");
    const a = new RegExp(o,n.sensitive ? "" : "i");
    return {
        re: a,
        score: r,
        keys: i,
        parse: function(e) {
            const t = e.match(a)
              , n = {};
            if (!t)
                return null;
            for (let r = 1; r < t.length; r++) {
                const e = t[r] || ""
                  , o = i[r - 1];
                n[o.name] = e && o.repeatable ? e.split("/") : e
            }
            return n
        },
        stringify: function(t) {
            let n = ""
              , r = !1;
            for (const o of e) {
                r && n.endsWith("/") || (n += "/"),
                r = !1;
                for (const e of o)
                    if (0 === e.type)
                        n += e.value;
                    else if (1 === e.type) {
                        const {value: i, repeatable: a, optional: s} = e
                          , c = i in t ? t[i] : "";
                        if (isArray$1(c) && !a)
                            throw new Error('Provided param "'.concat(i, '" is an array but it is not repeatable (* or + modifiers)'));
                        const l = isArray$1(c) ? c.join("/") : c;
                        if (!l) {
                            if (!s)
                                throw new Error('Missing required param "'.concat(i, '"'));
                            o.length < 2 && (n.endsWith("/") ? n = n.slice(0, -1) : r = !0)
                        }
                        n += l
                    }
            }
            return n || "/"
        }
    }
}
function compareScoreArray(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
        const r = t[n] - e[n];
        if (r)
            return r;
        n++
    }
    return e.length < t.length ? 1 === e.length && 80 === e[0] ? -1 : 1 : e.length > t.length ? 1 === t.length && 80 === t[0] ? 1 : -1 : 0
}
function comparePathParserScore(e, t) {
    let n = 0;
    const r = e.score
      , o = t.score;
    for (; n < r.length && n < o.length; ) {
        const e = compareScoreArray(r[n], o[n]);
        if (e)
            return e;
        n++
    }
    if (1 === Math.abs(o.length - r.length)) {
        if (isLastScoreNegative(r))
            return 1;
        if (isLastScoreNegative(o))
            return -1
    }
    return o.length - r.length
}
function isLastScoreNegative(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const ROOT_TOKEN = {
    type: 0,
    value: ""
}
  , VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(e) {
    if (!e)
        return [[]];
    if ("/" === e)
        return [[ROOT_TOKEN]];
    if (!e.startsWith("/"))
        throw new Error('Invalid path "'.concat(e, '"'));
    function t(e) {
        throw new Error("ERR (".concat(n, ')/"').concat(l, '": ').concat(e))
    }
    let n = 0
      , r = n;
    const o = [];
    let i;
    function a() {
        i && o.push(i),
        i = []
    }
    let s, c = 0, l = "", u = "";
    function p() {
        l && (0 === n ? i.push({
            type: 0,
            value: l
        }) : 1 === n || 2 === n || 3 === n ? (i.length > 1 && ("*" === s || "+" === s) && t("A repeatable param (".concat(l, ") must be alone in its segment. eg: '/:ids+.")),
        i.push({
            type: 1,
            value: l,
            regexp: u,
            repeatable: "*" === s || "+" === s,
            optional: "*" === s || "?" === s
        })) : t("Invalid state to consume buffer"),
        l = "")
    }
    function d() {
        l += s
    }
    for (; c < e.length; )
        if (s = e[c++],
        "\\" !== s || 2 === n)
            switch (n) {
            case 0:
                "/" === s ? (l && p(),
                a()) : ":" === s ? (p(),
                n = 1) : d();
                break;
            case 4:
                d(),
                n = r;
                break;
            case 1:
                "(" === s ? n = 2 : VALID_PARAM_RE.test(s) ? d() : (p(),
                n = 0,
                "*" !== s && "?" !== s && "+" !== s && c--);
                break;
            case 2:
                ")" === s ? "\\" == u[u.length - 1] ? u = u.slice(0, -1) + s : n = 3 : u += s;
                break;
            case 3:
                p(),
                n = 0,
                "*" !== s && "?" !== s && "+" !== s && c--,
                u = "";
                break;
            default:
                t("Unknown state")
            }
        else
            r = n,
            n = 4;
    return 2 === n && t('Unfinished custom RegExp for param "'.concat(l, '"')),
    p(),
    a(),
    o
}
function createRouteRecordMatcher(e, t, n) {
    const r = tokensToParser(tokenizePath(e.path), n)
      , o = assign$1(r, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o),
    o
}
function createRouterMatcher(e, t) {
    const n = []
      , r = new Map;
    function o(e, n, r) {
        const s = !r
          , c = normalizeRouteRecord(e);
        c.aliasOf = r && r.record;
        const l = mergeOptions(t, e)
          , u = [c];
        if ("alias"in e) {
            const t = "string" == typeof e.alias ? [e.alias] : e.alias;
            for (const e of t)
                u.push(normalizeRouteRecord(assign$1({}, c, {
                    components: r ? r.record.components : c.components,
                    path: e,
                    aliasOf: r ? r.record : c
                })))
        }
        let p, d;
        for (const t of u) {
            const {path: u} = t;
            if (n && "/" !== u[0]) {
                const e = n.record.path
                  , r = "/" === e[e.length - 1] ? "" : "/";
                t.path = n.record.path + (u && r + u)
            }
            if (p = createRouteRecordMatcher(t, n, l),
            r ? r.alias.push(p) : (d = d || p,
            d !== p && d.alias.push(p),
            s && e.name && !isAliasRecord(p) && i(e.name)),
            isMatchable(p) && a(p),
            c.children) {
                const e = c.children;
                for (let t = 0; t < e.length; t++)
                    o(e[t], p, r && r.children[t])
            }
            r = r || p
        }
        return d ? () => {
            i(d)
        }
        : noop$2
    }
    function i(e) {
        if (isRouteName(e)) {
            const t = r.get(e);
            t && (r.delete(e),
            n.splice(n.indexOf(t), 1),
            t.children.forEach(i),
            t.alias.forEach(i))
        } else {
            const t = n.indexOf(e);
            t > -1 && (n.splice(t, 1),
            e.record.name && r.delete(e.record.name),
            e.children.forEach(i),
            e.alias.forEach(i))
        }
    }
    function a(e) {
        const t = findInsertionIndex(e, n);
        n.splice(t, 0, e),
        e.record.name && !isAliasRecord(e) && r.set(e.record.name, e)
    }
    return t = mergeOptions({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t),
    e.forEach((e => o(e))),
    {
        addRoute: o,
        resolve: function(e, t) {
            let o, i, a, s = {};
            if ("name"in e && e.name) {
                if (o = r.get(e.name),
                !o)
                    throw createRouterError(1, {
                        location: e
                    });
                a = o.record.name,
                s = assign$1(paramsFromLocation(t.params, o.keys.filter((e => !e.optional)).concat(o.parent ? o.parent.keys.filter((e => e.optional)) : []).map((e => e.name))), e.params && paramsFromLocation(e.params, o.keys.map((e => e.name)))),
                i = o.stringify(s)
            } else if (null != e.path)
                i = e.path,
                o = n.find((e => e.re.test(i))),
                o && (s = o.parse(i),
                a = o.record.name);
            else {
                if (o = t.name ? r.get(t.name) : n.find((e => e.re.test(t.path))),
                !o)
                    throw createRouterError(1, {
                        location: e,
                        currentLocation: t
                    });
                a = o.record.name,
                s = assign$1({}, t.params, e.params),
                i = o.stringify(s)
            }
            const c = [];
            let l = o;
            for (; l; )
                c.unshift(l.record),
                l = l.parent;
            return {
                name: a,
                path: i,
                params: s,
                matched: c,
                meta: mergeMetaFields(c)
            }
        },
        removeRoute: i,
        clearRoutes: function() {
            n.length = 0,
            r.clear()
        },
        getRoutes: function() {
            return n
        },
        getRecordMatcher: function(e) {
            return r.get(e)
        }
    }
}
function paramsFromLocation(e, t) {
    const n = {};
    for (const r of t)
        r in e && (n[r] = e[r]);
    return n
}
function normalizeRouteRecord(e) {
    const t = {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: e.aliasOf,
        beforeEnter: e.beforeEnter,
        props: normalizeRecordProps(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    };
    return Object.defineProperty(t, "mods", {
        value: {}
    }),
    t
}
function normalizeRecordProps(e) {
    const t = {}
      , n = e.props || !1;
    if ("component"in e)
        t.default = n;
    else
        for (const r in e.components)
            t[r] = "object" == typeof n ? n[r] : n;
    return t
}
function isAliasRecord(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function mergeMetaFields(e) {
    return e.reduce(( (e, t) => assign$1(e, t.meta)), {})
}
function mergeOptions(e, t) {
    const n = {};
    for (const r in e)
        n[r] = r in t ? t[r] : e[r];
    return n
}
function findInsertionIndex(e, t) {
    let n = 0
      , r = t.length;
    for (; n !== r; ) {
        const o = n + r >> 1;
        comparePathParserScore(e, t[o]) < 0 ? r = o : n = o + 1
    }
    const o = getInsertionAncestor(e);
    return o && (r = t.lastIndexOf(o, r - 1)),
    r
}
function getInsertionAncestor(e) {
    let t = e;
    for (; t = t.parent; )
        if (isMatchable(t) && 0 === comparePathParserScore(e, t))
            return t
}
function isMatchable({record: e}) {
    return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}
function parseQuery$1(e) {
    const t = {};
    if ("" === e || "?" === e)
        return t;
    const n = ("?" === e[0] ? e.slice(1) : e).split("&");
    for (let r = 0; r < n.length; ++r) {
        const e = n[r].replace(PLUS_RE, " ")
          , o = e.indexOf("=")
          , i = decode(o < 0 ? e : e.slice(0, o))
          , a = o < 0 ? null : decode(e.slice(o + 1));
        if (i in t) {
            let e = t[i];
            isArray$1(e) || (e = t[i] = [e]),
            e.push(a)
        } else
            t[i] = a
    }
    return t
}
function stringifyQuery(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = encodeQueryKey(n),
        null == r) {
            void 0 !== r && (t += (t.length ? "&" : "") + n);
            continue
        }
        (isArray$1(r) ? r.map((e => e && encodeQueryValue(e))) : [r && encodeQueryValue(r)]).forEach((e => {
            void 0 !== e && (t += (t.length ? "&" : "") + n,
            null != e && (t += "=" + e))
        }
        ))
    }
    return t
}
function normalizeQuery(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        void 0 !== r && (t[n] = isArray$1(r) ? r.map((e => null == e ? null : "" + e)) : null == r ? r : "" + r)
    }
    return t
}
const matchedRouteKey = Symbol("")
  , viewDepthKey = Symbol("")
  , routerKey = Symbol("")
  , routeLocationKey = Symbol("")
  , routerViewLocationKey = Symbol("");
function useCallbacks() {
    let e = [];
    return {
        add: function(t) {
            return e.push(t),
            () => {
                const n = e.indexOf(t);
                n > -1 && e.splice(n, 1)
            }
        },
        list: () => e.slice(),
        reset: function() {
            e = []
        }
    }
}
function registerGuard(e, t, n) {
    const r = () => {
        e[t].delete(n)
    }
    ;
    onUnmounted(r),
    onDeactivated(r),
    onActivated(( () => {
        e[t].add(n)
    }
    )),
    e[t].add(n)
}
function onBeforeRouteLeave(e) {
    const t = inject(matchedRouteKey, {}).value;
    t && registerGuard(t, "leaveGuards", e)
}
function guardToPromiseFn(e, t, n, r, o, i=e => e()) {
    const a = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
    return () => new Promise(( (s, c) => {
        const l = e => {
            !1 === e ? c(createRouterError(4, {
                from: n,
                to: t
            })) : e instanceof Error ? c(e) : isRouteLocation(e) ? c(createRouterError(2, {
                from: t,
                to: e
            })) : (a && r.enterCallbacks[o] === a && "function" == typeof e && a.push(e),
            s())
        }
          , u = i(( () => e.call(r && r.instances[o], t, n, l)));
        let p = Promise.resolve(u);
        e.length < 3 && (p = p.then(l)),
        p.catch((e => c(e)))
    }
    ))
}
function extractComponentsGuards(e, t, n, r, o=e => e()) {
    const i = [];
    for (const a of e)
        for (const e in a.components) {
            let s = a.components[e];
            if ("beforeRouteEnter" === t || a.instances[e])
                if (isRouteComponent(s)) {
                    const c = (s.__vccOpts || s)[t];
                    c && i.push(guardToPromiseFn(c, n, r, a, e, o))
                } else {
                    let c = s();
                    i.push(( () => c.then((i => {
                        if (!i)
                            throw new Error("Couldn't resolve component \"".concat(e, '" at "').concat(a.path, '"'));
                        const s = isESModule(i) ? i.default : i;
                        a.mods[e] = i,
                        a.components[e] = s;
                        const c = (s.__vccOpts || s)[t];
                        return c && guardToPromiseFn(c, n, r, a, e, o)()
                    }
                    ))))
                }
        }
    return i
}
function useLink(e) {
    const t = inject(routerKey)
      , n = inject(routeLocationKey)
      , r = computed(( () => {
        const n = unref(e.to);
        return t.resolve(n)
    }
    ))
      , o = computed(( () => {
        const {matched: e} = r.value
          , {length: t} = e
          , o = e[t - 1]
          , i = n.matched;
        if (!o || !i.length)
            return -1;
        const a = i.findIndex(isSameRouteRecord.bind(null, o));
        if (a > -1)
            return a;
        const s = getOriginalPath(e[t - 2]);
        return t > 1 && getOriginalPath(o) === s && i[i.length - 1].path !== s ? i.findIndex(isSameRouteRecord.bind(null, e[t - 2])) : a
    }
    ))
      , i = computed(( () => o.value > -1 && includesParams(n.params, r.value.params)))
      , a = computed(( () => o.value > -1 && o.value === n.matched.length - 1 && isSameRouteLocationParams(n.params, r.value.params)));
    return {
        route: r,
        href: computed(( () => r.value.href)),
        isActive: i,
        isExactActive: a,
        navigate: function(n={}) {
            return guardEvent(n) ? t[unref(e.replace) ? "replace" : "push"](unref(e.to)).catch(noop$2) : Promise.resolve()
        }
    }
}
const RouterLinkImpl = defineComponent({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: useLink,
    setup(e, {slots: t}) {
        const n = reactive(useLink(e))
          , {options: r} = inject(routerKey)
          , o = computed(( () => ({
            [getLinkClass(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [getLinkClass(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        })));
        return () => {
            const r = t.default && t.default(n);
            return e.custom ? r : h$5("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: o.value
            }, r)
        }
    }
})
  , RouterLink = RouterLinkImpl;
function guardEvent(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey || e.defaultPrevented || void 0 !== e.button && 0 !== e.button)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
        !0
    }
}
function includesParams(e, t) {
    for (const n in t) {
        const r = t[n]
          , o = e[n];
        if ("string" == typeof r) {
            if (r !== o)
                return !1
        } else if (!isArray$1(o) || o.length !== r.length || r.some(( (e, t) => e !== o[t])))
            return !1
    }
    return !0
}
function getOriginalPath(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const getLinkClass = (e, t, n) => null != e ? e : null != t ? t : n
  , RouterViewImpl = defineComponent({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: n}) {
        const r = inject(routerViewLocationKey)
          , o = computed(( () => e.route || r.value))
          , i = inject(viewDepthKey, 0)
          , a = computed(( () => {
            let e = unref(i);
            const {matched: t} = o.value;
            let n;
            for (; (n = t[e]) && !n.components; )
                e++;
            return e
        }
        ))
          , s = computed(( () => o.value.matched[a.value]));
        provide(viewDepthKey, computed(( () => a.value + 1))),
        provide(matchedRouteKey, s),
        provide(routerViewLocationKey, o);
        const c = ref();
        return watch(( () => [c.value, s.value, e.name]), ( ([e,t,n], [r,o,i]) => {
            t && (t.instances[n] = e,
            o && o !== t && e && e === r && (t.leaveGuards.size || (t.leaveGuards = o.leaveGuards),
            t.updateGuards.size || (t.updateGuards = o.updateGuards))),
            !e || !t || o && isSameRouteRecord(t, o) && r || (t.enterCallbacks[n] || []).forEach((t => t(e)))
        }
        ), {
            flush: "post"
        }),
        () => {
            const r = o.value
              , i = e.name
              , a = s.value
              , l = a && a.components[i];
            if (!l)
                return normalizeSlot(n.default, {
                    Component: l,
                    route: r
                });
            const u = a.props[i]
              , p = u ? !0 === u ? r.params : "function" == typeof u ? u(r) : u : null
              , d = h$5(l, assign$1({}, p, t, {
                onVnodeUnmounted: e => {
                    e.component.isUnmounted && (a.instances[i] = null)
                }
                ,
                ref: c
            }));
            return normalizeSlot(n.default, {
                Component: d,
                route: r
            }) || d
        }
    }
});
function normalizeSlot(e, t) {
    if (!e)
        return null;
    const n = e(t);
    return 1 === n.length ? n[0] : n
}
const RouterView = RouterViewImpl;
function createRouter(e) {
    const t = createRouterMatcher(e.routes, e)
      , n = e.parseQuery || parseQuery$1
      , r = e.stringifyQuery || stringifyQuery
      , o = e.history
      , i = useCallbacks()
      , a = useCallbacks()
      , s = useCallbacks()
      , c = shallowRef(START_LOCATION_NORMALIZED);
    let l = START_LOCATION_NORMALIZED;
    isBrowser && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const u = applyToParams.bind(null, (e => "" + e))
      , p = applyToParams.bind(null, encodeParam)
      , d = applyToParams.bind(null, decode);
    function f(e, i) {
        if (i = assign$1({}, i || c.value),
        "string" == typeof e) {
            const r = parseURL(n, e, i.path)
              , a = t.resolve({
                path: r.path
            }, i)
              , s = o.createHref(r.fullPath);
            return assign$1(r, a, {
                params: d(a.params),
                hash: decode(r.hash),
                redirectedFrom: void 0,
                href: s
            })
        }
        let a;
        if (null != e.path)
            a = assign$1({}, e, {
                path: parseURL(n, e.path, i.path).path
            });
        else {
            const t = assign$1({}, e.params);
            for (const e in t)
                null == t[e] && delete t[e];
            a = assign$1({}, e, {
                params: p(t)
            }),
            i.params = p(i.params)
        }
        const s = t.resolve(a, i)
          , l = e.hash || "";
        s.params = u(d(s.params));
        const f = stringifyURL(r, assign$1({}, e, {
            hash: encodeHash(l),
            path: s.path
        }))
          , h = o.createHref(f);
        return assign$1({
            fullPath: f,
            hash: l,
            query: r === stringifyQuery ? normalizeQuery(e.query) : e.query || {}
        }, s, {
            redirectedFrom: void 0,
            href: h
        })
    }
    function h(e) {
        return "string" == typeof e ? parseURL(n, e, c.value.path) : assign$1({}, e)
    }
    function m(e, t) {
        if (l !== e)
            return createRouterError(8, {
                from: t,
                to: e
            })
    }
    function g(e) {
        return y(e)
    }
    function v(e) {
        const t = e.matched[e.matched.length - 1];
        if (t && t.redirect) {
            const {redirect: n} = t;
            let r = "function" == typeof n ? n(e) : n;
            return "string" == typeof r && (r = r.includes("?") || r.includes("#") ? r = h(r) : {
                path: r
            },
            r.params = {}),
            assign$1({
                query: e.query,
                hash: e.hash,
                params: null != r.path ? {} : e.params
            }, r)
        }
    }
    function y(e, t) {
        const n = l = f(e)
          , o = c.value
          , i = e.state
          , a = e.force
          , s = !0 === e.replace
          , u = v(n);
        if (u)
            return y(assign$1(h(u), {
                state: "object" == typeof u ? assign$1({}, i, u.state) : i,
                force: a,
                replace: s
            }), t || n);
        const p = n;
        let d;
        return p.redirectedFrom = t,
        !a && isSameRouteLocation(r, o, n) && (d = createRouterError(16, {
            to: p,
            from: o
        }),
        $(o, o, !0, !1)),
        (d ? Promise.resolve(d) : E(p, o)).catch((e => isNavigationFailure(e) ? isNavigationFailure(e, 2) ? e : P(e) : k(e, p, o))).then((e => {
            if (e) {
                if (isNavigationFailure(e, 2))
                    return y(assign$1({
                        replace: s
                    }, h(e.to), {
                        state: "object" == typeof e.to ? assign$1({}, i, e.to.state) : i,
                        force: a
                    }), t || p)
            } else
                e = S(p, o, !0, s, i);
            return w(p, o, e),
            e
        }
        ))
    }
    function _(e, t) {
        const n = m(e, t);
        return n ? Promise.reject(n) : Promise.resolve()
    }
    function b(e) {
        const t = N.values().next().value;
        return t && "function" == typeof t.runWithContext ? t.runWithContext(e) : e()
    }
    function E(e, t) {
        let n;
        const [r,o,s] = extractChangingRecords(e, t);
        n = extractComponentsGuards(r.reverse(), "beforeRouteLeave", e, t);
        for (const i of r)
            i.leaveGuards.forEach((r => {
                n.push(guardToPromiseFn(r, e, t))
            }
            ));
        const c = _.bind(null, e, t);
        return n.push(c),
        x(n).then(( () => {
            n = [];
            for (const r of i.list())
                n.push(guardToPromiseFn(r, e, t));
            return n.push(c),
            x(n)
        }
        )).then(( () => {
            n = extractComponentsGuards(o, "beforeRouteUpdate", e, t);
            for (const r of o)
                r.updateGuards.forEach((r => {
                    n.push(guardToPromiseFn(r, e, t))
                }
                ));
            return n.push(c),
            x(n)
        }
        )).then(( () => {
            n = [];
            for (const r of s)
                if (r.beforeEnter)
                    if (isArray$1(r.beforeEnter))
                        for (const o of r.beforeEnter)
                            n.push(guardToPromiseFn(o, e, t));
                    else
                        n.push(guardToPromiseFn(r.beforeEnter, e, t));
            return n.push(c),
            x(n)
        }
        )).then(( () => (e.matched.forEach((e => e.enterCallbacks = {})),
        n = extractComponentsGuards(s, "beforeRouteEnter", e, t, b),
        n.push(c),
        x(n)))).then(( () => {
            n = [];
            for (const r of a.list())
                n.push(guardToPromiseFn(r, e, t));
            return n.push(c),
            x(n)
        }
        )).catch((e => isNavigationFailure(e, 8) ? e : Promise.reject(e)))
    }
    function w(e, t, n) {
        s.list().forEach((r => b(( () => r(e, t, n)))))
    }
    function S(e, t, n, r, i) {
        const a = m(e, t);
        if (a)
            return a;
        const s = t === START_LOCATION_NORMALIZED
          , l = isBrowser ? history.state : {};
        n && (r || s ? o.replace(e.fullPath, assign$1({
            scroll: s && l && l.scroll
        }, i)) : o.push(e.fullPath, i)),
        c.value = e,
        $(e, t, n, s),
        P()
    }
    let O;
    let T, A = useCallbacks(), R = useCallbacks();
    function k(e, t, n) {
        P(e);
        const r = R.list();
        return r.length ? r.forEach((r => r(e, t, n))) : console.error(e),
        Promise.reject(e)
    }
    function P(e) {
        return T || (T = !e,
        O || (O = o.listen(( (e, t, n) => {
            if (!L.listening)
                return;
            const r = f(e)
              , i = v(r);
            if (i)
                return void y(assign$1(i, {
                    replace: !0
                }), r).catch(noop$2);
            l = r;
            const a = c.value;
            isBrowser && saveScrollPosition(getScrollKey(a.fullPath, n.delta), computeScrollPosition()),
            E(r, a).catch((e => isNavigationFailure(e, 12) ? e : isNavigationFailure(e, 2) ? (y(e.to, r).then((e => {
                isNavigationFailure(e, 20) && !n.delta && n.type === NavigationType.pop && o.go(-1, !1)
            }
            )).catch(noop$2),
            Promise.reject()) : (n.delta && o.go(-n.delta, !1),
            k(e, r, a)))).then((e => {
                (e = e || S(r, a, !1)) && (n.delta && !isNavigationFailure(e, 8) ? o.go(-n.delta, !1) : n.type === NavigationType.pop && isNavigationFailure(e, 20) && o.go(-1, !1)),
                w(r, a, e)
            }
            )).catch(noop$2)
        }
        ))),
        A.list().forEach(( ([t,n]) => e ? n(e) : t())),
        A.reset()),
        e
    }
    function $(t, n, r, o) {
        const {scrollBehavior: i} = e;
        if (!isBrowser || !i)
            return Promise.resolve();
        const a = !r && getSavedScrollPosition(getScrollKey(t.fullPath, 0)) || (o || !r) && history.state && history.state.scroll || null;
        return nextTick().then(( () => i(t, n, a))).then((e => e && scrollToPosition(e))).catch((e => k(e, t, n)))
    }
    const C = e => o.go(e);
    let I;
    const N = new Set
      , L = {
        currentRoute: c,
        listening: !0,
        addRoute: function(e, n) {
            let r, o;
            return isRouteName(e) ? (r = t.getRecordMatcher(e),
            o = n) : o = e,
            t.addRoute(o, r)
        },
        removeRoute: function(e) {
            const n = t.getRecordMatcher(e);
            n && t.removeRoute(n)
        },
        clearRoutes: t.clearRoutes,
        hasRoute: function(e) {
            return !!t.getRecordMatcher(e)
        },
        getRoutes: function() {
            return t.getRoutes().map((e => e.record))
        },
        resolve: f,
        options: e,
        push: g,
        replace: function(e) {
            return g(assign$1(h(e), {
                replace: !0
            }))
        },
        go: C,
        back: () => C(-1),
        forward: () => C(1),
        beforeEach: i.add,
        beforeResolve: a.add,
        afterEach: s.add,
        onError: R.add,
        isReady: function() {
            return T && c.value !== START_LOCATION_NORMALIZED ? Promise.resolve() : new Promise(( (e, t) => {
                A.add([e, t])
            }
            ))
        },
        install(e) {
            e.component("RouterLink", RouterLink),
            e.component("RouterView", RouterView),
            e.config.globalProperties.$router = this,
            Object.defineProperty(e.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => unref(c)
            }),
            isBrowser && !I && c.value === START_LOCATION_NORMALIZED && (I = !0,
            g(o.location).catch((e => {}
            )));
            const t = {};
            for (const r in START_LOCATION_NORMALIZED)
                Object.defineProperty(t, r, {
                    get: () => c.value[r],
                    enumerable: !0
                });
            e.provide(routerKey, this),
            e.provide(routeLocationKey, shallowReactive(t)),
            e.provide(routerViewLocationKey, c);
            const n = e.unmount;
            N.add(e),
            e.unmount = function() {
                N.delete(e),
                N.size < 1 && (l = START_LOCATION_NORMALIZED,
                O && O(),
                O = null,
                c.value = START_LOCATION_NORMALIZED,
                I = !1,
                T = !1),
                n()
            }
        }
    };
    function x(e) {
        return e.reduce(( (e, t) => e.then(( () => b(t)))), Promise.resolve())
    }
    return L
}
function extractChangingRecords(e, t) {
    const n = []
      , r = []
      , o = []
      , i = Math.max(t.matched.length, e.matched.length);
    for (let a = 0; a < i; a++) {
        const i = t.matched[a];
        i && (e.matched.find((e => isSameRouteRecord(e, i))) ? r.push(i) : n.push(i));
        const s = e.matched[a];
        s && (t.matched.find((e => isSameRouteRecord(e, s))) || o.push(s))
    }
    return [n, r, o]
}
function useRouter$1() {
    return inject(routerKey)
}
function useRoute$1(e) {
    return inject(routeLocationKey)
}
class Deferred {
    constructor() {
        this.promise = new Promise(( (e, t) => {
            this.resolve = e,
            this.reject = t
        }
        ))
    }
}
const hasOwnProperty$1 = ( () => {
    const {hasOwnProperty: e} = Object.prototype;
    return (t, n) => e.call(t, n)
}
)()
  , isNonNullObject = e => "object" == typeof e && null !== e
  , isFunction$2 = e => "function" == typeof e
  , delay = e => new Promise((t => setTimeout(t, e)))
  , memoize = (e, t= (...e) => e[0]) => {
    const n = new Map
      , r = new WeakMap;
    return (...o) => {
        var i;
        const a = t(...o)
          , s = isNonNullObject(a) ? r : n
          , c = null != (i = s.get(a)) ? i : e(...o);
        return s.has(a) || s.set(a, c),
        c
    }
}
  , compareVersion = (e, t) => {
    if (!e || !t)
        return Number.NaN;
    const n = e.split(".").map((e => +e))
      , r = t.split(".").map((e => +e));
    for (let o = 0; o < Math.min(n.length, r.length); o += 1) {
        if (Number.isNaN(n[o]) || Number.isNaN(r[o]))
            return Number.NaN;
        if (n[o] !== r[o])
            return n[o] - r[o]
    }
    return 0
}
  , getPlatformVersion = memoize((e => {
    var t, n;
    return null != (n = null == (t = new RegExp("(?:".concat(e, ")\\/([\\d+.]+)")).exec("undefined" == typeof navigator ? "" : navigator.userAgent)) ? void 0 : t[1]) ? n : ""
}
))
  , compareYodaVersion = e => compareVersion(getPlatformVersion("Yoda"), e)
  , compareKwaiAppVersion = e => compareVersion(getPlatformVersion("Kwai|ksNebula"), e)
  , system = ( () => {
    if ("undefined" == typeof navigator)
        return "unknown";
    const {userAgent: e, maxTouchPoints: t} = navigator;
    return /android/iu.test(e) ? "Android" : /iPhone|iPad|iPod/u.test(e) || e.includes("Mac") && t > 1 ? "iOS" : "unknown"
}
)()
  , isAndroid = "Android" === system
  , isIOS = "iOS" === system
  , isYoda = () => {
    var e;
    return "undefined" != typeof window && "function" == typeof (null == (e = window.__yodaBridge__) ? void 0 : e.invoke)
}
  , isApp = e => !!getPlatformVersion(e)
  , isKwaiApp = isApp("Kwai|ksNebula")
  , SafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;
let overflow = !1
  , _callbackId = 1
  , _instanceId = genInstanceId();
function genInstanceId() {
    const e = "".concat(SafeInteger)
      , t = Number(e.slice(0, 3)) - 100
      , n = Math.floor(Math.random() * t)
      , r = "".concat(Date.now())
      , o = r.slice(r.length - 9)
      , i = new Array(e.length - 12).fill(0).join("");
    return Number("".concat(n).concat(o).concat(i))
}
function genCallbackId(e) {
    const t = genNextId(e);
    return t >= SafeInteger ? (overflow = !0,
    _callbackId = 1,
    _instanceId = genInstanceId(),
    genCallbackId()) : t
}
function genNextId(e) {
    let t = _instanceId + _callbackId++;
    for (; overflow || e && e[t]; )
        t = _instanceId + _callbackId++;
    return t
}
function getUUId(e) {
    return genCallbackId(e)
}
function debounce(e, t=300) {
    let n = null;
    return (...r) => {
        clearTimeout(n),
        n = setTimeout(( () => {
            e.apply(this, r)
        }
        ), t)
    }
}
let yodaInstance = null;
function setYoda(e) {
    yodaInstance = e
}
function getYoda() {
    return yodaInstance
}
async function checkCanUse(e, t) {
    const n = getYoda()
      , r = await n.bridge("tool", "canIUse", {
        namespace: e,
        name: t
    });
    return "1" == r.result && r.canUse
}
const markStr$1 = "too_performance_";
function getPerformanceId() {
    return markStr$1 + getUUId()
}
function isPerformanceId(e) {
    return e.startsWith(markStr$1)
}
const markStr = "event_";
function getEventId(e) {
    return markStr + getUUId(e)
}
function getEventIdOnlyNumber(e) {
    return e.replace(markStr, "")
}
function getEventIdByNumber(e) {
    return markStr + String(e)
}
function isEventId(e) {
    return e.startsWith(markStr)
}
const logArrayPool = []
  , logSessionMinTime = 1e3
  , maxTime = 30;
var switchEnum, switchEnum2;
switchEnum2 = switchEnum || (switchEnum = {}),
switchEnum2[switchEnum2.unload = 0] = "unload",
switchEnum2[switchEnum2.open = 1] = "open",
switchEnum2[switchEnum2.close = 2] = "close";
const isLocalBridge = e => ["canIUse", "getApiList"].includes(e.name);
let isSendLog = switchEnum.unload
  , getPageLoadDataPromise = null;
const loggerSwitch = () => {
    var e, t;
    if (getPageLoadDataPromise)
        return getPageLoadDataPromise;
    const {promise: n, resolve: r} = new Deferred;
    if (getPageLoadDataPromise = n,
    isSendLog == switchEnum.unload)
        if (null == (e = window.__yodaCommonDataObject__) ? void 0 : e.sampleData) {
            if ("string" == typeof window.__yodaCommonDataObject__.sampleData)
                try {
                    window.__yodaCommonDataObject__.sampleData = JSON.parse(window.__yodaCommonDataObject__.sampleData)
                } catch (e2) {
                    window.__yodaCommonDataObject__.sampleData = {}
                }
            isSendLog = (null == (t = window.__yodaCommonDataObject__.sampleData) ? void 0 : t.bridgeHit) ? switchEnum.open : switchEnum.close,
            r(isSendLog == switchEnum.open)
        } else {
            getYoda().bridge("webview", "getPageLoadData", {}, ( ({result: e, sampleData: t}) => {
                isSendLog = 1 == e && (null == t ? void 0 : t.bridgeHit) ? switchEnum.open : switchEnum.close,
                r(isSendLog == switchEnum.open)
            }
            ))
        }
    else
        r(isSendLog == switchEnum.open);
    return getPageLoadDataPromise
}
;
function sendLog() {
    window.__yodaBridge__.invoke("tool", "sendPerformanceLog", JSON.stringify({
        data: logArrayPool
    }), getPerformanceId()),
    logArrayPool.length = 0
}
const _logger = debounce(( () => {
    sendLog()
}
), logSessionMinTime)
  , getLog = (e, t, n) => {
    var r, o, i, a;
    const s = {
        key: "bridge",
        value: {},
        dimension: {
            api: e.name,
            namespace: e.namespace
        },
        event_client_timestamp: t,
        event_trigger_source: "H5",
        task_identifier: e.callbackId,
        is_task_event: !0,
        task_status: ""
    };
    switch (e.type) {
    case "invoke":
        s.value.h5_invoke_bridge_time = t,
        s.task_status = "START",
        "function" == typeof (null == (r = window.__yodaBridge__) ? void 0 : r.invoke) && "function" == typeof (null == (a = null == (i = null == (o = window.webkit) ? void 0 : o.messageHandlers) ? void 0 : i.KMYYoda) ? void 0 : a.postMessage) || (s.result = 126002,
        s.error_msg = "");
        break;
    case "callback":
        s.value.h5_receive_callback_time = t,
        s.value.h5_invoke_bridge_time = n,
        s.dimension.result_type = e.resultCode,
        s.dimension.result_type && (s.dimension.result_type = s.dimension.result_type.toString()),
        s.dimension.error_msg = e.errorMsg,
        s.task_status = "END";
        break;
    case "event":
        s.task_status = "SUCCESS",
        delete s.dimension.api,
        delete s.dimension.namespace,
        s.dimension.event = ""
    }
    return s
}
  , logger = (e, t) => {
    if (isLocalBridge(e))
        return;
    const n = Date.now().toString();
    return loggerSwitch().then((r => {
        r && (logArrayPool.push(getLog(e, n, t)),
        logArrayPool.length >= maxTime ? sendLog() : _logger())
    }
    )),
    n
}
;
function createSingleDeferred(e) {
    let t = null
      , n = new Promise((e => {
        t = e
    }
    ));
    return e && (n = n.then(e, e)),
    {
        isMulti: !1,
        resolve: t,
        promise: n
    }
}
function createMultiDeferred(e) {
    return {
        isMulti: !0,
        resolve: e,
        promise: new Promise(( () => {}
        ))
    }
}
const invokeMap = {}
  , deferredInvoke = {
    pushMQ(e=!1, t, n=!1) {
        const r = n ? getEventId() : getUUId(invokeMap)
          , o = e ? createMultiDeferred(t) : createSingleDeferred(t);
        return o.traceId = String(r),
        invokeMap[r] = o,
        o
    },
    removeMQ(e) {
        invokeMap[e] = void 0
    },
    create(e, t, n=!1, r) {
        const o = this.pushMQ(n, r);
        o.namespace = e,
        o.name = t;
        const i = logger({
            namespace: e,
            name: t,
            type: "invoke",
            callbackId: o.traceId
        });
        return invokeMap[o.traceId].startTime = i,
        {
            id: o.traceId,
            promise: o.promise
        }
    },
    resolve(e, t) {
        if (isPerformanceId(e))
            return;
        const n = invokeMap[e];
        n && (n.resolve(t),
        n.isMulti || this.removeMQ(e),
        isEventId(e) || logger({
            namespace: n.namespace,
            name: n.name,
            type: "callback",
            callbackId: n.traceId,
            resultCode: t.result
        }, n.startTime))
    },
    reject(e, t) {
        const n = invokeMap[e];
        n && (n.resolve(t),
        n.isMulti || this.removeMQ(e),
        isEventId(e) || logger({
            namespace: n.namespace,
            name: n.name,
            type: "callback",
            callbackId: n.traceId,
            resultCode: t.result,
            errorMsg: t.message
        }, n.startTime))
    }
}
  , BRIDGE_TYPE = {
    noCallbackList: ["popBack", "exitWebView"],
    onClickList: ["setPhysicalBackButton", "setTopLeftBtn", "setTopLeftSecondBtn", "setTopRightBtn", "setTopRightSecondBtn"],
    handlerList: ["on", "off"]
}
  , NAMESPACE_2_GLOBALVAR = {
    kwai: "Kwai",
    kwaiAd: "KwaiAd",
    kwaiAdThird: "KwaiAdThird",
    kwaiMerchant: "KwaiMerchant",
    kwaiLive: "KwaiLive",
    kspay: "kspay",
    Kwai: "Kwai",
    KwaiAd: "KwaiAd",
    KwaiAdThird: "KwaiAdThird",
    KwaiMerchant: "KwaiMerchant",
    KwaiLive: "KwaiLive"
}
  , {noCallbackList: noCallbackList, onClickList: onClickList, handlerList: handlerList} = BRIDGE_TYPE;
function generateUUID(e=!0) {
    let t = (new Date).getTime();
    "undefined" != typeof performance && "function" == typeof performance.now && (t += performance.now());
    return (e ? "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" : "xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx").replace(/[xy]/g, (e => {
        const n = (t + 16 * Math.random()) % 16 | 0;
        return t = Math.floor(t / 16),
        ("x" === e ? n : 3 & n | 8).toString(16)
    }
    ))
}
function generateUUCallbackFunction(e, t, n) {
    const r = generateUUID(!1)
      , o = "yoda_kuaishou_plugin_callback_".concat(n, "_").concat(r);
    return window[o] = function(n) {
        if ("string" == typeof n)
            try {
                n = JSON.parse(n)
            } catch (e2) {
                console.warn(e2)
            }
        isFunction$2(e) ? e.call(window, n) : "string" == typeof e && isFunction$2(window[e]) && window[e].call(window, n),
        t || delete window[o]
    }
    ,
    o
}
function transformFuncToURL(e, t) {
    const n = e;
    return e && Array.isArray(e.actions) && (n.actions = e.actions.map((e => (e && e.url && isFunction$2(e.url) && (e.url = generateUUCallbackFunction(e.url, !0, t)),
    e)))),
    n
}
const handlerCbMap = {};
function generateHandlerFunction(e, t) {
    let n = ""
      , r = null;
    if (Object.keys(handlerCbMap).some((t => {
        const o = handlerCbMap[t];
        return o === e && (r = o,
        n = t,
        !0)
    }
    )),
    r !== e && e) {
        const r = generateUUCallbackFunction(e, !0, t);
        handlerCbMap[r] = e,
        n = r
    }
    return n
}
function bridgeParamsHandler(e, t, n, r) {
    let o = {
        ...n
    };
    const i = "".concat(e, "_").concat(t);
    if (onClickList.includes(t))
        o.onClick = generateUUCallbackFunction(o.onClick, !0, i);
    else if (noCallbackList.includes(t))
        o = null;
    else if (handlerList.includes(t)) {
        const e = generateUUCallbackFunction(r, !1, i);
        o.handler && isFunction$2(o.handler) && (o.handler = generateHandlerFunction(o.handler, i)),
        o.callback = e
    } else if ("showDialog" === t) {
        const {positiveButton: e, negativeButton: t, neutralButton: n} = o;
        e && (o.positiveButton = transformFuncToURL(e, i)),
        t && (o.negativeButton = transformFuncToURL(t, i)),
        n && (o.neutralButton = transformFuncToURL(n, i))
    } else if (Object.keys(NAMESPACE_2_GLOBALVAR).includes(e)) {
        const e = generateUUCallbackFunction(r, !0, i);
        o.callback = o.callback || e
    }
    return o
}
const getMultiInstanceError = () => new Error("当前环境存在 Yoda 多实例问题，详细请参考 https://docs.corp.kuaishou.com/k/home/VbQx2ulc6v3M/fcADLOKqHyHpSr7hiCKKQVtVM")
  , setupMultiInstanceGuard = () => {
    let {__yodaBridgeCallback__: e} = window;
    if ("function" == typeof e)
        throw getMultiInstanceError();
    Object.defineProperty(window, "__yodaBridgeCallback__", {
        get: () => e,
        set(t) {
            if (e)
                throw getMultiInstanceError();
            e = t
        }
    })
}
;
let currentMode = "production";
const getCurrentMode = () => currentMode
  , setCurrentMode = e => {
    currentMode = e
}
  , loggerMethods = ["debug", "info", "log", "warn", "error"]
  , createLogger = e => Object.fromEntries(loggerMethods.map((t => [t, e(t)])))
  , print = (e, t, ...n) => {
    "production" !== getCurrentMode() && console[t]("[".concat(e, "]"), ...n)
}
  , console$1 = createLogger((e => (...t) => print("@yoda/bridge", e, ...t)))
  , invoke$1 = async e => {
    var t;
    const {namespace: n, name: r, params: o, multiCallback: i, callback: a} = e
      , s = NAMESPACE_2_GLOBALVAR[n]
      , {id: c, promise: l} = deferredInvoke.create(n, r, i, a)
      , u = s || n
      , p = e => {
        invokeCallback(c, e)
    }
    ;
    if (e.namespace = "Kwai" === u && "undefined" != typeof navigator && navigator.userAgent.includes("livemate/") ? "livemate" : u,
    e.params = null != (t = bridgeParamsHandler(u, r, o, p)) ? t : {},
    console$1.info("Invoking '".concat(e.namespace, ".").concat(e.name, "'"), e.params),
    isIOS && !window.webkit && compareYodaVersion("2.10.9.2") < 0)
        return l;
    try {
        window.__yodaBridge__.invoke(e.namespace, e.name, JSON.stringify(e.params), String(c))
    } catch (d) {
        p(JSON.stringify({
            result: 125110,
            msg: d.message
        }))
    }
    return l
}
  , invokeCallback = (e, t) => {
    isIOS && compareYodaVersion("2.3.7") < 0 && (e = "".concat(e));
    const n = "string" == typeof t ? JSON.parse(t) : t;
    1 === (null == n ? void 0 : n.result) ? deferredInvoke.resolve(e, n) : deferredInvoke.reject(e, n)
}
;
"undefined" != typeof window && (setupMultiInstanceGuard(),
window.__yodaBridgeCallback__ = invokeCallback);
const apiSet = new Set
  , invokeAndroid9920 = async e => {
    var t;
    const {namespace: n, name: r, params: o, multiCallback: i, callback: a} = e;
    if (!apiSet.size) {
        const e = await invoke$1({
            namespace: "tool",
            name: "getApiList",
            params: {}
        });
        1 === e.result && Array.isArray(e.apiList) && e.apiList.forEach(( ({namespace: e, name: t}) => apiSet.add("".concat(e, ".").concat(t))))
    }
    const s = apiSet.has("".concat(null != (t = NAMESPACE_2_GLOBALVAR[n]) ? t : n, ".").concat(r));
    return new Promise((e => {
        if (s)
            invoke$1({
                namespace: n,
                name: r,
                params: o,
                multiCallback: i,
                callback: a
            }).then(e);
        else {
            const t = {
                result: 125004
            };
            null == a || a(t),
            e(t)
        }
    }
    ))
}
;
let currentContainer = null;
const getContainer = () => currentContainer
  , setContainer = e => {
    currentContainer = e
}
  , getContext = ({initialBridge: e, initialParams: t}) => ({
    bridge: e,
    params: t
});
class BridgeError extends Error {
    constructor(e, t, n, r) {
        super(e),
        this.name = "BridgeError",
        this.message = e,
        this.code = t,
        this.rawRes = r,
        this.context = getContext(n)
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            context: this.context
        }
    }
}
const isBridgeError = e => e instanceof BridgeError
  , getLocation = async ({useLastLocationWhileLimited: e=!1, ...t}) => {
    const {invoke: n} = getContainer();
    if (compareKwaiAppVersion("10.1.30") < 0) {
        const {biz: e, force: r, statKey: o, alertScene: i, updateLocationScene: a, ...s} = t
          , c = {
            ...s,
            biz_type: e,
            forced_permission_request: void 0 === r ? 2 : r ? 1 : 3
        };
        try {
            const {data: {longitude: e, latitude: t}} = await n("kwai.syncLocationWithPermissionCheck", {
                ...c,
                forced_permission_request: 3
            });
            return {
                longitude: e,
                latitude: t
            }
        } catch (e2) {}
        await n("kwai.requestLocationPermissionWithPermissionCheck", c);
        const {data: {longitude: l, latitude: u}} = await n("kwai.syncLocationWithPermissionCheck", c);
        return {
            longitude: l,
            latitude: u
        }
    }
    if (isAndroid && compareKwaiAppVersion("10.3.30") < 0) {
        const {updateLocationScene: e=""} = t;
        Object.assign(t, {
            useInterval: !e
        })
    }
    try {
        const {longitude: e, latitude: r} = await n("system.requestLocation", t);
        return {
            longitude: e,
            latitude: r
        }
    } catch (r) {
        if (!isBridgeError(r))
            throw r;
        if (10014 === r.code && e) {
            const {longitude: e, latitude: r} = await n("system.getLocationCityInfo", {
                biz: t.biz
            });
            if ("number" == typeof e && "number" == typeof r)
                return {
                    longitude: e,
                    latitude: r
                }
        }
        throw r
    }
}
  , apis = {
    getLocation: getLocation
}
  , bridgeToLegacyKwaiBridge = Object.fromEntries(Object.entries({
    advertise: ["startFansTopLivePlay", "startNeoAdVideo"],
    feed: ["authorizationStatusForCalendar", "changeEventForCalendar", "closeChildLock", "getAddressBookAccessStatus", "getCoronaTvChasingData", "getFeed", "openDetailPage", "openFansGroup", "setSettingEntryForCourse", "startPlayLongVideo", "updateDeviceBit", "updateUserRecoBit", "updateWeatherInfo", "userIncentivesUpdateTasks"],
    game: ["addShortcutToDesktop", "appointGame", "changeAppointStatus", "gameSendLog", "gameTaskSelectImage", "getAppointStatus", "getWebViewDisplayType", "kgPageDidShowed", "openNativeGamecenter"],
    growth: ["getDeviceSecretInfo", "unionPhoneNumber"],
    im: ["setEnableIMTip"],
    live: ["deleteSubscribe", "liveReservationNotification", "openLiveQuizLive", "showSubscribeEditDialog", "showSubscribeSelectPhotoDialog", "subscribeLive", "unsubscribeLive"],
    merchant: ["closeLiveMerchantFloatingWindow", "getLatestImage", "getSidToken", "loadUrlOnNewMerchantPage", "merchantSetPhotoPlayStatus", "onItemSelected", "popupToFollow", "querySessionIsStickyOnTop", "reqSessionStickyOnTopWithThread", "requestLocationAuthorization"],
    minigame: ["publishSogameVideo"],
    pay: ["authThirdPartyAccount", "bindWithdrawType", "couponPay", "hasImportSdk", "nebulaStartGatewayWithdraw", "openKspayWebView", "sfBindWithdrawType", "startDeposit", "startGatewayPay", "startGatewayWithdraw", "startHalfScreenRecharge", "startKspayOrderPrepay"],
    platform: ["getDarkMode", "openWechatMiniProgram", "sendSMS", "startFaceRecognition"],
    post: ["cancelJsInjectUpload", "captureCertVideo", "deleteCacheVideoByPhotoId", "editAtlas", "editDraft", "editSmartAlbum", "getEditDraftData", "getSmartAlbumData", "getVideoUploadStatus", "intownShare", "postAtlas", "postVideo", "preloadMagicFace", "previewVideo", "reUploadShopVideo", "reeditPhoto", "resumeVideoUpload", "retryJsInjectUpload", "saveImage", "saveTempImages", "selectAndUploadMedia", "selectImage", "selectMixMediasAndUpload", "selectVideoAndUpload", "startAudioRecord", "uploadCertVideo", "uploadShopVideo", "uploadVideoFromAlbum", "verifyLiveUser"],
    social: ["addTokenBlockShareId", "bindPhone", "bindRiskPreCheck", "decryptContactsName", "enterGroupChat", "followUser", "joinGroup", "login", "logout", "mobileQuickAuthInfo", "mobileQuickLoginInfo", "needUpdateProfile", "requestFollowUserV2", "selectCountryPhoneCode", "sendIMMessage", "sendImFriendMessage", "setPageFollowRefer", "setShareTokenToClipBoard", "share", "startAuthActivity", "verifyAccount", "verifySMSCode", "verifyThirdPartyLogin", "wechatLogin"],
    system: ["collapseKeyboard", "getPushPermission", "getServerTime", "gete2", "openPushPermission"],
    tool: ["getClipBoard", "getExpTagTransList", "loadUrlOnNewPage", "openBrowser", "scanCode"],
    ui: ["selectCity", "showBottomSheet", "showPicker"],
    webview: ["clearClipBoard", "exitWebView", "getABTest", "getAppEnvironment", "getDeviceInfo", "hasInstalledApp", "hideNavigationBar", "popBack", "resetTopButtons", "setClipBoard", "setPageTitle", "setSlideBack", "setTopLeftBtn", "setTopLeftSecondBtn", "setTopRightBtn", "setTopRightSecondBtn", "submitData"]
}).flatMap(( ([e,t]) => t.map((t => ["".concat(e, ".").concat(t), "kwai.".concat(t)])))))
  , invalidResultBridges = ["social.currentUserInfo", "post.draftRecommendPhotos", "post.draftRecommendPublishPhotos", "kwai.KSVerifyRealNameInfo", "kwai.verifyRealNameInfo", "component.aliyunVerifyRealNameInfo", "component.verifyRealNameInfo"]
  , multipleCallbacksBridges = ["component.download", "kwai.download", "kwai.downloadThirdPartyAPP", "kwai.startNFC", "kwaiAd.callAdBridge", "kwaiAd.callCardHandler", "pay.startHalfScreenRecharge", "post.postVideo", "post.reUploadShopVideo", "post.selectImage", "post.uploadShopVideo", "post.uploadVideoFromAlbum", "post.selectMixMediasAndUpload", "post.launchAICut", "advertise.startNeoTask", "kwaiLive.subscribeChannel"]
  , multipleCallbacksBridgeSet = new Set(multipleCallbacksBridges)
  , useCallbackBridgeSet = new Set([...invalidResultBridges, ...multipleCallbacksBridges])
  , version = "2.0.14"
  , globalConfig = {
    get mode() {
        return getCurrentMode()
    },
    set mode(e) {
        setCurrentMode(e),
        console$1.info("You're currently running version ".concat(version, " in ").concat(e, " mode."))
    }
}
  , transformConfig = e => {
    const t = []
      , n = e => {
        t.push((t => {
            const n = e[t.bridge];
            return void 0 === n ? t : {
                ...t,
                bridge: n
            }
        }
        ))
    }
      , r = e => {
        t.push((t => {
            const n = e[t.bridge];
            if (void 0 === n)
                return t;
            const r = {
                ...n,
                ...t.params
            };
            return {
                ...t,
                params: r
            }
        }
        ))
    }
    ;
    return "tool.checkAppInstalled" === e.bridge && r({
        [e.bridge]: {
            identifier: e.params[isAndroid ? "android" : "ios"]
        }
    }),
    isIOS && compareKwaiAppVersion("9.10.11") >= 0 && n({
        "hybrid.getHybridStatus": "webview.pageContentStatus",
        "hybrid.getAndUpdateHybridDetail": "webview.pageContentInfo",
        "hybrid.preloadVideoList": "media.pvList",
        "hybrid.isVideoFullyCached": "media.vReady"
    }),
    isIOS && compareKwaiAppVersion("11.1.40") < 0 && n({
        "advertise.startNeoAdVideo": "kwai.startNeoAdVideo"
    }),
    isIOS && compareKwaiAppVersion("10.7.20") < 0 && n({
        "merchant.getSidToken": "kwai.getSidToken"
    }),
    isAndroid && compareKwaiAppVersion("10.6.50") < 0 && n({
        "ui.setStatusBarStyle": "kwai.setStatusBarStyle"
    }),
    (compareKwaiAppVersion("10.4.30") < 0 || !isKwaiApp) && n(bridgeToLegacyKwaiBridge),
    isIOS && compareKwaiAppVersion("10.4.10") < 0 && r({
        "system.startVibrate": {
            strength: "low",
            duration: 300
        }
    }),
    (compareKwaiAppVersion("10.3.20") < 0 || !isKwaiApp) && n({
        "webview.exitCurrentWebView": "kwai.".concat(isIOS ? "exitCurrentWebview" : "exitWebView")
    }),
    compareKwaiAppVersion("9.6.20") < 0 && t.push((e => {
        const {bridge: t} = e;
        return ["syncLocationWithPermissionCheck", "getLocationWithPermissionCheck", "requestLocationPermissionWithPermissionCheck"].some((e => t.endsWith(e))) ? {
            ...e,
            bridge: t.replace("WithPermissionCheck", "")
        } : e
    }
    )),
    t.reduce(( (e, t) => t(e)), e)
}
  , getInvocationConfig = e => {
    const [t,n={},r] = e
      , [o,i] = "function" == typeof r ? [{}, r] : [null != r ? r : {}];
    return {
        initialBridge: t,
        initialParams: n,
        bridge: t,
        params: n,
        options: o,
        callback: i
    }
}
  , getLegacyErrorMessage = e => hasOwnProperty$1(e, "error_msg") && "string" == typeof e.error_msg ? e.error_msg : ""
  , isIntrinsicAPI = e => e.bridge.startsWith("yoda.")
  , invokeAPI = e => {
    const {bridge: t, params: n} = e
      , [,r] = t.split(".");
    return (0,
    apis[r])(n)
}
  , invokeBridge = e => {
    const t = getYoda()
      , {initialBridge: n, bridge: r, params: o, callback: i} = e
      , [a,s] = r.split(".");
    return useCallbackBridgeSet.has(n) ? (t.bridge(a, s, o, (e => {
        console$1.info("Received a response from '".concat(r, "'"), e),
        null == i || i(e)
    }
    ), multipleCallbacksBridgeSet.has(n)),
    Promise.resolve()) : new Promise(( (n, i) => {
        t.bridge(a, s, o, (t => {
            var o;
            if (console$1.info("Received a response from '".concat(r, "'"), t),
            1 === t.result) {
                const {result: e, ...r} = t;
                return void n(r)
            }
            const {message: a=getLegacyErrorMessage(t)} = t
              , s = new BridgeError(a,t.result,e,t);
            null == (o = globalConfig.errorHandler) || o.call(globalConfig, s),
            i(s)
        }
        ))
    }
    ))
}
  , invoke = async (...e) => {
    var t, n;
    try {
        const n = getInvocationConfig(e);
        if (!isYoda())
            throw new BridgeError(["Cannot invoke bridge", "in non-Yoda environment."].join(" "),125014,n,null);
        const r = transformConfig(n)
          , {options: {timeout: o=(null != (t = globalConfig.timeout) ? t : 0)}} = r
          , i = isIntrinsicAPI(r) ? invokeAPI(r) : invokeBridge(r);
        return o > 0 && Number.isFinite(o) ? await Promise.race([i, delay(o).then(( () => Promise.reject(new BridgeError("Bridge invocation timed out.",125010,r,null))))]) : await i
    } catch (r) {
        throw isBridgeError(r) && (null == (n = globalConfig.errorHandler) || n.call(globalConfig, r)),
        r
    }
}
  , legacyEventTypes = new Set(["native_visible", "native_background", "native_foreground", "native_will_leave", "native_leave", "native_reentry", "native_loadPage", "native_pageFinished", "native_userDidLogin", "native_userDidLogout", "native_networkChanged", "native_screenshot_event", "native_web_view_display_mode_changed", "native_share_dialog_event", "native_shake", "native_darkModeChange"])
  , addListener$1 = async (e, t, n) => {
    legacyEventTypes.has(e) ? await invoke("kwai.on", {
        type: e,
        handler: t
    }) : await invoke("event.addEventListener", {
        type: void 0 === (null == n ? void 0 : n.data) ? e : {
            type: e,
            options: n.data
        },
        listener: t
    })
}
  , removeListener$1 = async (e, t) => {
    legacyEventTypes.has(e) ? await invoke("kwai.off", {
        type: e,
        handler: t
    }) : await invoke("event.removeEventListener", {
        type: e,
        listener: t
    })
}
  , eventMQ = {};
function addListener(e, t, n) {
    const r = eventMQ[e] || {
        callbackId: n,
        eventRecord: {}
    }
      , o = getUUId();
    t.__yodaCallbackId__[e] = String(o),
    r.eventRecord[o] = t,
    eventMQ[e] = r
}
function createCb(e) {
    return function(t) {
        const n = eventMQ[e];
        Object.keys((null == n ? void 0 : n.eventRecord) || {}).forEach((e => n.eventRecord[Number(e)](JSON.parse(JSON.stringify(t)))))
    }
}
function getCallbackIdByType(e) {
    return getEventIdByNumber(eventMQ[e].callbackId)
}
function removeListener(e, t) {
    const n = eventMQ[e]
      , r = t.__yodaCallbackId__[e];
    delete n.eventRecord[Number(r)],
    delete t.__yodaCallbackId__[e],
    hasListener(e) || delete eventMQ[e]
}
function hasListener(e) {
    const t = eventMQ[e];
    return Object.keys((null == t ? void 0 : t.eventRecord) || {}).length > 0
}
var Direction, Direction2;
Direction2 = Direction || (Direction = {}),
Direction2.x = "x",
Direction2.y = "y",
Direction2.z = "z";
const SHAKE_EVENT = "shaked"
  , SHAKE_START_EVENT = "shake-start"
  , SHAKE_END_EVENT = "shake-end"
  , JUDGE_STOP_TIME = 1e3
  , DEFAULT_SETTING = {
    level: 2,
    times: 3,
    intervalTime: 1300,
    iOSIntervalTime: 500,
    androidIntervalTime: 1300,
    isEmitImmediately: !0
}
  , ANDROID_LEVEL_MAP = {
    1: {
        basic: 13,
        total: 450
    },
    2: {
        basic: 16,
        total: 700
    },
    3: {
        basic: 20,
        total: 1100
    }
}
  , IOS_LEVEL_MAP = {
    1: {
        basic: 9,
        total: 220
    },
    2: {
        basic: 12,
        total: 400
    },
    3: {
        basic: 14,
        total: 500
    }
};
class ShakeHandler {
    constructor(e) {
        this.shakeConfig = {},
        this.shakedArr = [],
        this.isChecking = !1,
        this.nowStatus = {
            x: 0,
            y: 0,
            z: 0
        },
        this.lastStatus = {
            x: 0,
            y: 0,
            z: 0
        },
        this.stopMark = null,
        this.checkIsShakeStoped = !1,
        this.notEmitButShaked = !0,
        this.isShakeStarted = !1,
        this.isAndroid = !1,
        this.isArrivedConfigStandard = !1,
        this.levelMap = ANDROID_LEVEL_MAP,
        this.dispatchEvent = null,
        this.setStillShaking = debounce(( () => this.notShaking()), JUDGE_STOP_TIME),
        this.dispatchEvent = e.dispatchEvent,
        this.isAndroid = e.isAndroid,
        this.levelMap = this.isAndroid ? ANDROID_LEVEL_MAP : IOS_LEVEL_MAP
    }
    setOptions(e) {
        e ? (this.shakeConfig = {
            ...DEFAULT_SETTING,
            ...e
        },
        this.shakeConfig.times = this.isAndroid ? this.shakeConfig.times - 1 : 2 * (this.shakeConfig.times - 1),
        this.shakeConfig.intervalTime = this.isAndroid ? this.shakeConfig.androidIntervalTime : this.shakeConfig.iOSIntervalTime) : this.shakeConfig = {
            ...DEFAULT_SETTING
        }
    }
    resetShakeStatus(e) {
        this.shakedArr = [],
        this.isChecking = !1,
        this.notEmitButShaked = !1,
        e && (this.isArrivedConfigStandard = !1,
        this.isShakeStarted = !1)
    }
    checkIsShake(e) {
        if (this.isChecking = !0,
        Object.keys(this.nowStatus).forEach((t => this.nowStatus[t] = 9.8 * e[t])),
        this.judgeArrivedTerminal())
            return this.lastStatus = {
                x: 0,
                y: 0,
                z: 0
            },
            this.handleShakeHappend(),
            this.setStillShaking(),
            void (this.isChecking = !1);
        this.judgeLikelyShake() ? this.handleArrivedStandard() : this.isChecking = !1
    }
    judgeLikelyShake() {
        const {x: e, y: t, z: n} = this.nowStatus
          , {basic: r, total: o} = this.levelMap[this.shakeConfig.level];
        return e > r || t > r || n > r || e * e + t * t + n * n > o
    }
    judgeArrivedTerminal() {
        let e = 0
          , t = 0
          , n = Direction.x;
        return Object.keys(this.nowStatus).forEach((r => {
            t = Math.abs(this.lastStatus[r] - this.nowStatus[r]),
            e < t && (n = r,
            e = t)
        }
        )),
        this.lastStatus[n] * this.nowStatus[n] < 0
    }
    handleArrivedStandard() {
        this.lastStatus = {
            ...this.nowStatus
        },
        this.checkIsShakeStoped = !1,
        this.setStillShaking()
    }
    async handleShakeHappend() {
        this.isShakeStarted || await this.dispatchEvent({
            type: SHAKE_START_EVENT,
            data: {}
        }),
        this.isShakeStarted = !0,
        this.updateShakedArr((new Date).getTime())
    }
    notShaking() {
        this.checkIsShakeStoped = !0,
        this.checkDoDelayEmit()
    }
    updateShakedArr(e) {
        const {intervalTime: t} = this.shakeConfig;
        this.shakedArr.length > 0 ? e - this.shakedArr[this.shakedArr.length - 1] <= t ? this.shakedArr.push(e) : (this.shakedArr = [],
        this.isChecking = !1) : this.shakedArr.push(e),
        this.shakedArr.length >= this.shakeConfig.times ? this.handleArrivedEmitStandard() : this.isChecking = !1
    }
    handleArrivedEmitStandard() {
        this.isArrivedConfigStandard = !0,
        this.resetShakeStatus(),
        this.shakeConfig.isEmitImmediately ? this.dispatchEvent({
            type: SHAKE_EVENT,
            data: {}
        }) : this.notEmitButShaked = !0
    }
    checkDoDelayEmit() {
        this.notEmitButShaked && this.checkIsShakeStoped && !this.shakeConfig.isEmitImmediately && this.dispatchEvent({
            type: SHAKE_EVENT,
            data: {}
        }),
        this.isShakeStarted && this.dispatchEvent({
            type: SHAKE_END_EVENT,
            data: {
                isArrivedConfigStandard: this.isArrivedConfigStandard
            }
        }),
        this.resetShakeStatus(!0)
    }
}
const interval = 60;
let shakeHandler = null
  , checkIsShake = null;
const startMonitorShake = async () => {
    const e = getYoda()
      , t = await e.bridge("system", "startAccelerometer", {
        interval: interval
    });
    checkIsShake = shakeHandler.checkIsShake.bind(shakeHandler);
    const n = await e.bridge("event", "addEventListener", {
        type: "accelerometer-change",
        listener: checkIsShake
    });
    if (1 === t.result && 1 !== n.result && stopMonitorShake(),
    1 !== t.result || 1 !== n.result)
        throw new Error("摇一摇初始化失败，请稍后重试。AccelerometerRes:".concat(JSON.stringify(t), ";eventRes:").concat(JSON.stringify(n)))
}
  , validateOption = e => {
    if (!e)
        return;
    const {level: t, times: n, isEmitImmediately: r} = e;
    if (void 0 !== t && !ANDROID_LEVEL_MAP[t])
        throw new Error("请传入正确的level，可选值为1、2、3");
    if (void 0 !== n) {
        if (!Number.isInteger(n))
            throw new Error("times应为整数");
        if (n < 1)
            throw new Error("times应大于1")
    }
    if (void 0 !== r && "boolean" != typeof r)
        throw new Error("isEmitImmediately应为boolean类型")
}
  , initShakeHandler = async e => {
    const t = getYoda();
    if (!(await checkCanUse("system", "startAccelerometer")))
        throw new Error("当前APP暂不支持摇一摇");
    if (shakeHandler)
        throw new Error("当前存在尚未结束监听的摇一摇");
    shakeHandler = new ShakeHandler({
        dispatchEvent: async e => t.bridge("event", "dispatchEvent", e),
        isAndroid: isAndroid
    }),
    validateOption(e),
    shakeHandler.setOptions(e),
    shakeHandler.resetShakeStatus(),
    await startMonitorShake.bind(t)()
}
  , stopMonitorShake = async () => {
    const e = getYoda();
    if (!(await checkCanUse("system", "stopAccelerometer")))
        throw new Error("当前APP暂不支持摇一摇");
    shakeHandler = null;
    const t = await e.bridge("event", "removeEventListener", {
        type: "accelerometer-change",
        listener: checkIsShake
    })
      , n = await e.bridge("system", "stopAccelerometer", {});
    if (1 !== t.result || 1 !== n.result)
        throw new Error("摇一摇停止监听失败。stopRes:".concat(JSON.stringify(n), ";eventRes:").concat(JSON.stringify(t)))
}
  , yodaCustomEvent = {
    shaked: SHAKE_EVENT
}
  , eventToInitMap = {
    [yodaCustomEvent.shaked]: initShakeHandler
}
  , handleEventUnregisterMap = {
    [yodaCustomEvent.shaked]: stopMonitorShake
}
  , addEventListener$1 = (e, t) => {
    var n;
    const {type: r, listener: o} = e
      , i = "string" == typeof r ? r : r.type
      , a = "string" == typeof r ? {} : r.options;
    if (null == (n = eventToInitMap[i]) || n.call(eventToInitMap, a),
    !o.__yodaCallbackId__ && (o.__yodaCallbackId__ = {}),
    o.__yodaCallbackId__[i])
        throw new Error("addEventListener ".concat(i, " 的 listener 已经被绑定过了"));
    const s = hasListener(i);
    let c = null
      , l = Promise.resolve();
    if (s)
        isFunction$2(t) && t({
            result: 1
        });
    else {
        const e = deferredInvoke.pushMQ(!0, createCb(i), !0);
        c = parseInt(getEventIdOnlyNumber(e.traceId)),
        l = invoke$1({
            namespace: "event",
            name: "addEventListener",
            params: {
                type: i,
                listener: String(e.traceId)
            },
            callback: t
        })
    }
    return addListener(i, o, c),
    l
}
  , removeEventListener = (e, t) => {
    var n;
    const {type: r, listener: o} = e;
    null == (n = handleEventUnregisterMap[r]) || n.call(handleEventUnregisterMap);
    let i = Promise.resolve();
    if (o.__yodaCallbackId__) {
        const e = getCallbackIdByType(r);
        removeListener(r, o),
        hasListener(r) || (i = invoke$1({
            namespace: "event",
            name: "removeEventListener",
            params: {
                type: r,
                listener: e
            },
            callback: t
        }),
        deferredInvoke.removeMQ(e))
    }
    return i
}
  , yoda = {
    bridge: (e, t, n, r, o=!1) => {
        const i = {
            namespace: e,
            name: t,
            params: n,
            multiCallback: o,
            callback: r
        };
        if ("event" === e) {
            if ("addEventListener" === t)
                return addEventListener$1(n, r);
            if ("removeEventListener" === t)
                return removeEventListener(n, r)
        }
        return 0 === compareKwaiAppVersion("9.9.20") && isAndroid ? invokeAndroid9920(i) : invoke$1(i)
    }
};
setYoda(yoda),
setContainer({
    invoke: invoke,
    addListener: addListener$1,
    removeListener: removeListener$1
});
const yoda$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    addListener: addListener$1,
    invoke: invoke,
    isBridgeError: isBridgeError,
    removeListener: removeListener$1,
    version: version
}, Symbol.toStringTag, {
    value: "Module"
}));
var n$1, r$3, a$5;
Object.defineProperty || (Object.defineProperty = function(e, t, n) {
    e[t] = "[object Object]" === Object.prototype.toString.call(n) && n.hasOwnProperty("value") ? n.value : n
}
),
Object.assign || Object.defineProperty(Object, "assign", {
    value: function(e) {
        if (null === e)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (null !== r)
                for (var o in r)
                    Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o])
        }
        return t
    },
    writable: !0,
    configurable: !0
}),
Function.prototype.bind || (Function.prototype.bind = function(e) {
    if ("function" != typeof this)
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var t = Array.prototype.slice.call(arguments, 1)
      , n = this
      , r = function() {}
      , o = function() {
        var o = this instanceof r ? this : e;
        return n.apply(o, t.concat(Array.prototype.slice.call(arguments)))
    };
    return this.prototype && (r.prototype = this.prototype),
    o.prototype = new r,
    o
}
),
Array.prototype.indexOf || (Array.prototype.indexOf = function(e, t) {
    var n;
    if (null == this)
        throw new TypeError('"this" is null or not defined');
    var r = Object(this)
      , o = r.length >>> 0;
    if (0 === o)
        return -1;
    var i = +t || 0;
    if (Math.abs(i) === 1 / 0 && (i = 0),
    i >= o)
        return -1;
    for (n = Math.max(i >= 0 ? i : o - Math.abs(i), 0); n < o; ) {
        if (n in r && r[n] === e)
            return n;
        n++
    }
    return -1
}
),
Object.keys || (Object.keys = (n$1 = Object.prototype.hasOwnProperty,
r$3 = !{
    toString: null
}.propertyIsEnumerable("toString"),
a$5 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
function(e) {
    if ("object" != typeof e && "function" != typeof e || null === e)
        throw new TypeError("Object.keys called on non-object");
    var t = [];
    for (var n in e)
        n$1.call(e, n) && t.push(n);
    if (r$3)
        for (var r = 0, o = a$5; r < o.length; r++) {
            var i = o[r];
            n$1.call(e, i) && t.push(i)
        }
    return t
}
)),
Array.prototype.forEach || (Array.prototype.forEach = function(e, t) {
    var n, r;
    if (null == this)
        throw new TypeError(" this is null or not defined");
    var o = Object(this)
      , i = o.length >>> 0;
    if ("function" != typeof e)
        throw new TypeError(e + " is not a function");
    for (arguments.length > 1 && (n = t),
    r = 0; r < i; ) {
        var a = void 0;
        r in o && (a = o[r],
        e.call(n, a, r, o)),
        r++
    }
}
);
var o$3 = function(e, t) {
    return (o$3 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
};
function i$1(e, t) {
    if ("function" != typeof t && null !== t)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    function n() {
        this.constructor = e
    }
    o$3(e, t),
    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
    new n)
}
var s$3 = function() {
    return (s$3 = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
};
function c$3(e, t) {
    var n = {};
    for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
        var o = 0;
        for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
            t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]])
    }
    return n
}
function u$4(e, t, n, r) {
    return new (n || (n = Promise))((function(t, o) {
        function i(e) {
            try {
                s(r.next(e))
            } catch (t) {
                o(t)
            }
        }
        function a(e) {
            try {
                s(r.throw(e))
            } catch (t) {
                o(t)
            }
        }
        function s(e) {
            var r;
            e.done ? t(e.value) : (r = e.value,
            r instanceof n ? r : new n((function(e) {
                e(r)
            }
            ))).then(i, a)
        }
        s((r = r.apply(e, [])).next())
    }
    ))
}
function p$3(e, t) {
    var n, r, o, i, a = {
        label: 0,
        sent: function() {
            if (1 & o[0])
                throw o[1];
            return o[1]
        },
        trys: [],
        ops: []
    };
    return i = {
        next: s(0),
        throw: s(1),
        return: s(2)
    },
    "function" == typeof Symbol && (i[Symbol.iterator] = function() {
        return this
    }
    ),
    i;
    function s(i) {
        return function(s) {
            return function(i) {
                if (n)
                    throw new TypeError("Generator is already executing.");
                for (; a; )
                    try {
                        if (n = 1,
                        r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r),
                        0) : r.next) && !(o = o.call(r, i[1])).done)
                            return o;
                        switch (r = 0,
                        o && (i = [2 & i[0], o.value]),
                        i[0]) {
                        case 0:
                        case 1:
                            o = i;
                            break;
                        case 4:
                            return a.label++,
                            {
                                value: i[1],
                                done: !1
                            };
                        case 5:
                            a.label++,
                            r = i[1],
                            i = [0];
                            continue;
                        case 7:
                            i = a.ops.pop(),
                            a.trys.pop();
                            continue;
                        default:
                            if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== i[0] && 2 !== i[0])) {
                                a = 0;
                                continue
                            }
                            if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                                a.label = i[1];
                                break
                            }
                            if (6 === i[0] && a.label < o[1]) {
                                a.label = o[1],
                                o = i;
                                break
                            }
                            if (o && a.label < o[2]) {
                                a.label = o[2],
                                a.ops.push(i);
                                break
                            }
                            o[2] && a.ops.pop(),
                            a.trys.pop();
                            continue
                        }
                        i = t.call(e, a)
                    } catch (s) {
                        i = [6, s],
                        r = 0
                    } finally {
                        n = o = 0
                    }
                if (5 & i[0])
                    throw i[1];
                return {
                    value: i[0] ? i[1] : void 0,
                    done: !0
                }
            }([i, s])
        }
    }
}
function l$3(e, t, n) {
    if (2 === arguments.length)
        for (var r, o = 0, i = t.length; o < i; o++)
            !r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)),
            r[o] = t[o]);
    return e.concat(r || Array.prototype.slice.call(t))
}
var d$3 = {
    sessionId: "",
    appDevicePackageReady: !1,
    identityPackageReady: !1
}
  , g$5 = function() {
    function e(e, t) {
        switch (this.page = "",
        this.identity = "",
        t) {
        case "web":
            this.page_type = 2;
            break;
        case "native":
            this.page_type = 1;
            break;
        case "mina":
            this.page_type = 3;
            break;
        default:
            this.page_type = 0
        }
        this.update(e.page, e.params)
    }
    return e.prototype.update = function(e, t) {
        void 0 === e && (e = ""),
        e && e !== this.page && (this.page = e,
        this.identity = this.generatePageId(e)),
        t && (this.params = Object.assign(this.params || {}, t))
    }
    ,
    e.prototype.toJSON = function() {
        return {
            page: this.page,
            identity: this.identity,
            page_type: this.page_type,
            params: JSON.stringify(this.params),
            category: this.category
        }
    }
    ,
    e.prototype.generatePageId = function(e) {
        return e + (new Date).getTime()
    }
    ,
    e
}()
  , f$6 = ["Kwai", "Kwai_Lite", "Kwai_Pro", "livemate", "ksthanos", "ksNebula", "ksnebula", "kwaiying", "pearl", "kinder", "m2u", "LOLita", "XFunCore", "ACVideoCore", "ZIKZAK"].concat(["UVideo", "Vstatus", "Kwaigo", "MvMaster"])
  , h$4 = "undefined" == typeof window ? {
    addEventListener: function() {},
    removeEventListener: function() {},
    setTimeout: function() {},
    setInterval: function() {},
    _WEBLOGGER_MOCKED_WINDOW_: !0,
    document: {
        cookie: "",
        addEventListener: function() {},
        removeEventListener: function() {},
        querySelector: function() {},
        querySelectorAll: function() {}
    },
    navigator: {
        userAgent: "",
        sendBeacon: function() {}
    },
    screen: {},
    history: {},
    location: {
        hostname: "",
        search: "",
        href: "",
        origin: ""
    },
    localStorage: {
        getItem: function() {},
        setItem: function() {}
    }
} : window;
function v$4(e, t, n) {
    var r, o = {};
    if (e.length > 0)
        for (var i = t ? decodeURIComponent : function(e) {
            return e
        }
        , a = e.split(/;\s/g), s = null, c = null, l = null, u = 0, p = a.length; u < p; u++) {
            if ((l = null === (r = a[u]) || void 0 === r ? void 0 : r.match(/([^=]+)=/i)) && null !== l)
                try {
                    s = decodeURIComponent(l[1]),
                    c = i(a[u].substring(l[1].length + 1))
                } catch (d) {}
            else
                s = decodeURIComponent(a[u]),
                c = "";
            null !== s && (o[s] = c)
        }
    return o
}
var y$5, _$4 = {};
function m$3(e, t, n) {
    void 0 === t && (t = {}),
    void 0 === n && (n = !1);
    try {
        if (!n && e in _$4)
            return _$4[e];
        var r = h$4.document.cookie || "";
        return r === y$5 ? _$4[e] : (y$5 = r,
        (_$4 = v$4(r, !t.raw))[e])
    } catch (o) {}
}
function E$1(e, t, n) {
    void 0 === n && (n = {});
    try {
        h$4.document.cookie = function(e, t, n, r) {
            void 0 === r && (r = {});
            var o = "".concat(encodeURIComponent(e), "=").concat(n ? encodeURIComponent(t) : t)
              , i = r.expires
              , a = r.path || "/"
              , s = r.domain || "";
            return i instanceof Date && (o += "; expires=".concat(i.toUTCString())),
            "number" == typeof i && (o += "; max-age==".concat(i)),
            "" !== a && (o += "; path=".concat(a)),
            "" !== s && (o += "; domain=".concat(s)),
            !0 === r.secure && (o += "; secure"),
            o
        }(e, t, !n.raw, n),
        _$4[e] = t
    } catch (r) {}
}
var P$3 = {
    getCookie: m$3,
    setCookie: E$1,
    parseCookieString: v$4
};
function S$3() {
    for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
    try {
        var n = null === console || void 0 === console ? void 0 : console.log;
        return n && n.call.apply(n, l$3([console], e, !1))
    } catch (r) {
        return
    }
}
function k$2() {
    for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
    try {
        var n = null === console || void 0 === console ? void 0 : console.warn;
        return n && n.call.apply(n, l$3([console], e, !1))
    } catch (r) {
        return
    }
}
function O$2() {
    for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
    try {
        var n = null === console || void 0 === console ? void 0 : console.error;
        return n && n.call.apply(n, l$3([console], e, !1))
    } catch (r) {
        return
    }
}
function U(e, t, n, r) {
    return "attachEvent"in e ? e.attachEvent("on" + t, n) : e.addEventListener(t, n, r)
}
function b$4(e, t, n, r) {
    return "attachEvent"in e ? e.detachEvent("on" + t, n) : e.removeEventListener(t, n, r)
}
function T(e, t, n) {
    if (void 0 === n && (n = " "),
    (t -= e.length) <= 0)
        return e;
    for (var r = ""; t; )
        1 & t && (r += n),
        t >>= 1,
        n += n;
    return r + e
}
var N$2 = function(e) {
    void 0 === e && (e = h$4.navigator.userAgent.toLowerCase());
    try {
        for (var t = 0; t < f$6.length; t++)
            if (e.indexOf(f$6[t].toLowerCase()) > -1)
                return !0
    } catch (n) {
        return !1
    }
};
function A$2(e) {
    for (var t = {}, n = 0, r = e.split("&"); n < r.length; n++) {
        var o = r[n].split("=")
          , i = o[0]
          , a = o[1];
        i in t ? t[i]instanceof Array ? t[i].push(a) : t[i] = [t[i], a] : t[i] = a
    }
    return t
}
function C() {
    var e = m$3("appver", void 0, !0);
    return e && function(e, t) {
        if (!t)
            return !1;
        if (-1 !== t.indexOf("alpha"))
            return !1;
        if (-1 !== t.indexOf("beta"))
            return !1;
        try {
            var n = e.match(/\d+\.\d+\.\d+/);
            if (!(e = (null == n ? void 0 : n[0]) || ""))
                return !0;
            if (n = t.match(/\d+\.\d+\.\d+/),
            !(t = (null == n ? void 0 : n[0]) || ""))
                return !1;
            var r = e.split(".").map((function(e) {
                return Number(e)
            }
            ))
              , o = r[0]
              , i = r[1]
              , a = r[2]
              , s = t.split(".").map((function(e) {
                return Number(e)
            }
            ))
              , c = s[0]
              , l = s[1]
              , u = s[2];
            return !(c < o || !(c > o) && (l < i || !(l > i) && u < a))
        } catch (p) {
            return !1
        }
    }("10.8.30", e)
}
function w$1(e) {
    void 0 === e && (e = h$4.location.href);
    var t = e.lastIndexOf("?");
    return -1 === t ? {
        page: e
    } : {
        page: e.slice(0, t),
        params: A$2(e.slice(t + 1))
    }
}
var L$2 = function(e) {
    return e && "object" == typeof e && !Array.isArray(e)
};
function I$1(e) {
    return !e || !/^(https?:)?\/\//.test(e) || (O$2("[error 108]", "请注意当前埋点页面信息为 ".concat(e, "，不符合规范，上报失败！")),
    !1)
}
var R, x$1 = (R = "",
function() {
    if (R)
        return R;
    try {
        var e = h$4.devicePixelRatio || 1
          , t = Math.floor(screen.width * e)
          , n = Math.floor(screen.height * e);
        return R = "".concat(t, "x").concat(n)
    } catch (r) {
        return ""
    }
}
), D = function() {
    return !(!((null == h$4 ? void 0 : h$4.Worker) && (null == h$4 ? void 0 : h$4.Uint8Array) && h$4.URL && h$4.Promise) || (n = (null === (e = null == h$4 ? void 0 : h$4.navigator) || void 0 === e ? void 0 : e.userAgent) || "",
    r = /mobile|tablet|ip(ad|hone|od)|android|(windows phone)/i.test(n),
    o = "MacIntel" === (null == h$4 ? void 0 : h$4.navigator.platform) && (null === (t = null == h$4 ? void 0 : h$4.navigator) || void 0 === t ? void 0 : t.maxTouchPoints) > 1,
    r || o));
    var e, t, n, r, o
}, G = function(e) {
    try {
        return Math.abs(Math.floor(e))
    } catch (t) {
        return e
    }
};
function K(e) {
    return "string" == typeof e ? e : "object" == typeof e ? JSON.stringify(e) : ""
}
var W = ["PV", "CUSTOM", "RADAR", "CUSTOM_EVENT", "VIDEO", "LAUNCH_EVENT", "HEART_BEAT_EVENT", "APP_USAGE_STAT_EVENT", "EXCEPTION_EVENT", "DEVICE_STAT_EVENT"];
function B(e, t, n) {
    var r, o = null === (r = null == e ? void 0 : e.toUpperCase) || void 0 === r ? void 0 : r.call(e);
    W.includes(o) || (null == t ? void 0 : t.page) && (null == n ? void 0 : n.page) && t.page !== n.page && k$2("埋点警告：".concat(o, " 事件，").concat(t.action, " 元素的所属页面(").concat(t.page, ")和运行时页面(").concat(n.page, ")不匹配，可能导致埋点丢失！！"))
}
var V$1 = function() {
    function e() {
        this.events = {}
    }
    return e.prototype.on = function(e, t) {
        var n;
        t && "function" == typeof t && (this.events[e] = this.events[e] || [],
        null === (n = this.events[e]) || void 0 === n || n.push(t))
    }
    ,
    e.prototype.off = function(e, t) {
        if (this.events[e]) {
            if (t && "function" == typeof t) {
                var n = this.events[e];
                n && (o = t,
                (i = (r = n).indexOf(o)) > -1 && r.splice(i, 1))
            }
            var r, o, i;
            t || (this.events[e] = [])
        }
    }
    ,
    e.prototype.emit = function(e) {
        for (var t, n = [], r = 1; r < arguments.length; r++)
            n[r - 1] = arguments[r];
        this.events[e] && (null === (t = this.events[e]) || void 0 === t || t.forEach((function(e) {
            e.apply(void 0, n)
        }
        )))
    }
    ,
    e
}()
  , M$1 = 0
  , j = function(e) {
    function t(n, r) {
        var o, i = e.call(this) || this;
        return i.version = "3.10.45",
        i.plugins = {},
        i.flush = function() {
            i.logger.flush()
        }
        ,
        i.baseOption = s$3({}, r),
        i.logConfig = (o = n,
        s$3({
            env: "production",
            proto: "v3",
            timeout: 3e4,
            wait: 1e3,
            maxBatchLength: 50,
            sampleRate: 1,
            yoda: "undefined" != typeof window && window.yoda,
            forbidV2HttpUrlPage: !0
        }, o || {})),
        i.initUrlPackage(),
        t.__instance || (t.__instance = i),
        i
    }
    return i$1(t, e),
    Object.defineProperty(t.prototype, "sessionId", {
        get: function() {
            return d$3.sessionId
        },
        enumerable: !1,
        configurable: !0
    }),
    t.prototype.initUrlPackage = function() {
        this.updateCurrentUrlPackage()
    }
    ,
    t.prototype.updateCurrentUrlPackage = function(e, t) {
        if (void 0 === e && (e = {}),
        void 0 === t && (t = "web"),
        "object" == typeof e && e.page && this.currentUrlPackage && e.page === this.currentUrlPackage.page)
            return this.currentUrlPackage.update(e.page, e.params);
        this.currentUrlPackage = new g$5(e,t)
    }
    ,
    t.prototype.updateReferUrlPackage = function(e, t) {
        void 0 === e && (e = this.currentUrlPackage),
        void 0 === t && (t = "web"),
        this.referUrlPackage = e instanceof g$5 ? e : new g$5(e,t)
    }
    ,
    t.prototype.updateBase = function(e) {
        this.updateCommonPackage(e)
    }
    ,
    t.prototype.updateCommonPackage = function(e) {
        "object" == typeof e && this.commonPackage.update(e)
    }
    ,
    t.prototype.addPlugins = function() {
        var e = this;
        this.logConfig.plugins && this.logConfig.plugins.length && this.logConfig.plugins.forEach((function(t) {
            "object" == typeof t && "function" == typeof t.apply && e.addPluginInstance(t)
        }
        ))
    }
    ,
    t.prototype.addPluginInstance = function(e) {
        if (e) {
            var t = e.key || e.constructor && e.constructor.key || "plugin_auto_key_".concat(M$1++);
            "function" != typeof e.apply || e.weblog && e.weblog === this || e.apply(this),
            this.plugins[t] = e
        }
    }
    ,
    t.prototype.plug = function(e, t) {
        if (this.plugins[e.key])
            return O$2("[code 301]", "".concat(e.key, " 插件重复加载！"));
        this.addPluginInstance(new e(this,t))
    }
    ,
    t.prototype.unplug = function(e) {
        var t = this.plugins[e];
        t && (t.destroy(),
        delete this.plugins[e])
    }
    ,
    t.prototype.unplugAll = function() {
        for (var e in this.plugins)
            this.plugins[e] && this.unplug(e)
    }
    ,
    t.prototype.generateLog = function(e, t) {
        return {}
    }
    ,
    t.prototype.send = function(e, t, n) {
        B(e, t, this.currentUrlPackage);
        var r = this.generateLog(e.toUpperCase(), t);
        return "function" == typeof this.beforeSend && this.beforeSend(e, t, r),
        this.logger.send(r, !!n, t.callback)
    }
    ,
    t.prototype.collect = function(e, t) {
        this.send(e, t)
    }
    ,
    t.prototype.sendImmediately = function(e, t) {
        this.send(e, t, !0)
    }
    ,
    t.prototype.sendPackage = function(e, t) {
        this.logger.sendPackage(e, t)
    }
    ,
    t.prototype.destroy = function() {
        this.unplugAll()
    }
    ,
    t
}(V$1);
function H() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
        var t = 16 * Math.random() | 0;
        return ("x" == e ? t : 3 & t | 8).toString(16)
    }
    ))
}
function J$1(e) {
    if (void 0 === e && (e = "undefined" != typeof location ? location.hostname : ""),
    !e)
        return "";
    var t = e.split(".")
      , n = t.length;
    return n <= 2 ? "" : ".".concat(t[n - 2], ".").concat(t[n - 1])
}
function Y$1() {
    try {
        var e = m$3("did") || m$3("_did") || m$3("weblogger_did");
        if (!e) {
            e = "web_".concat(function() {
                for (var e = 1e9 * Math.random() >>> 0, t = [], n = 0; n < 7; n++)
                    t.push("0123456789ABCDEF".charAt(16 * Math.random()));
                return e + t.join("")
            }());
            var t = new Date;
            t.setFullYear(t.getFullYear() + 1),
            E$1("weblogger_did", e, {
                expires: t,
                domain: J$1(),
                path: "/"
            })
        }
        return e
    } catch (n) {
        return ""
    }
}
var Q$1 = function(e) {
    function t(t, n, r) {
        var o = e.call(this, {}, n) || this;
        if ("string" == typeof t) {
            var i = w$1(t);
            o.page = i.page,
            o.params = i.params
        } else
            o.page = (t || {}).page || "",
            o.params = (t || {}).params || void 0;
        return o.identity = o.generatePageId(),
        r && "string" == typeof t && o.init(t, r),
        o
    }
    return i$1(t, e),
    t.prototype.init = function(e, t) {
        void 0 === t && (t = {});
        var n = function(e, t) {
            var n = e.url
              , r = e.page
              , o = e.params
              , i = e.pageId
              , a = !1;
            if (!r && "string" == typeof n) {
                var s = w$1(n);
                r = s.page,
                o = s.params
            }
            if ("function" == typeof t)
                try {
                    var c = t({
                        url: n,
                        page: r,
                        params: o
                    });
                    "string" == typeof c ? r = c : "object" == typeof c && (c.page && (r = c.page),
                    c.params && (o = c.params),
                    c.pageId && (i = c.pageId),
                    c.coPage && (a = !0))
                } catch (p) {}
            else if ("object" == typeof t) {
                var l = "";
                for (var u in t)
                    if ((n || r || "").indexOf(u) > -1) {
                        l = t[u];
                        break
                    }
                l && (r = l)
            }
            return {
                page: r,
                params: o,
                pageId: i,
                coPage: a
            }
        }({
            url: e,
            page: this.page,
            params: this.params
        }, t)
          , r = n.page
          , o = n.params;
        this.update(r, o)
    }
    ,
    t.prototype.attachUrl = function() {
        var e;
        if (this.params || (this.params = {}),
        null === location || void 0 === location ? void 0 : location.href) {
            this.params.origin_url = this.params.origin_url || (null === (e = h$4.location) || void 0 === e ? void 0 : e.href);
            var t = w$1(h$4.location.href).page
              , n = void 0 === t ? "" : t;
            this.params.origin_pathname = n
        }
    }
    ,
    t.prototype.getRealUrlPackage = function() {
        var e = w$1(h$4.location.href)
          , t = e.page
          , n = e.params;
        return {
            page: t,
            params: s$3({
                page_code: this.page,
                url: h$4.location.href,
                query: n
            }, n),
            page_type: this.page_type,
            identity: this.identity
        }
    }
    ,
    t.prototype.generatePageId = function() {
        return H()
    }
    ,
    t
}(g$5)
  , z$2 = "https://data-track.corp.kuaishou.com"
  , F$2 = z$2 + "/"
  , q$1 = "production"
  , X$1 = "rest/wd/common/log/collect/"
  , $$1 = [q$1, "test", "development", "logger", "oversea"]
  , Z$1 = {
    v2: "rest/kd/log/collect?_json=1&biz=",
    v3: "".concat(X$1, "misc2"),
    radar: "".concat(X$1, "radar")
}
  , ee$1 = {
    v2: {
        production: ["https://wlog.ksapisrv.com/", "https://wlog.gifshow.com/"][Math.round(Math.random())],
        development: F$2,
        test: F$2,
        oversea: "https://logsdk.kwai-pro.com/"
    },
    v3: {
        production: "https://log-sdk.ksapisrv.com/",
        development: F$2,
        test: F$2,
        oversea: "https://logsdk.kwai-pro.com/"
    }
}
  , te$1 = function(e, t, n) {
    return void 0 === e && (e = q$1),
    void 0 === t && (t = !1),
    void 0 === n && (n = "v3"),
    -1 === $$1.indexOf(e) ? e + Z$1[n] : t && ee$1.v3[e] ? ee$1.v3[e] + Z$1.radar : ee$1[n][e] && Z$1[n] ? ee$1[n][e] + Z$1[n] : ee$1.v3.production + Z$1.v3
}
  , ne$1 = function(e, t) {
    if (!t)
        return e;
    try {
        return /\?(.+?)$/.test(e) ? e.replace(/\?(.+?)$/, "?".concat(t, "&$1")) : e + "?".concat(t)
    } catch (n) {
        return e
    }
}
  , re = function() {
    function e(e, t) {
        var n = this;
        this.asyncQueue = [],
        this.throttleQueue = [],
        this.errorQueue = [],
        this.sendingQueue = {},
        this.url = "",
        this.isV2 = !1,
        this.isDebug = !1,
        this.radarUrl = "",
        this.drained = !1,
        this.batchCount = 50,
        this.isSetSamplingResult = !1,
        this.sendingYield = null,
        this.flush = function(e) {
            n.sendLogs(n.throttleQueue.concat(n.asyncQueue), e),
            n.throttleQueue = [],
            n.asyncQueue = []
        }
        ,
        this.drain = function() {
            n.drained = !0,
            n.flush(),
            n.flushErrorLogs(),
            setTimeout((function() {
                n.drained = !1
            }
            ), 1e3)
        }
        ,
        this.config = e,
        this.config.maxBatchLength && this.config.maxBatchLength > 1 && (this.batchCount = Math.min(50, this.config.maxBatchLength)),
        this.commonPackage = t,
        this.isDebug = this.config.logger || "logger" === this.config.env,
        this.isV2 = "v2" === this.config.proto,
        this.updateUrls()
    }
    return e.prototype.sendData = function(e, t) {
        return "function" == typeof this.config.sender ? this.config.sender(e, t) : this.baseSendData(e, t)
    }
    ,
    Object.defineProperty(e.prototype, "responseSamplingStorageKey", {
        get: function() {
            var e = this.commonPackage.app_package
              , t = e.product_name
              , n = e.product
              , r = this.commonPackage.identity_package.device_id;
            return "RESPONSE_SAMPLING_STORAGE_KEY_".concat(t || n, "_").concat(r)
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.updateUrls = function() {
        var e = this.config.env;
        e && /^(https?:)?\/\//.test(e) ? this.url = e : this.url = te$1(e),
        this.formatUrl()
    }
    ,
    e.prototype.formatUrl = function() {
        this.radarUrl || (this.radarUrl = this.url.replace(-1 !== this.url.indexOf(Z$1.v2) ? Z$1.v2 : Z$1.v3, Z$1.radar),
        -1 !== this.radarUrl.indexOf(ee$1.v2.production || "") && this.radarUrl.replace(ee$1.v2.production || "", ee$1.v3.production));
        var e = this.commonPackage.app_package
          , t = e.product_name
          , n = e.product
          , r = "v=3.10.45&kpn=".concat(t || n);
        this.url = ne$1(this.url, r),
        this.radarUrl = ne$1(this.radarUrl, r)
    }
    ,
    e.prototype.getCommonPackageJSON = function() {
        return this.commonPackage.toJSON()
    }
    ,
    e.prototype.send = function(e, t, n) {
        if (void 0 === t && (t = !1),
        n || this.drained)
            return this.sendLogs([e], n);
        t ? this.sendAsync(e, n) : this.sendThrottle(e)
    }
    ,
    e.prototype.sendAsync = function(e, t) {
        return u$4(this, void 0, void 0, (function() {
            return p$3(this, (function(t) {
                switch (t.label) {
                case 0:
                    return this.asyncQueue.push(e),
                    this.asyncQueue.length >= this.batchCount ? (this.flush(),
                    [2]) : this.sendingYield ? [4, this.sendingYield] : [3, 2];
                case 1:
                    t.sent(),
                    this.sendingYield = null,
                    t.label = 2;
                case 2:
                    return t.trys.push([2, 4, , 5]),
                    [4, Promise.resolve()];
                case 3:
                case 4:
                    return t.sent(),
                    [3, 5];
                case 5:
                    return this.asyncQueue.length ? (this.flush(),
                    [2]) : [2]
                }
            }
            ))
        }
        ))
    }
    ,
    e.prototype.sendThrottle = function(e) {
        var t = this;
        this.throttleQueue.push(e),
        this.throttleQueue.length >= this.batchCount ? this.flush() : (clearTimeout(this.batchWaitTimer),
        this.batchWaitTimer = setTimeout((function() {
            t.flush()
        }
        ), this.config.wait))
    }
    ,
    e.prototype.sendLogs = function(e, t) {
        var n = this;
        if (!e || !e.length)
            return "function" == typeof t && t();
        var r = this.buildLogPackage(e, this.url);
        this.sendPackage(r, (function(e) {
            e ? n.errHandler(r) : n.flushErrorLogs(),
            "function" == typeof t && t(e)
        }
        ))
    }
    ,
    e.prototype.sendPackage = function(e, t) {
        var n = this.config.timeout;
        try {
            this.sendData(s$3(s$3({}, e), {
                isDebug: this.isDebug,
                isDrained: this.drained,
                timeout: n
            }), t)
        } catch (r) {
            "function" == typeof t && t(r)
        }
    }
    ,
    e.prototype.buildLogPackage = function(e, t) {
        return this.isV2 ? this.buildV2Package(e, t) : this.buildV3Package(e, t)
    }
    ,
    e.prototype.buildV2Package = function(e, t) {
        return {
            url: t,
            data: {
                log: {
                    event: e
                }
            }
        }
    }
    ,
    e.prototype.buildV3Package = function(e, t, n) {
        var r = this.getCommonPackageJSON();
        return n && Object.assign(r, n),
        {
            url: t,
            data: {
                common: r,
                logs: e
            }
        }
    }
    ,
    e.prototype.errHandler = function(e) {
        var t;
        if (this.isV2)
            this.errorQueue.unshift(e);
        else {
            var n = e.data;
            if (n.logs.length) {
                delete n.common.h5_extra_attr.http_seq_id,
                delete n.common.h5_extra_attr.client_timestamp;
                for (var r = !1, o = 0; o < this.errorQueue.length; o++) {
                    var i = this.errorQueue[o];
                    if (i.url === e.url && i.data.logs.length + n.logs.length <= 100 && JSON.stringify(i.data.common) === JSON.stringify(n.common)) {
                        r = !0,
                        (t = i.data.logs).push.apply(t, n.logs);
                        break
                    }
                }
                r || (this.errorQueue.length >= 5 && this.errorQueue.pop(),
                this.errorQueue.unshift(e))
            }
        }
    }
    ,
    e.prototype.flushErrorLogs = function() {
        var e = this;
        this.errorQueue.forEach((function(t) {
            e.sendPackage(t)
        }
        )),
        this.errorQueue = []
    }
    ,
    e.prototype.destory = function() {
        this.batchWaitTimer && clearTimeout(this.batchWaitTimer),
        this.compensateTimer && clearTimeout(this.compensateTimer)
    }
    ,
    e.prototype.sendRadar = function(e, t) {
        var n = t ? {
            service_name: t
        } : void 0
          , r = this.buildV3Package([e], this.radarUrl || this.url, n);
        this.sendPackage(r)
    }
    ,
    e
}()
  , ae = function(e, t, n) {
    return O$2("[error 400]", "埋点上报接口请求报错", "\nurl:", t, "\ndata", n, "\nerror:", e || "server decode log failed")
};
function oe$2(e, t) {
    var n = e.url
      , r = e.data
      , o = e.timeout;
    return new Promise((function(e) {
        if ("undefined" != typeof XMLHttpRequest) {
            var i = new XMLHttpRequest;
            return i.open("POST", n),
            i.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"),
            "object" != typeof r || r instanceof Uint8Array || (r = JSON.stringify(r)),
            o && (i.timeout = o),
            i.onload = function() {
                var o = function(e, t, n, r) {
                    var o;
                    if (e < 200 || e >= 300 && 304 !== e)
                        ;
                    else
                        try {
                            var i = JSON.parse(t)
                              , a = i.exception
                              , s = i.result
                              , c = i.error_msg;
                            a && (o = a),
                            1 !== s && (o = c || "result is ".concat(s))
                        } catch (l) {
                            o = l.message
                        }
                    return o && ae(o, n, r),
                    o
                }(i.status, i.response, n, r);
                t && t(o),
                e({
                    error: o,
                    response: o ? void 0 : i.response
                })
            }
            ,
            i.ontimeout = i.onerror = function(o) {
                o && ae(o, n, r),
                t && t(o ? "networkTimeout" : ""),
                e({
                    error: "networkTimeout"
                })
            }
            ,
            i.send(r),
            i
        }
    }
    ))
}
var ie$2 = function(e) {
    if ("undefined" != typeof XMLHttpRequest) {
        var t = function(t) {
            return O$2("[error 401]", "GET 请求出错 url: ".concat(e), t)
        };
        try {
            var n = new XMLHttpRequest;
            n.open("GET", e),
            n.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"),
            n.send(),
            n.onerror = t
        } catch (r) {
            t(r)
        }
    }
}
  , se$1 = null == h$4 ? void 0 : h$4.navigator
  , ce$1 = se$1 && -1 !== se$1.userAgent.indexOf("Chrome")
  , ue$1 = "function" == typeof se$1.sendBeacon;
function pe$1(e, t) {
    var n = e.url
      , r = e.data
      , o = e.timeout;
    e.isDebug;
    var i = e.isDrained
      , a = e.forceSendBeacon;
    return u$4(this, void 0, void 0, (function() {
        var e;
        return p$3(this, (function(s) {
            switch (s.label) {
            case 0:
                return r = JSON.stringify(r),
                i && function(e) {
                    var t, n = e.url, r = e.data;
                    if (!ce$1 && !e.forceSendBeacon || !ue$1)
                        return !1;
                    "object" == typeof r && r.fd && (r = r.fd);
                    try {
                        return null === (t = h$4.navigator) || void 0 === t ? void 0 : t.sendBeacon(n, r)
                    } catch (o) {
                        return O$2("[error 403]", "navigator.sendBeacon 报错", o),
                        !1
                    }
                }({
                    url: n,
                    data: r,
                    forceSendBeacon: a
                }) ? (t && t(),
                [2]) : [4, oe$2({
                    url: n,
                    data: r,
                    timeout: o
                }, t)];
            case 1:
                return [2, (e = s.sent()).error ? void 0 : e.response]
            }
        }
        ))
    }
    ))
}
var le$1, de$2 = function(e, t, n) {
    void 0 === e && (e = z$2);
    var r = "".concat(e, "/#/logger/index?sessionId=").concat(n);
    return S$3("%c埋点抓包校验: %c".concat(r), "color:#1abf89;font-size:1.2em;line-height:2.4em;", "font-size:1.2em;"),
    "".concat(t, "/").concat(n, "/")
}, e2;
e2 = le$1 || (le$1 = {}),
e2.loading = "loading",
e2.loaded = "loaded";
var ge$1, fe$1, he$2, ve$1 = Object.create(null), ye$1 = "weblogger_switch", _e$1 = function(e) {
    var t = function() {
        try {
            var e = m$3(ye$1) || "undefined" != typeof sessionStorage && sessionStorage.getItem(ye$1);
            if (!e)
                return;
            var t = JSON.parse(e)
              , n = t.loggerSessionId
              , r = t.reportHost
              , o = t.loggerHost
              , i = t.handshakeApi;
            return n ? (ie$2(i || "".concat(r, "/").concat(n)),
            de$2(o, r, n)) : ""
        } catch (a) {
            return ""
        }
    }() || function(e) {
        void 0 === e && (e = h$4.location.href);
        var t = e.lastIndexOf("?");
        if (-1 === t)
            return "";
        var n = A$2(e.slice(t + 1)).webloggerSwitch;
        if (!n)
            return "";
        try {
            var r = decodeURIComponent(n)
              , o = JSON.parse(r)
              , i = o.loggerSessionId
              , a = o.reportHost
              , s = o.loggerHost
              , c = o.handshakeApi;
            return i ? ("undefined" != typeof sessionStorage && h$4.sessionStorage.setItem(ye$1, r),
            ie$2(c || "".concat(a, "/").concat(i)),
            de$2(s, a, i)) : ""
        } catch (l) {
            return ""
        }
    }();
    if (t)
        return te$1(t, !1, e)
}, me$1 = function(e) {
    function t(t, n) {
        var r = e.call(this, t, n) || this;
        return r.baseSendData = r.sendLog,
        r.getResponseSamplingStorage(),
        r
    }
    return i$1(t, e),
    t.prototype.getResponseSamplingStorage = function() {
        return u$4(this, void 0, void 0, (function() {
            var e;
            return p$3(this, (function(t) {
                switch (t.label) {
                case 0:
                    return t.trys.push([0, 2, , 3]),
                    [4, Promise.resolve()];
                case 1:
                    return t.sent(),
                    (e = Number(h$4.localStorage.getItem(this.responseSamplingStorageKey))) && Date.now() < e ? this.sendEffectiveTime = e : e && h$4.localStorage.removeItem(this.responseSamplingStorageKey),
                    [3, 3];
                case 2:
                    return t.sent(),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ))
    }
    ,
    t.prototype.isResponseSampling = function() {
        return !!(this.sendEffectiveTime && Date.now() < this.sendEffectiveTime)
    }
    ,
    t.prototype.setResponseSamplingConfig = function(e) {
        var t = this;
        this.isSetSamplingResult || (this.isSetSamplingResult = !0,
        null == e || e.then((function(e) {
            var n;
            try {
                n = e && JSON.parse(e)
            } catch (i) {
                n = {
                    result: 1,
                    hostName: ""
                }
            }
            var r = null == n ? void 0 : n.expireSeconds;
            if (r) {
                var o = Date.now() + 1e3 * r;
                t.sendEffectiveTime = o,
                h$4.localStorage.setItem(t.responseSamplingStorageKey, String(o))
            }
        }
        )))
    }
    ,
    t.prototype.updateUrls = function() {
        var e = this.config
          , t = e.env
          , n = void 0 === t ? q$1 : t
          , r = e.logger
          , o = e.proto
          , i = e.isBridge
          , a = e.disableCompress
          , s = _e$1(o);
        if (s)
            this.url = s,
            this.isDebug = !0;
        else if (r || "logger" === n || "logger-oversea" === n) {
            var c = function(e, t) {
                void 0 === e && (e = Y$1()),
                void 0 === t && (t = !1);
                var n = t ? "https://data-track-sgp.corp.kuaishou.com" : z$2;
                return ie$2("".concat(n, "/rest/").concat(e)),
                de$2(n, "".concat(n, "/rest"), e)
            }(this.commonPackage.identity_package.device_id, "logger-oversea" === n);
            this.url = te$1(c, !1, o),
            this.isDebug = !0
        } else
            n && /^(https?:)?\/\//.test(n) ? this.url = n : (this.isDebug = n !== q$1,
            this.url = te$1(n, !1, o),
            this.radarUrl = te$1(n, !0, o));
        this.enableAsyncGzip = !a && "v3" === o && !i && D() && n === q$1 && !s && !r,
        this.enableAsyncGzip && function(e, t) {
            if (void 0 === t && (t = !0),
            !ve$1[e]) {
                var n = ve$1[e] = {
                    state: le$1.loading
                }
                  , r = document.createElement("script");
                r.crossOrigin = "anonymous",
                r.src = e,
                t && (r.async = !0);
                var o = document.getElementsByTagName("script")[0];
                o && o.parentNode ? o.parentNode.insertBefore(r, o) : document.head.appendChild(r),
                r.onload = function() {
                    n.state = le$1.loaded
                }
                ,
                r.onerror = function(e) {
                    n.state = le$1.loaded
                }
            }
        }("https://h2.static.yximgs.com/udata/pkg/ks-track-platform-new/weblogger/3.10.45/async/gzipper.min.js"),
        this.formatUrl()
    }
    ,
    t.prototype.sendLog = function(e, t) {
        var n = this.config.forceSendBeacon;
        !this.isV2 && this.isResponseSampling() || !this.drained && this.enableAsyncGzip && this.sendGzip(e, t) || this.setResponseSamplingConfig(pe$1(s$3(s$3({}, e), {
            forceSendBeacon: n
        }), t))
    }
    ,
    t.prototype.sendGzip = function(e, n) {
        var r, o = this;
        if (!(null === (r = t.Gzipper) || void 0 === r ? void 0 : r.sendData))
            return !1;
        var i = t.Gzipper.sendData(e, (function(t) {
            t && o.setResponseSamplingConfig(pe$1(e, n))
        }
        ));
        return this.setResponseSamplingConfig(i),
        !!i
    }
    ,
    t.prototype.getCommonPackageJSON = function() {
        return this.commonPackage.toJSON()
    }
    ,
    t.prototype.send = function(t, n, r) {
        void 0 === n && (n = !1),
        this.isV2 && (this.commonPackage.setAdditionalSeqIdPackage(t.getEventType()),
        t.common_package = this.getCommonPackageJSON()),
        e.prototype.send.call(this, t, n, r)
    }
    ,
    t
}(re);
!function(e) {
    var t, n, r, o, i, a, s, c;
    (t = e.ElementStatus || (e.ElementStatus = {}))[t.UNKNOWN_STATUS = 0] = "UNKNOWN_STATUS",
    t[t.CHECKED = 1] = "CHECKED",
    t[t.UNCHECKED = 2] = "UNCHECKED",
    (n = e.PageShowAction || (e.PageShowAction = {}))[n.UNKNOWN_ACTION = 0] = "UNKNOWN_ACTION",
    n[n.ENTER = 1] = "ENTER",
    n[n.LEAVE = 2] = "LEAVE",
    n[n.RESUME = 3] = "RESUME",
    (r = e.ActionStatus || (e.ActionStatus = {}))[r.UNKNOWN_STATUS = 0] = "UNKNOWN_STATUS",
    r[r.SUCCESS = 1] = "SUCCESS",
    r[r.FAIL = 2] = "FAIL",
    (o = e.ActionType || (e.ActionType = {}))[o.UNKNOWN_ACTION_TYPE = 0] = "UNKNOWN_ACTION_TYPE",
    o[o.CLICK = 1] = "CLICK",
    o[o.LEFT_PULL = 2] = "LEFT_PULL",
    o[o.RIGHT_PULL = 3] = "RIGHT_PULL",
    o[o.UP_PULL = 4] = "UP_PULL",
    o[o.DOWN_PULL = 5] = "DOWN_PULL",
    (i = e.SubAction || (e.SubAction = {}))[i.UNKNOWN_SUB_ACTION = 0] = "UNKNOWN_SUB_ACTION",
    i[i.PAGE_ENTER = 1] = "PAGE_ENTER",
    i[i.PAGE_LEAVE = 2] = "PAGE_LEAVE",
    i[i.PAGE_RESUME = 3] = "PAGE_RESUME",
    i[i.PAGE_PAUSE = 4] = "PAGE_PAUSE",
    (a = e.Direction || (e.Direction = {}))[a.UNKNOWN2 = 0] = "UNKNOWN2",
    a[a.UP = 1] = "UP",
    a[a.DOWN = 2] = "DOWN",
    a[a.LEFT = 3] = "LEFT",
    a[a.RIGHT = 4] = "RIGHT",
    (s = e.TaskStatus || (e.TaskStatus = {}))[s.UNKNOWN_STATUS = 0] = "UNKNOWN_STATUS",
    s[s.START = 1] = "START",
    s[s.RETRY = 2] = "RETRY",
    s[s.PAUSE = 3] = "PAUSE",
    s[s.RESUME = 4] = "RESUME",
    s[s.PENDING = 5] = "PENDING",
    s[s.PROCESSING = 6] = "PROCESSING",
    s[s.SUCCESS = 7] = "SUCCESS",
    s[s.FAIL = 8] = "FAIL",
    s[s.CANCEL = 9] = "CANCEL",
    s[s.FINISH = 10] = "FINISH",
    (c = e.OperationType || (e.OperationType = {}))[c.UNKNOWN_OPERATION = 0] = "UNKNOWN_OPERATION",
    c[c.CLICK = 1] = "CLICK",
    c[c.DOUBLE_CLICK = 2] = "DOUBLE_CLICK",
    c[c.TRIPLE_CLICK = 3] = "TRIPLE_CLICK",
    c[c.LONG_PRESS = 4] = "LONG_PRESS",
    c[c.PULL = 5] = "PULL",
    c[c.DRAG = 6] = "DRAG",
    c[c.SCALE = 7] = "SCALE",
    c[c.PULL_DOWN = 8] = "PULL_DOWN",
    c[c.PULL_UP = 9] = "PULL_UP",
    c[c.RIGHT_CLICK = 10] = "RIGHT_CLICK",
    c[c.AUTO = 11] = "AUTO"
}(ge$1 || (ge$1 = {})),
function(e) {
    var t, n;
    (t = e.ShowType || (e.ShowType = {}))[t.UNKNOWN_TYPE = 0] = "UNKNOWN_TYPE",
    t[t.PAGE_AUTO = 10] = "PAGE_AUTO",
    t[t.PAGE_CUSTOM = 11] = "PAGE_CUSTOM",
    t[t.ELEMENT = 12] = "ELEMENT",
    (n = e.TaskEventType || (e.TaskEventType = {}))[n.UNKNOWN_TYPE = 0] = "UNKNOWN_TYPE",
    n[n.USER_OPERATION = 1] = "USER_OPERATION",
    n[n.STAY_LENGTH_STAT_EVENT = 2] = "STAY_LENGTH_STAT_EVENT",
    n[n.BACKGROUND_TASK_EVENT = 3] = "BACKGROUND_TASK_EVENT"
}(fe$1 || (fe$1 = {})),
function(e) {
    var t;
    (t = e.ShowType || (e.ShowType = {}))[t.UNKNOWN2 = 0] = "UNKNOWN2",
    t[t.PAGE = 1] = "PAGE"
}(he$2 || (he$2 = {}));
var Ee$1 = !0
  , Pe$1 = (new Date).valueOf();
function Se$1(e) {
    var t = e || Pe$1;
    return t ? G((new Date).valueOf() - t) : 0
}
var ke$1, Oe$1, Ue$1, be$1 = function(e, t) {
    var n, r;
    void 0 === t && (t = !1);
    var o = e.type
      , i = e.currentUrlPackage
      , a = e.referUrlPackage
      , s = e.name
      , c = void 0 === s ? "" : s
      , l = e.action
      , u = e.beginTime
      , p = e.params
      , d = e.contentPackage
      , f = e.status
      , h = e.actionType
      , m = e.auto
      , g = ((n = {
        status: f ? ge$1.ActionStatus[f] || ge$1.ActionStatus.UNKNOWN_STATUS : ge$1.ActionStatus.SUCCESS
    })[t ? "show_type" : "action_type"] = h ? ge$1.ActionType[h] || ge$1.ActionType.UNKNOWN_ACTION_TYPE : ge$1.ActionType.CLICK,
    n.url_package = i,
    n.refer_url_package = a,
    n[t ? "content_wrapper" : "content_package"] = d,
    n);
    if ("PV" === o) {
        var v = ge$1.SubAction.PAGE_ENTER
          , y = ge$1.PageShowAction.ENTER
          , _ = Ee$1
          , b = 0;
        switch (Ee$1 = !1,
        l) {
        case "leave":
            y = ge$1.PageShowAction.LEAVE,
            v = ge$1.SubAction.PAGE_LEAVE,
            b = Se$1(u),
            Pe$1 = void 0;
            break;
        case "enter":
            y = ge$1.PageShowAction.ENTER,
            v = ge$1.SubAction.PAGE_ENTER,
            Pe$1 = (new Date).valueOf();
            break;
        case "visible":
            y = ge$1.PageShowAction.RESUME,
            v = ge$1.SubAction.PAGE_RESUME,
            Pe$1 = (new Date).valueOf();
            break;
        case "hidden":
            y = ge$1.PageShowAction.LEAVE,
            v = ge$1.SubAction.PAGE_PAUSE,
            b = Se$1(u),
            Pe$1 = void 0
        }
        var E = m ? fe$1.ShowType.PAGE_AUTO : fe$1.ShowType.PAGE_CUSTOM;
        return t && (_ = void 0,
        E = he$2.ShowType.PAGE),
        {
            show_event: s$3({
                action: y,
                sub_action: v,
                type: E,
                first_load: _,
                time_cost: 0,
                stay_length: b
            }, g)
        }
    }
    return {
        show_event: s$3({
            action: t ? 0 : ge$1.PageShowAction.ENTER,
            type: t ? 0 : fe$1.ShowType.ELEMENT,
            sub_action: t ? 0 : ge$1.SubAction.PAGE_ENTER,
            element_package: (r = {},
            r[t ? "action2" : "action"] = c,
            r.params = JSON.stringify(p),
            r)
        }, g)
    }
}, Te$1 = function(e, t) {
    var n, r;
    void 0 === t && (t = !1);
    var o = e.sessionId
      , i = e.currentUrlPackage
      , a = e.referUrlPackage
      , s = e.name
      , c = e.params
      , l = e.type
      , u = e.contentPackage
      , p = e.status
      , d = e.taskType
      , f = e.operationDirection
      , h = ((n = {
        url_package: i,
        refer_url_package: a,
        element_package: (r = {},
        r[t ? "action2" : "action"] = s,
        r.params = JSON.stringify(c),
        r)
    })[t ? "content_wrapper" : "content_package"] = u,
    n);
    if (t) {
        var m = "USER_OPERATION" === d || "CLICK" === l && !d
          , g = l && ge$1.OperationType[l] || ge$1.OperationType.CLICK;
        return m ? {
            click_event: s$3({
                type: g,
                direction: f && ge$1.Direction[f] || ge$1.Direction.UNKNOWN2
            }, h)
        } : {
            task_event: s$3({
                action2: s,
                status: p && ge$1.TaskStatus[p] || ge$1.TaskStatus.UNKNOWN_STATUS
            }, h)
        }
    }
    return {
        task_event: s$3({
            type: d && fe$1.TaskEventType[d] || fe$1.TaskEventType.USER_OPERATION,
            status: p && ge$1.TaskStatus[p] || ge$1.TaskStatus.UNKNOWN_STATUS,
            operation_type: ge$1.OperationType[l] || ge$1.OperationType.CLICK,
            operation_direction: f && ge$1.Direction[f] || ge$1.Direction.UNKNOWN2,
            session_id: o
        }, h)
    }
}, Ne$1 = function(e) {
    var t = e.name
      , n = e.params
      , r = e.currentUrlPackage
      , o = e.referUrlPackage
      , i = c$3(e, ["name", "params", "currentUrlPackage", "referUrlPackage"]);
    return {
        key: t,
        value: JSON.stringify(s$3(s$3({
            url_package: r,
            refer_url_package: o
        }, n), i))
    }
}, Ae$1 = function(e) {
    var t = e.currentUrlPackage
      , n = e.referUrlPackage
      , r = e.options;
    return {
        video_stat_event: s$3(s$3({}, r), {
            url_package: t,
            refer_url_package: n
        })
    }
}, Ce = {}, we$1 = function(e) {
    try {
        if (h$4 && h$4.localStorage && "undefined" != typeof Storage && h$4.localStorage instanceof Storage) {
            var t = Number(function(e) {
                try {
                    if (h$4 && h$4.localStorage) {
                        var t = h$4.localStorage.getItem(e);
                        if (t)
                            try {
                                return JSON.parse(t)
                            } catch (n) {
                                return t
                            }
                    }
                } catch (n) {
                    return null
                }
                return null
            }(e)) || 0;
            return t + 1 > 1e8 && (t = 0),
            function(e, t) {
                try {
                    if (h$4 && h$4.localStorage)
                        return h$4.localStorage.setItem(e, JSON.stringify(t)),
                        !0
                } catch (n) {
                    return !1
                }
            }(e, t + 1),
            t
        }
    } catch (n) {}
    return Ce[e] || (Ce[e] = 0),
    Ce[e]++
}, Le$1 = (ke$1 = (new Date).getTimezoneOffset() / 60) <= 0 ? "GMT+".concat(T(-ke$1 + "", 2, "0"), ":00") : "GMT-".concat(T(ke$1 + "", 2, "0"), ":00"), Ie$1 = function() {
    function e(e, t) {
        void 0 === t && (t = !1),
        this.client_timestamp = G((new Date).valueOf()),
        this.client_increment_id = 0,
        this.session_id = d$3.sessionId,
        this.event_id = "",
        t || (this.time_zone = Le$1),
        Object.assign(this, e),
        this.genIncrementId()
    }
    return e.prototype.genIncrementId = function() {
        this.client_increment_id = this.isCustomStatEvent() ? we$1("WEBLOGGER_CUSTOM_INCREAMENT_ID_KEY") : we$1("WEBLOGGER_INCREAMENT_ID_KEY")
    }
    ,
    e.prototype.isCustomStatEvent = function() {
        return !(!this.stat_package || !("custom_stat_event"in this.stat_package))
    }
    ,
    e.prototype.getEventType = function() {
        if (this.event_package) {
            var e = this.event_package
              , t = e.task_event
              , n = e.show_event
              , r = e.click_event
              , o = e.custom_event;
            if (n)
                return "showEvent";
            if (r)
                return "clickEvent";
            if (t)
                return "taskEvent";
            if (o)
                return "customEvent"
        }
        return "customEvent"
    }
    ,
    e
}();
function Re$1(e, t, n) {
    var r;
    void 0 === n && (n = !1);
    var o, i = t.eventId, a = t.currentUrlPackage, s = t.referUrlPackage, c = t.contentPackage, l = t.name, u = t.params;
    switch (n && "RADAR" !== e && "CUSTOM" !== e && (a && (a.page2 = a.page,
    delete a.page),
    s && (s.page2 = s.page,
    delete s.page)),
    e) {
    case "PV":
    case "SHOW":
        return new Ie$1({
            event_package: be$1({
                type: e,
                status: t.status,
                currentUrlPackage: a,
                referUrlPackage: s,
                action: t.type,
                beginTime: t.beginTime,
                actionType: t.actionType,
                name: l,
                params: u,
                contentPackage: c,
                operationDirection: t.operationDirection,
                auto: t.auto
            }, n),
            event_id: i
        },n);
    case "CUSTOM":
    case "CUSTOM_STAT_EVENT":
        var p = Ne$1({
            name: l,
            params: u,
            currentUrlPackage: a,
            referUrlPackage: s
        });
        return new Ie$1(n ? {
            event_package: {
                custom_event: p
            },
            event_id: i
        } : {
            stat_package: {
                custom_stat_event: p
            },
            event_id: i
        },n);
    case "RADAR":
        return new Ie$1({
            stat_package: {
                custom_stat_event: Ne$1({
                    name: l,
                    params: u,
                    currentUrlPackage: a,
                    referUrlPackage: s
                })
            },
            event_id: i
        },n);
    case "HEART_BEAT_EVENT":
    case "LAUNCH_EVENT":
    case "APP_USAGE_STAT_EVENT":
    case "EXCEPTION_EVENT":
    case "DEVICE_STAT_EVENT":
        return new Ie$1({
            stat_package: (r = {},
            r[e.toLowerCase()] = (o = t,
            o.currentUrlPackage,
            o.referUrlPackage,
            o.taskType,
            c$3(o, ["currentUrlPackage", "referUrlPackage", "taskType"])),
            r)
        },n);
    case "VIDEO":
        return new Ie$1(n ? {
            stat_package: Ae$1({
                currentUrlPackage: a,
                referUrlPackage: s,
                options: u.params
            }),
            event_id: i
        } : {
            event_package: Te$1({
                type: e,
                status: t.status,
                taskType: t.taskType,
                sessionId: d$3.sessionId,
                currentUrlPackage: a,
                referUrlPackage: s,
                name: l,
                params: u.params,
                contentPackage: c
            }, n),
            event_id: i
        },n);
    default:
        return new Ie$1({
            event_package: Te$1({
                type: e,
                status: t.status,
                taskType: t.taskType,
                sessionId: d$3.sessionId,
                currentUrlPackage: a,
                referUrlPackage: s,
                name: l,
                params: u,
                contentPackage: c
            }, n),
            event_id: i
        },n)
    }
}
var xe, De$1 = (null === (Oe$1 = null == h$4 ? void 0 : h$4.navigator) || void 0 === Oe$1 ? void 0 : Oe$1.userAgent) || "", Ge$1 = function(e) {
    var t, n, r, o;
    if (void 0 === e && (e = null === (t = null == h$4 ? void 0 : h$4.navigator) || void 0 === t ? void 0 : t.userAgent),
    Ue$1 && e === De$1)
        return Ue$1;
    var i = "unknow"
      , a = /android/i
      , s = "Mac OS"
      , c = "Windows"
      , l = "Android"
      , u = "iPhone"
      , p = "iPad"
      , d = "Windows Phone"
      , f = "Linux";
    Ue$1 = {
        os: {
            name: i,
            version: i
        },
        model: i
    };
    try {
        var h = e.match(/\((.*?)\)/);
        if (!h)
            return a.test(e) && (Ue$1.os.name = l),
            Ue$1;
        var m = h[1] + ")"
          , g = m.split(";").map((function(e) {
            return e.trim()
        }
        ))
          , v = void 0
          , y = void 0
          , _ = void 0;
        if (e.indexOf(d) > -1)
            _ = v = d,
            (w = m.match(/Windows\sPhone\s(.*?)[;\)\s]/)) && (y = w[1]),
            _ = null === (n = g[g.length - 1]) || void 0 === n ? void 0 : n.replace(")", "");
        else if (a.test(e)) {
            v = l;
            var b = m.match(/android.*?;(.*?)build\//i);
            b && (_ = (_ = null === (r = b[1]) || void 0 === r ? void 0 : r.split(";").pop()) && _.trim());
            for (var E = 0; E < g.length; E++)
                if (a.test(g[E])) {
                    y = null === (o = g[E]) || void 0 === o ? void 0 : o.replace(a, ""),
                    _ || (_ = g[E + 1]);
                    break
                }
        } else if (e.indexOf(u) > -1 || e.indexOf(p) > -1)
            _ = e.indexOf(u) > -1 ? u : p,
            v = "iOS",
            (w = m.match(/OS\s(.*?)\slike/)) && (y = w[1]);
        else if (e.indexOf(s) > -1)
            _ = v = s,
            (w = m.match(/OS\sX\s(.*?)[;\)\s]/)) && (y = w[1]);
        else if (e.indexOf(c) > -1) {
            var w;
            _ = v = c,
            (w = m.match(/Windows\s(.*?)[;\)]/)) && (y = w[1])
        } else if (e.indexOf("Nokia") > -1) {
            v = "Symbian";
            var S = e.match(/Symbian.*?\/(.*?);/);
            S && (y = S[1]);
            var O = e.match(/Nokia(.*?)\//);
            O && (_ = O[1])
        } else
            m.indexOf(f) > -1 && (v = _ = f);
        Ue$1 = {
            os: {
                name: v || i,
                version: y && y.replace(/_/g, ".").trim() || i
            },
            model: _ || i
        }
    } catch (T) {}
    return Ue$1
};
function Ke() {
    return void 0 === xe && (xe = N$2() && m$3("kpn") || function() {
        if ("undefined" == typeof window)
            return "";
        for (var e = window.navigator.userAgent, t = [[/ Kwai\//, "KUAISHOU"], [/ ksthanos\//, "THANOS"], [/ ksNebula\//i, "NEBULA"]], n = 0; n < t.length; n++) {
            var r = t[n]
              , o = r[0]
              , i = r[1];
            if (o.exec(e))
                return i
        }
        return ""
    }() || ""),
    xe
}
var We$1, Be$1, Ve, Me$1 = function() {}, je$1 = {
    supportsPushState: function() {
        var e = h$4.navigator.userAgent;
        return (-1 === e.indexOf("Android 2.") && -1 === e.indexOf("Android 4.0") || -1 === e.indexOf("Mobile Safari") || -1 !== e.indexOf("Chrome") || -1 !== e.indexOf("Windows Phone")) && h$4.history && "pushState"in h$4.history
    },
    getUAInfo: Ge$1,
    getDefaultKpn: Ke
}, He$1 = function() {
    var e;
    return "function" == typeof (null === (e = null == h$4 ? void 0 : h$4.__yodaBridge__) || void 0 === e ? void 0 : e.invoke)
}, Je$1 = function(e, t) {
    return void 0 === t && (t = "tool"),
    u$4(void 0, void 0, void 0, (function() {
        var n;
        return p$3(this, (function(r) {
            switch (r.label) {
            case 0:
                return void 0 === We$1 ? [2, !1] : [4, We$1("tool.canIUse", {
                    namespace: t,
                    name: e
                })];
            case 1:
                return [2, (null == (n = r.sent()) ? void 0 : n.canUse) || !1]
            }
        }
        ))
    }
    ))
}, Ye$1 = function() {
    return Je$1("setClientLog")
}, Qe$1 = function(e, t) {
    return u$4(void 0, void 0, void 0, (function() {
        var n;
        return p$3(this, (function(r) {
            switch (r.label) {
            case 0:
                return r.trys.push([0, 2, , 3]),
                [4, We$1("tool.setClientLog", {
                    type: e,
                    data: t
                })];
            case 1:
                return [2, r.sent()];
            case 2:
                return n = r.sent(),
                O$2("[error 206]", "yoda.tool.setClientLog() 报错: ".concat(n.message)),
                [3, 3];
            case 3:
                return [2]
            }
        }
        ))
    }
    ))
}, ze$1 = {
    setClientLog: Qe$1,
    sendRadarLog: function(e) {
        return u$4(void 0, void 0, void 0, (function() {
            var t;
            return p$3(this, (function(n) {
                switch (n.label) {
                case 0:
                    return n.trys.push([0, 2, , 3]),
                    [4, We$1("tool.sendRadarLog", e)];
                case 1:
                    return [2, n.sent()];
                case 2:
                    return t = n.sent(),
                    O$2("[error 207]", "yoda.tool.sendRadarLog() 报错: ".concat(t.message)),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ))
    },
    sendWebLog: function(e) {
        return u$4(void 0, void 0, void 0, (function() {
            return p$3(this, (function(t) {
                try {
                    return [2, We$1("tool.sendWebLog", e)]
                } catch (n) {
                    O$2("[error 214]", "yoda.tool.sendWebLog() 报错: ".concat(n.message))
                }
                return [2]
            }
            ))
        }
        ))
    },
    sendSummarizedLog: function(e) {
        return u$4(void 0, void 0, void 0, (function() {
            var t;
            return p$3(this, (function(n) {
                switch (n.label) {
                case 0:
                    return n.trys.push([0, 2, , 3]),
                    [4, We$1("tool.sendSummarizedLog", e)];
                case 1:
                    return [2, n.sent()];
                case 2:
                    return t = n.sent(),
                    O$2("[error 208]", "yoda.tool.sendSummarizedLog() 报错: ".concat(t.message)),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ))
    },
    getWebviewLoadPerf: function(e, t) {
        return void 0 === e && (e = {}),
        u$4(void 0, void 0, void 0, (function() {
            var n;
            return p$3(this, (function(r) {
                switch (r.label) {
                case 0:
                    return r.trys.push([0, 2, , 3]),
                    [4, We$1("webview.getPageLoadData", e, t)];
                case 1:
                    return [2, r.sent()];
                case 2:
                    return n = r.sent(),
                    O$2("[error 209]", "yoda.webview.getPageLoadData() 报错: ".concat(n.message)),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ))
    },
    getKDSWebviewLoadPerf: function(e) {
        return void 0 === e && (e = {}),
        u$4(void 0, void 0, void 0, (function() {
            var t;
            return p$3(this, (function(n) {
                switch (n.label) {
                case 0:
                    return n.trys.push([0, 2, , 3]),
                    [4, We$1("system.getPageLoadData", e)];
                case 1:
                    return [2, n.sent()];
                case 2:
                    return t = n.sent(),
                    O$2("[error 209]", "yoda.system.getPageLoadData() 报错: ".concat(t.message)),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ))
    },
    isSupportBridgeLog: Ye$1,
    isSupportBridge: Je$1,
    invoke: We$1
}, Fe = {
    unknown: 0,
    none: 1,
    wifi: 2,
    "4g": 3,
    "3g": 4,
    "2g": 5,
    "5g": 7,
    "slow-2g": 5
};
!function(e) {
    e.CLICK = "CLICK",
    e.DOUBLE_CLICK = "DOUBLE_CLICK",
    e.TRIPLE_CLICK = "TRIPLE_CLICK",
    e.LONG_PRESS = "LONG_PRESS",
    e.PULL = "PULL",
    e.DRAG = "DRAG",
    e.SCALE = "SCALE",
    e.PULL_DOWN = "PULL_DOWN",
    e.PULL_UP = "PULL_UP",
    e.AUTO = "AUTO"
}(Be$1 || (Be$1 = {})),
function(e) {
    e.PV = "PV",
    e.SHOW = "SHOW",
    e.VIDEO = "VIDEO",
    e.CUSTOM = "CUSTOM",
    e.CUSTOM_EVENT = "CUSTOM_EVENT",
    e.RADAR = "RADAR"
}(Ve || (Ve = {}));
var qe$1 = function() {
    function e(e) {
        if (this.identity_package = {
            device_id: void 0,
            global_id: void 0,
            user_id: void 0,
            union_id: void 0,
            open_id: void 0,
            iu_id: void 0
        },
        this.app_package = {
            product: void 0,
            language: void 0,
            platform: void 0,
            container: "H5",
            package_name: void 0,
            product_name: void 0,
            version_name: void 0,
            channel: void 0,
            version_code: void 0
        },
        this.experiment = void 0,
        this.service_name = void 0,
        this.safety_id = void 0,
        this.sub_biz = void 0,
        this.device_package = {
            os_version: void 0,
            model: void 0,
            ua: void 0
        },
        this.need_encrypt = !1,
        this.network_package = {
            type: Fe.unknown
        },
        this.h5_extra_attr = {
            sdk_name: "webLogger",
            sdk_version: "3.10.45",
            sdk_bundle: "log.hybrid.js"
        },
        this.global_attr = {
            entry_tag: []
        },
        this.location_package = {
            country: void 0,
            province: void 0,
            city: void 0,
            county: void 0,
            street: void 0,
            latitude: void 0,
            longitude: void 0
        },
        this.update(e),
        this.app_package.version_name) {
            var t = this.app_package.version_name.lastIndexOf(".");
            this.app_package.version_code = +this.app_package.version_name.slice(t + 1) || 0
        }
        this.app_package.version_name || (this.app_package.version_name = void 0),
        this.app_package.version_code || (this.app_package.version_code = void 0)
    }
    return e.prototype.getH5ExtraAttr = function(e) {
        return Object.assign({}, this.h5_extra_attr, e)
    }
    ,
    e.prototype.update = function(e) {
        if ("object" == typeof e) {
            !function(e, t) {
                if (L$2(e) && L$2(t)) {
                    var n = function(e, t, n) {
                        L$2(e[n]) && L$2(t[n]) ? Object.assign(e[n], t[n]) : L$2(e[n]) || L$2(t[n]) || (e[n] = t[n])
                    };
                    for (var r in t)
                        if (e.hasOwnProperty(r))
                            n(e, t, r);
                        else
                            for (var o in e)
                                L$2(e[o]) && e[o].hasOwnProperty(r) && n(e[o], t, r)
                }
            }(this, e);
            var t = e.network_type;
            t && Fe[t] && (this.network_package.type = Fe[t])
        }
    }
    ,
    e.prototype.updateGlobalAttr = function(e) {
        Object.assign(this.global_attr || {}, e)
    }
    ,
    e.prototype.toJSON = function() {
        this.identity_package.user_id || (this.identity_package.user_id = void 0);
        var e = s$3(s$3({}, this), {
            toJSON: function() {
                return s$3(s$3({}, e), {
                    h5_extra_attr: JSON.stringify(e.h5_extra_attr),
                    global_attr: JSON.stringify(e.global_attr)
                })
            }
        });
        e.global_attr = s$3({}, this.global_attr),
        this.global_attr.entry_tag && this.global_attr.entry_tag.length ? e.global_attr.entry_tag = this.global_attr.entry_tag.slice() : delete e.global_attr.entry_tag,
        Object.keys(this.global_attr).length || delete e.global_attr;
        var t = this.location_package;
        return t && Object.keys(t).forEach((function(e) {
            void 0 === t[e] && delete t[e]
        }
        )),
        e
    }
    ,
    e
}()
  , Xe$1 = [["a7", "640x1136", ["iPhone 5", "iPhone 5s"]], ["a7", "1536x2048", ["iPad Air", "iPad Mini 2", "iPad Mini 3"]], ["a8", "640x1136", ["iPod touch (6th gen)"]], ["a8", "750x1334", ["iPhone 6"]], ["a8", "1242x2208", ["iPhone 6 Plus"]], ["a8", "1536x2048", ["iPad Air 2", "iPad Mini 4"]], ["a9", "640x1136", ["iPhone SE"]], ["a9", "750x1334", ["iPhone 6s"]], ["a9", "1242x2208", ["iPhone 6s Plus"]], ["a9x", "1536x2048", ["iPad Pro (1st gen 9.7-inch)"]], ["a9x", "2048x2732", ["iPad Pro (1st gen 12.9-inch)"]], ["a10", "750x1334", ["iPhone 7"]], ["a10", "1242x2208", ["iPhone 7 Plus"]], ["a10x", "1668x2224", ["iPad Pro (2th gen 10.5-inch)"]], ["a10x", "2048x2732", ["iPad Pro (2th gen 12.9-inch)"]], ["a11", "750x1334", ["iPhone 8"]], ["a11", "1242x2208", ["iPhone 8 Plus"]], ["a11", "1125x2436", ["iPhone X"]], ["a12", "828x1792", ["iPhone Xr"]], ["a12", "1125x2436", ["iPhone Xs"]], ["a12", "1242x2688", ["iPhone Xs Max"]], ["a12x", "1668x2388", ["iPad Pro (3rd gen 11-inch)"]], ["a12x", "2048x2732", ["iPad Pro (3rd gen 12.9-inch)"]]]
  , $e$1 = function() {
    try {
        var e = Ge$1()
          , t = N$2()
          , n = e.model || e.os.name || "unknown";
        if ("iOS" !== e.os.name || t)
            return n;
        var r = function() {
            for (var e = x$1(), t = [], n = 0, r = Xe$1; n < r.length; n++) {
                var o = r[n];
                e === o[1] && (t = t.concat(o[2]))
            }
            return t.length && t
        }();
        return r ? r.join(" or ") : n
    } catch (o) {
        return "unknown"
    }
}
  , Ze$1 = 0;
function et() {
    try {
        var e = Ge$1().os.name;
        return Ze$1 = e ? "Android" === e ? N$2() ? 6 : 8 : "iOS" === e ? N$2() ? 7 : 9 : 10 : 0
    } catch (t) {
        return 0
    }
}
function tt$1() {
    var e = "unknown"
      , t = null == h$4 ? void 0 : h$4.navigator
      , n = (null == t ? void 0 : t.connection) || (null == t ? void 0 : t.mozConnection) || (null == t ? void 0 : t.webkitConnection);
    return n && (e = n.type || n.effectiveType),
    e
}
var nt$2, rt = function(e) {
    function t(t) {
        var n = e.call(this, s$3({
            platform: et(),
            container: 10 === Ze$1 ? "WEB" : "H5",
            version_name: N$2() && m$3("appver", void 0, !0) || "",
            network_type: tt$1(),
            device_id: Y$1(),
            user_id: m$3("userId"),
            global_id: N$2() && m$3("egid") || "",
            app_package: {
                language: h$4.navigator.language
            },
            device_package: {
                os_version: Ge$1().os.version,
                model: $e$1(),
                ua: h$4.navigator.userAgent
            }
        }, t)) || this;
        return Object.assign(n.h5_extra_attr, {
            host_product: Ke(),
            resolution: x$1(),
            screen_width: G(h$4.screen.width),
            screen_height: G(h$4.screen.height),
            device_pixel_ratio: h$4.devicePixelRatio || 1,
            domain: h$4.location.origin,
            fromIframe: (null == h$4 ? void 0 : h$4.self) !== (null == h$4 ? void 0 : h$4.top)
        }, t.h5_extra_attr),
        delete n.location_package,
        n
    }
    return i$1(t, e),
    t.prototype.getVersionName = function() {
        return this.app_package.version_name
    }
    ,
    t.prototype.update = function(t) {
        e.prototype.update.call(this, t);
        var n = this.app_package.version_name;
        if ("string" == typeof n) {
            var r = n.lastIndexOf(".");
            this.app_package.version_code = +n.slice(r + 1) || 0,
            this.h5_extra_attr.app_version_name = n
        }
    }
    ,
    t.prototype.setAdditionalSeqIdPackage = function(e) {
        var t, n;
        this.additional_seq_id_package = {
            channel: 3,
            channel_seq_id: (n = "NORMAL",
            void 0 === n && (n = ""),
            we$1("".concat("WEBLOGGER_CHANNEL_SEQ_ID", "_").concat(n))),
            custom_type: e,
            custom_seq_id: (t = e,
            we$1("".concat("WEBLOGGER_V2_SEQ_ID", "_").concat(t)))
        }
    }
    ,
    t.prototype.increaseH5SeqId = function(e) {
        this.h5_extra_attr.client_timestamp = G((new Date).valueOf()),
        this.h5_extra_attr.seq_id = we$1(e ? "WEBLOGGER_H5_CUSTOM_SEQ_ID" : "WEBLOGGER_H5_SEQ_ID")
    }
    ,
    t
}(qe$1), at = function(e, t, n, r) {
    var o;
    void 0 === t && (t = {}),
    "string" != typeof e && (o = e.type),
    o = e.toUpperCase();
    var i = {};
    if ("string" == typeof t)
        i.contentPackage = r,
        "CUSTOM" === e ? (i.key = t,
        i.value = n) : (i.params = n,
        "PV" === e ? i.page = t : i.action = t);
    else if (i = t,
    ["CUSTOM", "CUSTOM_EVENT"].includes(o)) {
        var a = t;
        a.action && !a.key && (i.key = a.action),
        a.params && !a.value && (i.value = a.params)
    }
    return [o, i]
};
void 0 !== h$4 && ("object" != typeof h$4._WEBLOGGER && (h$4._WEBLOGGER = {
    _silenced: !1,
    constructors: [],
    instances: [],
    silence: function(e) {
        try {
            e ? sessionStorage.setItem("WEBLOGGER_SILENCED", "1") : sessionStorage.removeItem("WEBLOGGER_SILENCED"),
            h$4._WEBLOGGER.instances.forEach((function(t) {
                null == t || t.silence(e)
            }
            ))
        } catch (t) {}
    }
}),
nt$2 = h$4._WEBLOGGER);
var ot, it = !1, st = Math.random(), ct = function(e) {
    function t(t, n) {
        void 0 === t && (t = {});
        var r, o, i = e.call(this, t, n) || this;
        return i.beforeUnload = function(e) {
            if (!it) {
                for (var t in i.logger.drain(),
                i.plugins) {
                    var n = i.plugins[t];
                    "function" == typeof n.beforeUnload && n.beforeUnload(e)
                }
                it = !0,
                setTimeout((function() {
                    it = !1
                }
                ), 2e3)
            }
        }
        ,
        i.isBridge = t.bridgeMode && t.yoda && He$1(),
        i.logConfig.isBridge = i.isBridge,
        r = n && n.session_id || m$3("sid") || function() {
            var e = "";
            try {
                if (N$2()) {
                    if (e = m$3("session_id") || m$3("sid"))
                        return e
                } else
                    "undefined" != typeof sessionStorage && ((e = sessionStorage.getItem("WEBLOGGER_SESSIONID") || "") || (e = H(),
                    sessionStorage.setItem("WEBLOGGER_SESSIONID", e)))
            } catch (t) {
                e = H()
            }
            return e || H()
        }(),
        d$3.sessionId = r,
        i.isV2 = "v2" === i.logConfig.proto,
        i.getSampled(i.logConfig),
        i.presetBaseOption(i.baseOption),
        i.commonPackage = new rt(i.baseOption),
        i.logger = new me$1(i.logConfig,i.commonPackage),
        i.initYoda(),
        i.addPlugins(),
        U(h$4, "pagehide", i.beforeUnload),
        U(h$4, "beforeunload", i.beforeUnload),
        o = i,
        (null == nt$2 ? void 0 : nt$2.instances) && o && -1 === nt$2.instances.indexOf(o) && (nt$2.instances.push(o),
        nt$2._silenced && (null == o || o.silence(!0))),
        i
    }
    return i$1(t, e),
    t.prototype.getSampled = function(e) {
        var t = e || {}
          , n = t.sampleRateFn
          , r = t.sampleRate;
        "function" == typeof n ? this.sampled = !!n() : void 0 !== r && (this.sampled = st < Number(r))
    }
    ,
    t.prototype.presetBaseOption = function(e) {
        this.isBridge || (this.isV2 ? ("number" != typeof e.product && O$2("[error 101]", "请设置有效的 product 值，值类型为 number!"),
        delete e.product_name) : (e.product_name && "string" == typeof e.product_name || O$2("[error 100]", "请设置有效的 product_name 值，值类型为 string!"),
        delete e.product),
        e.user_id || (e.user_id = m$3("userId") || m$3("userName") || void 0,
        e.user_id || k$2("[warn 102]", "user_id 为空，请确定是否传入，如果是异步通过 updateCommonPackage 接口传入，可以忽略该提示!")),
        e.device_id || (e.device_id = Y$1(),
        e.device_id || O$2("[error 103]", "device_id 为空，请设置有效的设备 id!")),
        !e.global_id && N$2() && (e.global_id = m$3("egid") || ""))
    }
    ,
    Object.defineProperty(t.prototype, "yoda", {
        get: function() {
            return this.logConfig.yoda || (null == h$4 ? void 0 : h$4.KSYoda) || (null == h$4 ? void 0 : h$4.yoda)
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(t.prototype, "Utils", {
        get: function() {
            return {
                yoda: He$1() && this.yoda ? ze$1 : null,
                cookie: P$3,
                ua: je$1,
                io: {
                    sendData: pe$1
                }
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    t.prototype.initYoda = function() {
        var e, t = this;
        He$1() && this.yoda && (e = this.yoda,
        We$1 = "function" == typeof e ? e : e.invoke,
        u$4(void 0, void 0, void 0, (function() {
            var e;
            return p$3(this, (function(t) {
                switch (t.label) {
                case 0:
                    return t.trys.push([0, 2, , 3]),
                    [4, We$1("system.getDeviceInfo")];
                case 1:
                    return [2, t.sent()];
                case 2:
                    return e = t.sent(),
                    O$2("[error 209]", "yoda.system.getDeviceInfo() 报错: ".concat(e.message)),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        )).then((function(e) {
            (null == e ? void 0 : e.mod) && (t.commonPackage.device_package.model = e.mod)
        }
        )),
        u$4(void 0, void 0, void 0, (function() {
            var e;
            return p$3(this, (function(t) {
                switch (t.label) {
                case 0:
                    return t.trys.push([0, 2, , 3]),
                    [4, We$1("system.getAppInfo")];
                case 1:
                    return [2, t.sent()];
                case 2:
                    return e = t.sent(),
                    O$2("[error 209]", "yoda.system.getAppInfo() 报错: ".concat(e.message)),
                    [3, 3];
                case 3:
                    return [2]
                }
            }
            ))
        }
        )).then((function(e) {
            if ("object" == typeof e) {
                var n = e.did
                  , r = e.userId
                  , o = e.appver;
                n && (t.commonPackage.identity_package.device_id = n),
                r && !t.commonPackage.identity_package.user_id && (t.commonPackage.identity_package.user_id = r),
                o && (t.commonPackage.app_package.version_name = o)
            }
        }
        )))
    }
    ,
    t.prototype.initUrlPackage = function() {
        e.prototype.initUrlPackage.call(this);
        var t, n = this.logConfig.referer, r = "web";
        n ? (t = n.value,
        r = n.type && n.type || r) : "undefined" != typeof document && document.referrer && (t = document.referrer),
        t && this.updateReferUrlPackage(t, r)
    }
    ,
    t.prototype.updateCurrentUrlPackage = function(e, t) {
        var n;
        if (void 0 === e && (e = (null === (n = h$4.location) || void 0 === n ? void 0 : n.href) || ""),
        void 0 === t && (t = "web"),
        "object" == typeof e && !e.force && this.currentUrlPackage) {
            var r = e.page
              , o = void 0 === r ? this.currentUrlPackage.page : r
              , i = e.params
              , a = void 0 === i ? {} : i;
            if (o === this.currentUrlPackage.page)
                return this.currentUrlPackage.update(o, a)
        }
        this.currentUrlPackage = new Q$1(e,t,this.logConfig.urlMap),
        this.logConfig.attachUrl && this.currentUrlPackage.attachUrl()
    }
    ,
    t.prototype.updateReferUrlPackage = function(e, t) {
        void 0 === e && (e = this.currentUrlPackage),
        void 0 === t && (t = "web"),
        this.referUrlPackage = e instanceof Q$1 ? e : new Q$1(e,t,this.logConfig.urlMap)
    }
    ,
    Object.defineProperty(t.prototype, "isSendSampled", {
        get: function() {
            return void 0 === this.sampled || this.sampled || this.logger.isDebug
        },
        enumerable: !1,
        configurable: !0
    }),
    t.prototype.generateLog = function(e, t, n) {
        void 0 === n && (n = Re$1);
        var r, o = t, i = o.action, a = o.params, s = o.status, c = o.type, l = o.eventId, u = o.contentPackage, p = o.urlPage;
        u && (u = "string" == typeof u ? u : JSON.stringify(u));
        var d = "PV" === e;
        if (d) {
            var f = t
              , h = f.page
              , m = f.type;
            m || (t.type = m = "enter"),
            "enter" === m && h ? this.updateCurrentUrlPackage({
                page: h,
                params: a
            }) : this.currentUrlPackage.update(h, a)
        } else
            p && p.page && (r = {
                page: p.page,
                identity: p.identity || H(),
                params: K(p.params),
                page_type: this.currentUrlPackage.page_type
            });
        var g = {
            currentUrlPackage: r || this.currentUrlPackage.toJSON(),
            referUrlPackage: this.referUrlPackage ? this.referUrlPackage.toJSON() : void 0,
            contentPackage: u
        };
        if ("RADAR" !== e && (null == r || r.page.indexOf("http")),
        d) {
            var v = t.type;
            return n(e, s$3(s$3(s$3({}, t), {
                type: v
            }), g), this.isV2)
        }
        if ("SHOW" === e)
            return n(e, s$3(s$3(s$3({}, t), {
                name: i
            }), g), this.isV2);
        if ("VIDEO" === e)
            return n(e, s$3({
                params: t,
                name: "VIDEO"
            }, g), this.isV2);
        if ("RADAR" === e)
            return n(e, t, this.isV2);
        if (-1 !== ["CUSTOM", "RADAR", "CUSTOM_EVENT"].indexOf(e)) {
            var y = t
              , _ = y.key
              , b = y.value;
            return n("CUSTOM", s$3(s$3(s$3({}, t), {
                params: b,
                name: _
            }), g), this.isV2)
        }
        return n(e, s$3(s$3(s$3({}, t), {
            params: a,
            status: s,
            taskType: c,
            eventId: l,
            name: i
        }), g), this.isV2)
    }
    ,
    t.prototype.collect = function(e, t, n, r) {
        var o = at(e, t, n, r)
          , i = o[0]
          , a = o[1];
        return this.send(i, a, !1)
    }
    ,
    t.prototype.sendImmediately = function(e, t, n, r) {
        var o = at(e, t, n, r)
          , i = o[0]
          , a = o[1];
        return this.send(i, a, !0)
    }
    ,
    t.prototype.send = function(e, t, n) {
        if (!this._silenced) {
            B(e, t, this.currentUrlPackage);
            var r = this.generateLog(e, t);
            if (this.emit("event", {
                type: e,
                action: null == t ? void 0 : t.action,
                log: r
            }),
            "RADAR" === e)
                return this.logger.sendRadar(r, null == t ? void 0 : t.serviceName);
            if ((!this.isV2 || !this.logConfig.forbidV2HttpUrlPage || I$1(this.currentUrlPackage.page)) && this.isSendSampled) {
                var o = "object" == typeof t && t.callback || void 0;
                this.logger.send(r, !!n, o)
            }
        }
    }
    ,
    t.prototype.destroy = function() {
        e.prototype.destroy.call(this),
        b$4(h$4, "pagehide", this.beforeUnload),
        b$4(h$4, "beforeunload", this.beforeUnload),
        function(e) {
            if (null == nt$2 ? void 0 : nt$2.instances) {
                var t = nt$2.instances.indexOf(e);
                -1 !== t && nt$2.instances.splice(t, 1)
            }
        }(this)
    }
    ,
    t.prototype.silence = function(e) {
        this._silenced = e
    }
    ,
    t.Logger = me$1,
    t
}(j);
!function(e) {
    e[e.INIT = -1] = "INIT",
    e[e.CHECKING = 0] = "CHECKING",
    e[e.READY = 1] = "READY",
    e[e.DISABLED = 2] = "DISABLED"
}(ot || (ot = {}));
var ut, pt = function() {
    try {
        if (He$1())
            return {
                invoke: invoke,
                version: version
            }
    } catch (e2) {}
}, lt = function(e) {
    function t(t, n) {
        var r = e.call(this, s$3(s$3({}, t), {
            yoda: pt(),
            bridgeMode: !(null == t ? void 0 : t.disableBridge)
        }), n) || this;
        return r.yodaStatus = ot.INIT,
        r.entered = "",
        (null == t ? void 0 : t.disableBridge) || !He$1() ? r.yodaStatus = ot.DISABLED : r.checkSupportBridge(),
        r.waitYodaQueue || (r.waitYodaQueue = []),
        r
    }
    return i$1(t, e),
    t.prototype.checkSupportBridge = function() {
        return u$4(this, void 0, void 0, (function() {
            var e, t = this;
            return p$3(this, (function(n) {
                switch (n.label) {
                case 0:
                    return [4, Ye$1()];
                case 1:
                    return e = n.sent(),
                    this.yodaStatus = e ? ot.READY : ot.DISABLED,
                    this.waitYodaQueue.forEach((function(n) {
                        var r = n.type
                          , o = n.options
                          , i = n.immediately;
                        e ? t.sendByBridge(r, o, i) : t.sendByHttp(r, o, i)
                    }
                    )),
                    this.waitYodaQueue = [],
                    [2]
                }
            }
            ))
        }
        ))
    }
    ,
    t.prototype.sendByBridge = function(e, t, n) {
        var r, o;
        B(e, t, this.currentUrlPackage);
        var i = this.logConfig
          , a = i.disablePV
          , s = i.biz
          , c = t
          , l = c.contentPackage
          , u = c.disablePV
          , p = c.bridgeFields
          , d = void 0 === p ? {} : p
          , f = c.urlPage
          , h = a || u;
        l && (l = "string" == typeof l ? l : JSON.stringify(l));
        var m = "addTaskEvent"
          , g = "PV" === e;
        if (g) {
            if (h)
                return;
            var v = t
              , y = v.page
              , _ = v.type
              , b = v.params
              , E = v.coPage
              , w = v.category;
            if (_ || (t.type = _ = "enter"),
            "leave" === _ && this.currentUrlPackage.coPage && C())
                return void Qe$1("closeCoPage", s$3(s$3({}, t), this.currentUrlPackage));
            if (-1 === ["enter", "visible"].indexOf(_))
                return;
            if ("enter" === _) {
                var S = y || this.currentUrlPackage.page;
                this.updateCurrentUrlPackage({
                    page: S,
                    params: y ? b : this.currentUrlPackage.params,
                    force: !0
                }),
                E && (this.currentUrlPackage.coPage = E),
                w && (this.currentUrlPackage.category = w),
                this.entered = S
            } else
                y === this.entered && this.currentUrlPackage.update(y, b);
            if (!I$1(this.currentUrlPackage.page))
                return;
            m = "setCurrentPage"
        }
        var O = !!this.currentUrlPackage.coPage
          , T = (null == f ? void 0 : f.page) && !g ? {
            page: f.page,
            identity: f.identity,
            params: K(f.params),
            page_type: this.currentUrlPackage.page_type
        } : s$3(s$3({}, this.currentUrlPackage.toJSON()), {
            coPage: O
        })
          , A = function(e, t) {
            var n = t
              , r = n.action
              , o = n.params
              , i = n.eventId
              , a = n.contentPackage
              , s = n.currentUrlPackage
              , c = n.status
              , l = void 0 === c ? "SUCCESS" : c;
            n.name;
            var u, p = n.feedLogCtx;
            if ("PV" === e) {
                var d = t
                  , f = d.type
                  , h = d.beginTime;
                return s$3(s$3({}, s), {
                    actionType: f,
                    contentPackage: a,
                    status: l,
                    beginTime: h,
                    eventId: i,
                    pageType: Me$1() ? "NATIVE" : "H5"
                })
            }
            if (s && (u = {
                page: s.page,
                params: s.params,
                identity: s.identity,
                coPage: s.coPage
            }),
            ["RADAR", "CUSTOM", "CUSTOM_EVENT"].includes(e)) {
                var m = t
                  , g = m.key
                  , v = m.value
                  , y = m.biz;
                return {
                    key: g,
                    value: JSON.stringify(s$3(s$3({}, v), {
                        url_package: s
                    })),
                    biz: y,
                    eventId: i,
                    urlPage: u
                }
            }
            var _ = {
                action: r,
                params: JSON.stringify(o),
                contentPackage: a,
                feedLogCtx: p,
                eventId: i,
                urlPage: u
            };
            if ("SHOW" !== e) {
                var b = t.type;
                Object.assign(_, {
                    type: b || "USER_OPERATION",
                    status: l || "UNKNOWN_STATUS",
                    operationType: e,
                    operationDirection: "UNKNOWN2"
                })
            }
            return _
        }(e, s$3(s$3({
            biz: s
        }, t), {
            contentPackage: l,
            currentUrlPackage: h ? void 0 : T
        }))
          , R = -1 !== ["CUSTOM", "RADAR", "CUSTOM_EVENT"].indexOf(e);
        this.commonPackage.increaseH5SeqId(R);
        var k = this.baseOption || {}
          , P = k.service_name
          , $ = k.sub_biz
          , I = k.need_encrypt;
        A.h5ExtraAttr = JSON.stringify(this.commonPackage.getH5ExtraAttr({
            bridge_info: (null === (o = null === (r = this.logConfig) || void 0 === r ? void 0 : r.yoda) || void 0 === o ? void 0 : o.version) || version || !0,
            coPage: O
        })),
        A.realtime = !!n,
        A.serviceName = P || "",
        A.subBiz = $ || "",
        A.needEncrypt = I || !1,
        A.container = Me$1() ? "REACT_NATIVE" : "H5",
        "SHOW" === e ? m = "addElementShowEvent" : R && (m = "CUSTOM_EVENT" === e || this.logConfig.customStatToCustom ? "addCustomEvent" : "addCustomStatEvent"),
        Qe$1(m, s$3(s$3({}, d), A))
    }
    ,
    t.prototype.updateCurrentUrlPackage = function(e, t) {
        var n;
        if (void 0 === e && (e = (null === (n = h$4.location) || void 0 === n ? void 0 : n.href) || ""),
        void 0 === t && (t = "web"),
        "object" == typeof e && !e.force && this.currentUrlPackage) {
            var r = e.page
              , o = void 0 === r ? this.currentUrlPackage.page : r
              , i = e.params
              , a = void 0 === i ? {} : i;
            if (!o || o === this.currentUrlPackage.page) {
                this.currentUrlPackage.update(o, a);
                var s = this.entered === o;
                return void (this.yodaStatus !== ot.DISABLED && s && this.send("PV", {
                    type: "visible",
                    page: o,
                    params: a
                }, !0))
            }
        }
        this.currentUrlPackage = new Q$1(e,t,this.logConfig.urlMap),
        this.logConfig.attachUrl && this.currentUrlPackage.attachUrl()
    }
    ,
    t.prototype.sendByHttp = function(t, n, r) {
        return e.prototype.send.call(this, t, n, r)
    }
    ,
    t.prototype.send = function(e, t, n) {
        var r = this.logConfig
          , o = r.enableV3CustomEvent
          , i = r.openHttpSender;
        return "CUSTOM" === e && o || this.yodaStatus === ot.DISABLED || !He$1() ? this.sendByHttp(e, t, n) : (i && this.sendByHttp(e, t, n),
        this.yodaStatus === ot.INIT && (this.yodaStatus = ot.CHECKING),
        this.yodaStatus === ot.CHECKING || void 0 === this.yodaStatus ? (S$3("[weblogger]: waiting yoda ready"),
        this.waitYodaQueue || (this.waitYodaQueue = []),
        void this.waitYodaQueue.push({
            type: e,
            options: t,
            immediately: n
        })) : this.sendByBridge(e, t, n))
    }
    ,
    t
}(ct);
ut = lt,
void 0 !== h$4._GLOBAL_KS_WEBLOGGER_ ? h$4._GLOBAL_KS_WEBLOGGER_.Factory = ut : h$4.Weblog = ut,
(null == nt$2 ? void 0 : nt$2.constructors) && ut && -1 === nt$2.constructors.indexOf(ut) && (ut._classId = nt$2.constructors.length,
nt$2.constructors.push(ut)),
function() {
    if (null == nt$2 ? void 0 : nt$2.silence)
        try {
            nt$2._silenced = !!sessionStorage.getItem("WEBLOGGER_SILENCED")
        } catch (e2) {}
}();
var e$1 = function() {
    return (e$1 = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
};
function t(e, t) {
    var n = "function" == typeof Symbol && e[Symbol.iterator];
    if (!n)
        return e;
    var r, o, i = n.call(e), a = [];
    try {
        for (; (void 0 === t || 0 < t--) && !(r = i.next()).done; )
            a.push(r.value)
    } catch (s) {
        o = {
            error: s
        }
    } finally {
        try {
            r && !r.done && (n = i.return) && n.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return a
}
function n(e, t, n) {
    if (2 === arguments.length)
        for (var r, o = 0, i = t.length; o < i; o++)
            !r && o in t || ((r = r || Array.prototype.slice.call(t, 0, o))[o] = t[o]);
    return e.concat(r || Array.prototype.slice.call(t))
}
var s$1, u$2, r$1 = console, o$1$1 = "ksurl.cn/csHfgepO, radar:", i = r$1.log.bind(r$1, o$1$1), a$3 = r$1.warn.bind(r$1, o$1$1), c$2 = r$1.error.bind(r$1, o$1$1), l$2 = function() {
    function e() {
        for (var e, r = [], o = 0; o < arguments.length; o++)
            r[o] = arguments[o];
        this.middlewares = [],
        (e = this.middlewares).push.apply(e, n([], t(r), !1))
    }
    return e.prototype.use = function() {
        for (var e, r = [], o = 0; o < arguments.length; o++)
            r[o] = arguments[o];
        var i = this.middlewares.pop();
        (e = this.middlewares).push.apply(e, n([], t(r), !1)),
        this.middlewares.push(i)
    }
    ,
    e.prototype.invoke = function(e) {
        return r = this.middlewares,
        t = e,
        n = -1,
        function e(o) {
            if (o <= n)
                return new Error("`next` 被重复调用");
            var i = r[n = o];
            if (i = o === r.length ? undefined : i)
                try {
                    return i(t, e.bind(null, o + 1))
                } catch (a) {
                    return a
                }
        }(0);
        var t, n, r
    }
    ,
    e
}(), f$4 = ((u$2 = s$1 = s$1 || {}).LOAD = "load",
u$2.RES = "resource",
u$2.API = "api",
u$2.ERROR = "error",
u$2.SDK_ERROR = "sdk_error",
u$2.CUSTOM = "custom",
u$2.BATCH = "batch",
u$2.EVENT = "event",
u$2.BLOOD = "blood",
u$2.RUNTIME = "runtime",
function() {
    function e(e) {
        void 0 === e && (e = {});
        var t = this;
        this.broadcastSampleFb = function() {
            if (2 === (null == (e = t.core) ? void 0 : e.getWhiteUserStatus()))
                return t.sampling = 1,
                void (t.isHit = !0);
            var e = t.getSample(t.baseOptions.sampling);
            e !== t.sampling && (t.sampling = e,
            t.sampling && (t.isHit = t.samplingControl(t.sampling)))
        }
        ,
        void 0 === e && nt$1("100"),
        e.key || nt$1("101"),
        !e.core || "object" == typeof e.core.sampleData && "function" == typeof e.core.collect || nt$1("121"),
        this.baseOptions = e,
        this.key = e.key,
        this.version = e.version,
        this.name = e.name,
        this.isHit = !1,
        e.core && this.updateCore(e.core)
    }
    return e.prototype.updateCore = function(e) {
        var t;
        "object" == typeof e.sampleData && "function" == typeof e.collect || nt$1("121"),
        null != (t = this.core) && t.broadcastSample.off(this.broadcastSampleFb),
        this.core = e,
        this.sampling = this.getSample(this.baseOptions.sampling),
        this.sampling && (this.isHit = this.samplingControl(this.sampling)),
        null != (e = null == (t = this.core) ? void 0 : t.broadcastSample) && e.on(this.broadcastSampleFb)
    }
    ,
    e.prototype.getSample = function(e) {
        var t = null != (t = null == (t = this.core) ? void 0 : t.sampleData.core) ? t : 1;
        if (this.key === s$1.LOAD)
            return t;
        if ("number" != typeof (e = void 0 === e ? 1 : e) || e < 0 || 1 < e)
            return a$3("102", "".concat(this.key, "，采用Core的采样率").concat(null == (n = this.core) ? void 0 : n.sampleData.core)),
            t;
        var n = null != (n = this.core) && n.isInYoda ? void 0 === (null == (n = this.core) ? void 0 : n.sampleData[this.key]) ? 1 : this.core.sampleData[this.key] : e;
        return t && t < n ? (a$3("115", "".concat(this.key)),
        t) : n
    }
    ,
    e.prototype.samplingControl = function(e) {
        var t;
        return !(null == (t = this.core) || !t.sampleData.isHit) && (null == (t = this.core) ? void 0 : t.samplingControl(e / this.core.sampleData.core))
    }
    ,
    e.prototype.baseCollect = function(e) {
        var t;
        if (this.core) {
            if (this.isHit || 1 !== (null == (t = this.core) ? void 0 : t.getWhiteUserStatus())) {
                var n = e.value || {};
                n = Object.keys(n).filter((function(e) {
                    return null !== n[e] && void 0 !== n[e]
                }
                )).reduce((function(e, t) {
                    return e$1(e$1({}, e), ((e = {})[t] = n[t],
                    e))
                }
                ), {});
                try {
                    this.core.collect(e.key || this.key, e$1(e$1({
                        collect_version: this.version,
                        collect_name: this.name
                    }, e.dimension), {
                        sample_rate: this.sampling
                    }), n, e[P$1])
                } catch (r) {
                    a$3("126")
                }
            }
        } else
            a$3("110", "".concat(this.key))
    }
    ,
    e
}());
function p$2() {
    var e, t = "undefined" != typeof window ? window.performance : null;
    return t && t.timing ? "function" == typeof t.timing.toJSON ? ((e = t.timing.toJSON()) && !e.redirectStart && (e.redirectStart = e.navigationStart),
    e) : t.timing : null
}
var d$2 = ["//wlog.kuaishou.com/rest/n/log/web/collect", "/rest/wd/common/log/collect/misc2", "/rest/wd/common/log/collect/radar", "/rest/kd/log/collect", "//da-radar-plus-api.ksapisrv.com"]
  , m$2 = window
  , g$4 = "__RADAR_PERFORMANCE_TIMING_"
  , b$3 = "__radarSeedStore__"
  , w = "isCoreReady"
  , S$2 = "radarSessionId"
  , x = "resource"
  , O$1 = "error"
  , k$1 = "event"
  , A$1 = "dimension"
  , M = "projectId"
  , N$1 = "radar_init_time"
  , P$1 = "commonData"
  , V = "queue"
  , X = {
    start_time: {
        custom: function(e, t) {
            return Math.round(t.startTime)
        }
    },
    fetch_start: {
        custom: function(e, t) {
            return Math.round(t.fetchStart)
        }
    },
    dns: {
        end: "domainLookupEnd",
        start: "domainLookupStart",
        cachedSkip: !0,
        crossOriginSkip: !0
    },
    tcp: {
        end: "connectEnd",
        start: "connectStart",
        cachedSkip: !0,
        crossOriginSkip: !0
    },
    ssl: {
        custom: function(e, t) {
            return t.connectEnd && t.secureConnectionStart ? t.connectEnd - t.secureConnectionStart : null
        }
    },
    ttfb: {
        end: "responseStart",
        start: "requestStart",
        cachedSkip: !0,
        crossOriginSkip: !0
    },
    trans: {
        end: "responseEnd",
        start: "responseStart",
        cachedSkip: !0,
        crossOriginSkip: !0
    },
    fb: {
        end: "responseStart",
        start: "fetchStart",
        cachedSkip: !0,
        crossOriginSkip: !0
    },
    total: {
        end: "responseEnd",
        start: "fetchStart"
    },
    size: {
        custom: function(e, t) {
            return t.encodedBodySize
        },
        cachedSkip: !0,
        crossOriginSkip: !0
    },
    protocol: {
        custom: function(e, t) {
            return t.nextHopProtocol
        }
    },
    file: {
        custom: function(e, t) {
            return t.name
        }
    },
    res_type: {
        custom: function(e, t) {
            return t.initiatorType
        }
    },
    cached: {
        custom: function(e, t) {
            return 0 === t.transferSize || 0 === t.duration || null == t.transferSize && (0 === t.domainLookupStart || t.responseStart === t.fetchStart)
        },
        crossOriginSkip: !0
    },
    has_timing_allow: {
        custom: function(e, t) {
            return te(t)
        }
    }
}
  , J = /^(https?:)?\/\//;
function z$1(e, t) {
    if (!e)
        return !1;
    var n = e.replace(J, "");
    return t.some((function(e) {
        return 0 <= n.indexOf(e.replace(J, ""))
    }
    ))
}
function F$1(e) {
    if ("string" != typeof e)
        return "";
    try {
        var t = e.lastIndexOf(".");
        return e.substr(t + 1)
    } catch (n) {
        return ""
    }
}
function Y(e) {
    return "object" == typeof e && Object.keys(e).every((function(t) {
        return "number" == typeof e[t]
    }
    ))
}
function $(e) {
    return "function" == typeof e
}
function Q(e) {
    return e && $(e.then) && $(e.catch)
}
var Z = Array.prototype.slice;
function ee(e) {
    return Z.call(e)
}
function te(e) {
    return void 0 === e.nextHopProtocol ? null : "" !== e.nextHopProtocol
}
function ne(e) {
    return "resource" === e.entryType ? "fetch" !== (null == e ? void 0 : e.initiatorType) && "xmlhttprequest" !== (null == e ? void 0 : e.initiatorType) || "js" === F$1(e.name) || "css" === F$1(e.name) ? "resource" : "api" : "other"
}
function oe$1() {
    for (var e = arguments, t = e[0], n = 1; n < e.length; n++) {
        var r = e[n];
        if (r)
            for (var o in r)
                t[o] = r[o]
    }
    return t
}
function ie$1(e, t, n) {
    return void 0 === n && (n = {}),
    (Object.assign || oe$1)({}, e, t, n)
}
var ce = 1e3;
function se(e) {
    return Array.from(e.slice(-8)).map((function(e) {
        return e.toUpperCase().charCodeAt(0)
    }
    )).join("")
}
function ue(e, t) {
    for (var n = []; t--; ) {
        var r = Math.floor(Math.random() * e.length);
        n.push(e[r])
    }
    return n.join("")
}
function le(e) {
    return e = ["".concat(3), "".concat(se(e)), "".concat(ue("123456789", 8)), "".concat(Date.now()), "".concat(ce++)],
    btoa(e.join("."))
}
function fe(e, t) {
    var n = {};
    return Object.keys(e).forEach((function(r) {
        var o = pe(r, e, t);
        null != o && (n[r] = o)
    }
    )),
    n
}
function pe(e, t, n) {
    var r = t[e];
    if (r || nt$1("129，".concat(e)),
    (!r.crossOriginSkip || te(n)) && (!r.cachedSkip || !pe("cached", t, n)))
        return "function" == typeof r.custom ? r.custom(e, n) : (t = r.end,
        e = r.start,
        !r.notCatchIfUndefined || void 0 !== n[t] && void 0 !== n[e] ? (+n[t] || 0) - (+n[e] || 0) : void 0)
}
function de$1(e, t, n, r) {
    return e.addEventListener(t, n, r)
}
function he$1(e, t, n, r) {
    return e.removeEventListener(t, n, r)
}
function me(e) {
    return e.message || null != e.lineno
}
var ve = "ktrace-str";
function ye(e) {
    return "__radar_".concat(e = void 0 === e ? "" : e).concat(Math.random().toString(36).substring(2, 8))
}
function ge(e) {
    try {
        var t = e.split("|");
        if (8 !== t.length || "seqn" !== t[7].split(",")[1].split(":")[0])
            return;
        var n = t[7].split(",")[1].split(":")[1];
        return {
            trace_id: t[1],
            ktrace_segment_id: t[2],
            sequence_number: Number(n),
            ktrace_service_name: t[4],
            ktrace_biz_name: t[5]
        }
    } catch (r) {
        return
    }
}
function be(e, t, n) {
    var r = window.XMLHttpRequest;
    return r ? (window.XMLHttpRequest = function() {
        var o, i, a, s, c, l = new r, u = {
            id: ye()
        }, p = (l._radarResponse = {},
        function() {
            l._radarResponse.status = l.status,
            l._radarResponse.statusText = l.statusText;
            var e, t, n, r = function(e, t) {
                switch (null == t && (t = {}),
                typeof e) {
                case "object":
                    var n, r = [];
                    for (n in e) {
                        var o = e[n]
                          , i = n.toLowerCase();
                        r.push("".concat(i, ":\t").concat(o))
                    }
                    return r.join("\n") + "\n";
                case "string":
                    for (var a = 0, s = (r = e.split("\n")).length; a < s; a++) {
                        var c = r[a];
                        /([^:]+):\s*(.+)/.test(c) && (c = null != (c = RegExp.$1) ? c.toLowerCase() : void 0,
                        o = RegExp.$2,
                        c && null == t[c] && (t[c] = o))
                    }
                    return t
                }
            }(l.getAllResponseHeaders());
            for (e in r)
                n = r[e],
                l._radarResponse && l._radarResponse.headers && !l._radarResponse.headers[e] && (t = e.toLowerCase(),
                l._radarResponse.headers[t] = n)
        }
        );
        function d(e) {
            if ("function" == typeof t) {
                switch (p(),
                function() {
                    if (l.responseType && "text" !== l.responseType)
                        "document" === l.responseType ? (l._radarResponse.xml = l.responseXML,
                        l._radarResponse.data = l.responseXML) : l._radarResponse.data = l.response;
                    else {
                        l._radarResponse.text = l.responseText,
                        l._radarResponse.data = l.responseText;
                        try {
                            l._radarResponse.xml = l.responseXML
                        } catch (e) {}
                    }
                    "responseURL"in l && (l._radarResponse.finalUrl = l.responseURL)
                }(),
                e.type) {
                case "error":
                case "timeout":
                    u.error_occurred = !0;
                    break;
                case "load":
                case "abort":
                    u.error_occurred = !1
                }
                t(u, l._radarResponse)
            }
            l.removeEventListener("abort", d),
            l.removeEventListener("load", d),
            l.removeEventListener("error", d),
            l.removeEventListener("timeout", d)
        }
        return l.addEventListener("abort", d),
        l.addEventListener("load", d),
        l.addEventListener("error", d),
        l.addEventListener("timeout", d),
        "function" == typeof l.abort && (i = l.abort,
        l.abort = function() {
            return this._radarResponse.aborted = !0,
            i.apply(this, ee(arguments))
        }
        ),
        "function" == typeof l.setRequestHeader && (a = l.setRequestHeader,
        l.setRequestHeader = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            return u.headers[e[0]] = e[1],
            a.apply(this, e)
        }
        ),
        "function" == typeof l.open && (s = l.open,
        l.open = function(e, t, n, r, o) {
            var i = t;
            try {
                i = new URL(t,location.href).href
            } catch (c) {}
            var a = [].slice.call(arguments);
            return u = e$1({
                method: e,
                url: i,
                async: n,
                user: r,
                pass: o,
                headers: {}
            }, u),
            this._radarResponse.headers = {},
            s.apply(this, a)
        }
        ),
        "function" == typeof l.send && (c = l.send,
        l.send = function() {
            n && ((r = u.headers && u.headers["ktrace-str"]) ? t = !0 : (r = n(u)) && l.setRequestHeader(ve, r),
            o = ge(r),
            Object.assign(u, o, {
                has_ktrace_str: t
            }));
            var t, r = [].slice.call(arguments);
            return "function" == typeof e && (u._config = r[0],
            e(u)),
            c.apply(this, r)
        }
        ),
        l
    }
    ,
    ["DONE", "HEADERS_RECEIVED", "LOADING", "OPENED", "UNSENT"].forEach((function(e) {
        window.XMLHttpRequest[e] = r[e]
    }
    )),
    window.XMLHttpRequest.prototype = r.prototype,
    function() {
        r && (window.XMLHttpRequest = r)
    }
    ) : (c$2("118"),
    !1)
}
var we = ["application/json", "text/html", "text/plain"];
function _e(e, t, n) {
    var r = "function" == typeof importScripts ? self : window
      , o = r.fetch;
    return r.fetch = function(r, i) {
        var a, s = this, c = "string" == typeof r || r instanceof URL ? new Request(r,i) : r, l = (c.id = ye(),
        c.clone()), u = (n && (u = null,
        (i = void 0 === i ? {} : i).headers && (i.headers instanceof Headers ? u = i.headers.get(ve) : "[object Object]" === Object.prototype.toString.call(i.headers) && (u = i.headers[ve])),
        u ? c.has_ktrace_str = !0 : u = n(c),
        a = {},
        u && (a[ve] = u),
        i.headers = Object.assign({}, a, i.headers),
        a = ge(u),
        Object.assign(c, a)),
        "function" == typeof e && e(c),
        o(r, i)), p = null, d = null, f = !1;
        return u.then((function(e) {
            var t, n = null == (t = e.headers) ? void 0 : t.get("content-type");
            return n && we.some((function(e) {
                return -1 < n.indexOf(e)
            }
            )) ? (f = !0,
            t = e.clone(),
            p = t.clone(),
            t.clone().text()) : (p = e,
            "[object Object]")
        }
        )).then((function(e) {
            return t = s,
            n = void 0,
            r = function() {
                return n = this,
                r = function(t) {
                    switch (t.label) {
                    case 0:
                        d = e,
                        t.label = 1;
                    case 1:
                        return t.trys.push([1, 3, , 4]),
                        [4, l.text()];
                    case 2:
                        return [2, t.sent()];
                    case 3:
                        return t.sent(),
                        [2, "Radar: Request.text()失败"];
                    case 4:
                        return [2]
                    }
                }
                ,
                s = {
                    label: 0,
                    sent: function() {
                        if (1 & a[0])
                            throw a[1];
                        return a[1]
                    },
                    trys: [],
                    ops: []
                },
                c = {
                    next: t(0),
                    throw: t(1),
                    return: t(2)
                },
                "function" == typeof Symbol && (c[Symbol.iterator] = function() {
                    return this
                }
                ),
                c;
                function t(e) {
                    return function(t) {
                        var c = [e, t];
                        if (o)
                            throw new TypeError("Generator is already executing.");
                        for (; s; )
                            try {
                                if (o = 1,
                                i && (a = 2 & c[0] ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i),
                                0) : i.next) && !(a = a.call(i, c[1])).done)
                                    return a;
                                switch (i = 0,
                                (c = a ? [2 & c[0], a.value] : c)[0]) {
                                case 0:
                                case 1:
                                    a = c;
                                    break;
                                case 4:
                                    return s.label++,
                                    {
                                        value: c[1],
                                        done: !1
                                    };
                                case 5:
                                    s.label++,
                                    i = c[1],
                                    c = [0];
                                    continue;
                                case 7:
                                    c = s.ops.pop(),
                                    s.trys.pop();
                                    continue;
                                default:
                                    if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === c[0] || 2 === c[0])) {
                                        s = 0;
                                        continue
                                    }
                                    if (3 === c[0] && (!a || c[1] > a[0] && c[1] < a[3])) {
                                        s.label = c[1];
                                        break
                                    }
                                    if (6 === c[0] && s.label < a[1]) {
                                        s.label = a[1],
                                        a = c;
                                        break
                                    }
                                    if (a && s.label < a[2]) {
                                        s.label = a[2],
                                        s.ops.push(c);
                                        break
                                    }
                                    a[2] && s.ops.pop(),
                                    s.trys.pop();
                                    continue
                                }
                                c = r.call(n, s)
                            } catch (l) {
                                c = [6, l],
                                i = 0
                            } finally {
                                o = a = 0
                            }
                        if (5 & c[0])
                            throw c[1];
                        return {
                            value: c[0] ? c[1] : void 0,
                            done: !0
                        }
                    }
                }
                var n, r, o, i, a, s, c
            }
            ,
            new (n = Promise)((function(e, o) {
                function i(e) {
                    try {
                        s(r.next(e))
                    } catch (t) {
                        o(t)
                    }
                }
                function a(e) {
                    try {
                        s(r.throw(e))
                    } catch (t) {
                        o(t)
                    }
                }
                function s(t) {
                    var r;
                    t.done ? e(t.value) : ((r = t.value)instanceof n ? r : new n((function(e) {
                        e(r)
                    }
                    ))).then(i, a)
                }
                s((r = r.apply(t, [])).next())
            }
            ));
            var t, n, r
        }
        )).then((function(e) {
            return c._config = e,
            c.error_occurred = !1,
            e = null,
            f ? (e = p.clone()).data = d : e = p,
            "function" == typeof t && t(c, e),
            p
        }
        ), (function(e) {
            throw "function" == typeof t && (c.error_occurred = !0,
            c.log_entity = [{
                timestamp: Date.now(),
                data: {
                    name: e.name,
                    message: e.message,
                    stack: e.stack
                }
            }],
            t(c, {
                status: 0,
                statusText: e
            }, e)),
            e
        }
        ))
    }
    ,
    function() {
        o && (r.fetch = o)
    }
}
function Se() {
    var e = [];
    function t(t) {
        -1 !== (t = e.indexOf(t)) && e.splice(t, 1)
    }
    function n(n) {
        return e.push(n),
        t.bind(void 0, n)
    }
    return {
        on: n,
        off: t,
        once: function(e) {
            var t = n((function(n) {
                e(n),
                t()
            }
            ));
            return t
        },
        emit: function(n) {
            e.forEach((function(e) {
                !1 === e(n) && t.bind(void 0, e)()
            }
            ))
        }
    }
}
function Oe(e) {
    return (e = new RegExp("(?:^|; ?)".concat(e, "=(1|0)(;|$)")).exec(document.cookie)) && e[1]
}
var ke = ["radar_init", "h5_load", "fmp", "main_api", "h5_custom_metric"];
function Re(e) {
    var t = e.dimension
      , n = e.value;
    if (e = t.event_name,
    ke.indexOf(e) < 0)
        return !1;
    if (!Y(n))
        return !1;
    switch (e) {
    case "fmp":
        var r = n.fmp_time;
        return !(!n.fmp || !r);
    case "h5_load":
        return r = n.total,
        !(!n.load_event_time || !r);
    case "h5_custom_metric":
        return r = n.custom_metric_timestamp,
        !(!t.custom_metric_name || !r)
    }
    return !0
}
function Ee(e) {
    var t = e.dimension
      , n = (e = e.value,
    t.custom_failed)
      , r = t.api
      , o = t.status
      , i = t.res_type
      , a = t.protocol
      , s = (t = t.cached,
    e.duration)
      , c = e.size;
    return "boolean" == typeof (void 0 !== n && n) && "string" == typeof (void 0 === r ? "" : r) && "number" == typeof (void 0 === o ? 0 : o) && "string" == typeof (void 0 === i ? "" : i) && "string" == typeof (void 0 === a ? "" : a) && "boolean" == typeof (void 0 !== t && t) && "number" == typeof (void 0 === s ? 0 : s) && "number" == typeof (void 0 === c ? 0 : c) && Y(e)
}
function je(e) {
    if ([(e = e.dimension).error_cons_type, e.msg].some((function(e) {
        return null == e
    }
    )))
        return !1;
    var t, n = e.col, r = e.line;
    return e.sample_rate,
    e.event_client_timestamp,
    e = function(e, t) {
        var n = {};
        for (o in e)
            Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
            for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
                t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
        return n
    }(e, ["col", "line", "sample_rate", "event_client_timestamp"]),
    !(n && "number" != typeof n || r && "number" != typeof r) && "object" == typeof (t = e) && Object.keys(t).every((function(e) {
        return void 0 === t[e] || "string" == typeof t[e]
    }
    ))
}
function Le(e) {
    var t = e.dimension
      , n = (e = e.value,
    t.failed);
    if ("boolean" != typeof n)
        return !1;
    if (n) {
        var r = t.res_path;
        if ("string" != typeof t.file || "string" != typeof r)
            return !1
    }
    return !!n || "string" == typeof t.file && Y(e)
}
function He(e) {
    var t = e.value;
    return e = e.dimension.name,
    !(void 0 !== t && !Y(t) || !e)
}
function Te(e) {
    var t = !0;
    if ((e = e.dimension.data)instanceof Array) {
        if (0 === e.length)
            return !1;
        e.forEach((function(e) {
            "string" != typeof e.com && (t = !1)
        }
        ))
    }
    return t
}
var De = {
    load: Re,
    api: Ee,
    resource: Le,
    error: je,
    event: He,
    blood: Te
};
function Ae(e) {
    return e ? Object.keys(s$1).map((function(e) {
        return s$1[e]
    }
    )).indexOf(e.key) < 0 ? (c$2("117"),
    !1) : De[e.key](e) : (c$2("116"),
    !1)
}
function Me(e) {
    function t() {
        e = e.replace(/^\s*/, "")
    }
    function n(n) {
        return t(),
        e[0] === n && (e = e.slice(1),
        1)
    }
    function r() {
        t();
        var n = /^([^\s,;=\\]+)(.*)/.exec(e);
        if (n)
            return e = n[2],
            n[1]
    }
    if (e && "string" == typeof e) {
        for (var o, i = []; o = r(); ) {
            for (var a = {
                name: o
            }, s = {}; n(";"); ) {
                var c, l, u = void 0;
                (u = r()) && (c = void 0,
                n("=") && (c = function() {
                    if (t(),
                    '"' !== e[0])
                        return r();
                    e = e.slice(1);
                    for (var n = ""; e.length; ) {
                        var o = /^([^"\\]*)(.*)/.exec(e);
                        if (o) {
                            if (n += o[1],
                            '"' === o[2][0])
                                return e = o[2].slice(1),
                                n;
                            n += o[2][1],
                            e = o[2].slice(2)
                        }
                    }
                }(),
                l = void 0,
                (l = /([,;].*)/.exec(e)) && (e = l[1])),
                s[l = u.toLowerCase()] || (s[l] = 1,
                "dur" === l ? a.duration = parseFloat(c) || 0 : "desc" === l ? a.description = c || "" : a[u] = c))
            }
            if ("sec" === a.unit && a.duration && (a.duration *= 1e3),
            delete a.unit,
            i.push(a),
            !n(","))
                break
        }
        return i.length ? i : void 0
    }
}
function Ne() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
        var t = 16 * Math.random() | 0;
        return ("x" === e ? t : 3 & t | 8).toString(16)
    }
    ))
}
function Ie(e, t) {
    m$2[e = void 0 === e ? g$4 : e] = ie$1(m$2[e] || {}, t)
}
function qe() {
    var e = Pe(S$2, null, g$4);
    return e || (e = Ne(),
    Ue(S$2, e, g$4)),
    e
}
function Pe(e, t, n) {
    return m$2[n = void 0 === n ? g$4 : n] && void 0 !== m$2[n][e] ? m$2[n][e] : void 0 === t ? null : t
}
function Ue(e, t, n) {
    m$2[n = void 0 === n ? g$4 : n] || Ie(n, {}),
    m$2[n][e] = t
}
function We() {
    m$2[b$3] && (m$2[b$3][w] = !0)
}
function Xe(e, t) {
    return Pe(e, t = void 0 === t ? null : t, b$3)
}
function Je(e, t) {
    Ue(e, t, b$3)
}
function ze() {
    Je(V, [])
}
function Ye(e) {
    return JSON.parse(JSON.stringify(e))
}
function Be(e) {
    try {
        if (window && window.localStorage) {
            var t = window.localStorage.getItem(e);
            if (t)
                try {
                    return JSON.parse(t)
                } catch (n) {
                    return t
                }
        }
    } catch (n) {
        return null
    }
    return null
}
function Ge(e, t) {
    try {
        if (window && window.localStorage)
            return window.localStorage.setItem(e, JSON.stringify(t)),
            !0
    } catch (n) {
        return !1
    }
    return !1
}
function $e(e) {
    try {
        var t;
        if (window && window.localStorage && "undefined" != typeof Storage && window.localStorage instanceof Storage)
            return Ge(e, (t = 1e8 < (t = Number(Be(e)) || 0) + 1 ? 0 : t) + 1),
            t
    } catch (n) {}
}
function Qe(e) {
    for (var r = [], o = 1; o < arguments.length; o++)
        r[o - 1] = arguments[o];
    1 == +Ze(location.search.slice(1)).debug && a$3.apply(void 0, n(["[radar] ".concat(e, ": ")], t(r), !1))
}
function Ze(e) {
    var n, r, o = {};
    e = e.split("&");
    try {
        for (var i = function(e) {
            var t = "function" == typeof Symbol && Symbol.iterator
              , n = t && e[t]
              , r = 0;
            if (n)
                return n.call(e);
            if (e && "number" == typeof e.length)
                return {
                    next: function() {
                        return {
                            value: (e = e && r >= e.length ? void 0 : e) && e[r++],
                            done: !e
                        }
                    }
                };
            throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }(e), a = i.next(); !a.done; a = i.next()) {
            var s = t(a.value.split("="), 2)
              , c = s[0]
              , l = s[1];
            c in o ? o[c]instanceof Array ? o[c].push(l) : o[c] = [o[c], l] : o[c] = l
        }
    } catch (u) {
        n = {
            error: u
        }
    } finally {
        try {
            a && !a.done && (r = i.return) && r.call(i)
        } finally {
            if (n)
                throw n.error
        }
    }
    return o
}
function tt(e) {
    if (-1 === (n = (e = void 0 === e ? location.href : e).lastIndexOf("?")))
        return {
            page: e
        };
    var t = e.slice(0, n)
      , n = e.slice(n + 1);
    return {
        url: e,
        page: t,
        params: Ze(n)
    }
}
function nt$1(e) {
    throw new Error("radar error " + e)
}
var f$3 = function() {
    return (f$3 = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
};
function v$3(e, t) {
    var n = "function" == typeof Symbol && e[Symbol.iterator];
    if (!n)
        return e;
    var r, o, i = n.call(e), a = [];
    try {
        for (; (void 0 === t || 0 < t--) && !(r = i.next()).done; )
            a.push(r.value)
    } catch (s) {
        o = {
            error: s
        }
    } finally {
        try {
            r && !r.done && (n = i.return) && n.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return a
}
function _$2(e, t, n) {
    if (2 === arguments.length)
        for (var r, o = 0, i = t.length; o < i; o++)
            !r && o in t || ((r = r || Array.prototype.slice.call(t, 0, o))[o] = t[o]);
    return e.concat(r || Array.prototype.slice.call(t))
}
var y$4 = ["c_dimension1", "c_dimension2", "c_dimension3", "release_tag", "product_version", "sub_app"]
  , b$2 = function() {
    function e(e) {
        var t, n = this, r = (this.queueConfig = {
            wait: 1e3,
            maxBatchLength: 200
        },
        this.logQueue = [],
        this.preStoredLogQueue = [],
        this.batchTimer = 0,
        this.eventName = "onpagehide"in window ? "pagehide" : "beforeunload",
        this.customDimension = {},
        this.runtimeIdMap = {},
        this.randomSampling = Math.random(),
        this.commonDimension = {},
        this.isInYoda = !1,
        this.sampleData = {
            isHit: !0,
            core: 1
        },
        this.ignoreList = ["https://web-trace.ksapisrv.com/ktrace/collect"],
        this.broadcastSample = Se(),
        this.didRate = void 0,
        this.whiteUserStatus = 0,
        this.collect = function(e, t, r, o) {
            var i = Ye({
                key: e,
                dimension: t = void 0 === t ? {} : t,
                value: r = void 0 === r ? {} : r
            });
            if (!n.sampleData || !1 !== n.sampleData.isHit || 0 === n.whiteUserStatus) {
                if (!Ae(i))
                    return c$2("107", "key: ".concat(i.key)),
                    void n.collect(s$1.EVENT, {
                        sample_rate: 2 === n.whiteUserStatus ? 1 : t.sample_rate,
                        message: "radar上报日志类型错误",
                        name: "radar_log_error",
                        extra_info: JSON.stringify(i)
                    }, {});
                Object.keys(i.value).forEach((function(e) {
                    i.value[e] = i.value[e].toString()
                }
                )),
                n.decorateLog(i);
                var a = ie$1(n.getCommonData(), o || {})
                  , s = a.app_version_name;
                if (delete a.app_version_name,
                (e = new l$2((function(e, r) {
                    e.dimension.sample_rate = t.sample_rate,
                    e.dimension.app_version_name = s,
                    e.dimension.did_rate = n.didRate;
                    var o = (null == (o = null == e ? void 0 : e.dimension) ? void 0 : o.event_client_timestamp) || Date.now()
                      , i = (null == (i = null == e ? void 0 : e.dimension) ? void 0 : i.radar_session_id) || n.radarSessionId;
                    return ie$1(e, a, {
                        event_client_timestamp: o,
                        radar_session_id: i
                    })
                }
                ))).use((function(e, t) {
                    return e.key && "load" === e.key && (e.dimension = f$3(f$3({}, e.dimension), {
                        load_device_increase_id: $e("LOAD_DEVICE_INCREASE_ID"),
                        load_session_increase_id: n.genSessionIncreaseId("LOAD_SESSION_INCREASE_ID")
                    })),
                    e.key && "load" !== e.key && (e.dimension = f$3(f$3({}, e.dimension), {
                        other_device_increase_id: $e("OTHER_DEVICE_INCREASE_ID"),
                        other_session_increase_id: n.genSessionIncreaseId("OTHER_SESSION_INCREASE_ID")
                    })),
                    t()
                }
                )),
                (i = e.invoke(i))instanceof Error)
                    throw i;
                try {
                    window.dispatchEvent(new CustomEvent("get-radar-next-data",{
                        detail: {
                            kv: Ye(i)
                        }
                    }))
                } catch (c) {}
                if (delete i.dimension.broadcast_info,
                n.weblog && n.isHit(i) || 2 === n.whiteUserStatus ? n.logQueue.push(i) : (i.base_href = location.href,
                n.preStoredLogQueue.push(i)),
                Qe("radarLogNext", JSON.parse(JSON.stringify(i))),
                n.logQueue.length > n.queueConfig.maxBatchLength - 1)
                    return n.flush(),
                    clearTimeout(n.batchTimer),
                    void (n.batchTimer = 0);
                n.batchTimer || (n.batchTimer = window.setTimeout((function() {
                    n.flush(),
                    clearTimeout(n.batchTimer),
                    n.batchTimer = 0
                }
                ), n.queueConfig.wait))
            }
        }
        ,
        this.flush = function() {
            var e;
            n.logQueue.length <= 0 || (e = null,
            (e = n.config.httpReportFirst ? e : n.reportByBridge()) && !n.config.httpReportFirst || n.reportByHttp(),
            n.logQueue = [])
        }
        ,
        "object" == typeof e && null !== e || nt$1("108"),
        "string" != typeof e.projectId && nt$1("109"),
        qe());
        this.radarSessionId = r,
        this.config = e,
        this.sampling = "number" == typeof (t = null != (r = this.config.sampling) ? r : 1) && 0 <= t && t <= 1 ? t : (c$2("110"),
        1),
        void 0 !== e.weblogger && this.bindWeblogger(e.weblogger),
        null != (r = this.config) && r.ignoreList && Array.isArray(null == (e = this.config) ? void 0 : e.ignoreList) && (this.ignoreList = this.ignoreList.concat(this.config.ignoreList.map((function(e) {
            return e.replace(/^(https?:)?\/\//, "")
        }
        )))),
        this.queueConfig = f$3(f$3({}, this.queueConfig), null != (r = this.config) && r.queueConfig ? this.config.queueConfig : {}),
        null != (e = this.config) && e.customDimensions && this.setDimensions(null == (r = this.config) ? void 0 : r.customDimensions),
        ["pagehide", "beforeunload", "resume"].forEach((function(e) {
            "on" + e in window && de$1(window, e, n.flush)
        }
        )),
        de$1(document, "visibilitychange", this.flush, !0),
        "undefined" != typeof window && window.yodaCollectErrorDataDestroy && window.yodaCollectErrorDataDestroy()
    }
    return e.prototype.getWhiteUserStatus = function() {
        return this.whiteUserStatus
    }
    ,
    e.prototype.setIsWhiteUser = function() {
        var e, t, n, r;
        return t = this,
        n = void 0,
        r = function() {
            var t, n, r, o, i, a, s, c, l = this;
            return n = this,
            r = function(n) {
                switch (n.label) {
                case 0:
                    return !this.isInYoda && (t = null == (e = null == (e = null == (e = this.weblog) ? void 0 : e.commonPackage) ? void 0 : e.identity_package) ? void 0 : e.user_id) ? (setTimeout((function() {
                        l.whiteUserStatus = 1,
                        l.clearPreStoredLogQueue()
                    }
                    ), 1e3),
                    [4, fetch("https://da-radar-plus-api".concat("oversea" === (null == (e = null == (e = this.weblog) ? void 0 : e.logConfig) ? void 0 : e.env) ? "-sgp.kwai-pro" : ".ksapisrv", ".com/dp/platform/da/radar/api/uid/U2FsdGVkX18oxs4/w57rSZOb0mSZWOe/pJ5EhPgSVxA?uid=").concat(t)).then((function(e) {
                        return e.json()
                    }
                    )).then((function(e) {
                        0 === e.code && !0 === e.data && 0 === l.whiteUserStatus && (l.whiteUserStatus = 2,
                        l.sampleData = {
                            isHit: !0,
                            core: 1
                        },
                        l.broadcastSample.emit(l.sampleData)),
                        l.clearPreStoredLogQueue()
                    }
                    )).catch((function() {}
                    ))]) : [3, 2];
                case 1:
                    n.sent(),
                    this.weblog && (this.preStoredLogQueue = []),
                    n.label = 2;
                case 2:
                    return 0 === this.whiteUserStatus && (this.whiteUserStatus = 1),
                    [2]
                }
            }
            ,
            s = {
                label: 0,
                sent: function() {
                    if (1 & a[0])
                        throw a[1];
                    return a[1]
                },
                trys: [],
                ops: []
            },
            c = {
                next: u(0),
                throw: u(1),
                return: u(2)
            },
            "function" == typeof Symbol && (c[Symbol.iterator] = function() {
                return this
            }
            ),
            c;
            function u(e) {
                return function(t) {
                    var c = [e, t];
                    if (o)
                        throw new TypeError("Generator is already executing.");
                    for (; s; )
                        try {
                            if (o = 1,
                            i && (a = 2 & c[0] ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i),
                            0) : i.next) && !(a = a.call(i, c[1])).done)
                                return a;
                            switch (i = 0,
                            (c = a ? [2 & c[0], a.value] : c)[0]) {
                            case 0:
                            case 1:
                                a = c;
                                break;
                            case 4:
                                return s.label++,
                                {
                                    value: c[1],
                                    done: !1
                                };
                            case 5:
                                s.label++,
                                i = c[1],
                                c = [0];
                                continue;
                            case 7:
                                c = s.ops.pop(),
                                s.trys.pop();
                                continue;
                            default:
                                if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === c[0] || 2 === c[0])) {
                                    s = 0;
                                    continue
                                }
                                if (3 === c[0] && (!a || c[1] > a[0] && c[1] < a[3])) {
                                    s.label = c[1];
                                    break
                                }
                                if (6 === c[0] && s.label < a[1]) {
                                    s.label = a[1],
                                    a = c;
                                    break
                                }
                                if (a && s.label < a[2]) {
                                    s.label = a[2],
                                    s.ops.push(c);
                                    break
                                }
                                a[2] && s.ops.pop(),
                                s.trys.pop();
                                continue
                            }
                            c = r.call(n, s)
                        } catch (l) {
                            c = [6, l],
                            i = 0
                        } finally {
                            o = a = 0
                        }
                    if (5 & c[0])
                        throw c[1];
                    return {
                        value: c[0] ? c[1] : void 0,
                        done: !0
                    }
                }
            }
        }
        ,
        new (n = Promise)((function(e, o) {
            function i(e) {
                try {
                    s(r.next(e))
                } catch (t) {
                    o(t)
                }
            }
            function a(e) {
                try {
                    s(r.throw(e))
                } catch (t) {
                    o(t)
                }
            }
            function s(t) {
                var r;
                t.done ? e(t.value) : ((r = t.value)instanceof n ? r : new n((function(e) {
                    e(r)
                }
                ))).then(i, a)
            }
            s((r = r.apply(t, [])).next())
        }
        ))
    }
    ,
    e.prototype.genSessionIncreaseId = function(e) {
        return this.runtimeIdMap[e] || (this.runtimeIdMap[e] = 0),
        this.runtimeIdMap[e]++
    }
    ,
    e.prototype.bindWeblogger = function(e) {
        var t;
        if (e && "object" == typeof e) {
            if (this.weblog)
                return void a$3("122");
            this.weblog = e,
            this.updateUrlPackage(),
            void 0 !== (null == (t = null == e ? void 0 : e.logger) ? void 0 : t.radarUrl) && this.ignoreList.push(null == (t = null == e ? void 0 : e.logger) ? void 0 : t.radarUrl),
            void 0 !== (null == (t = null == e ? void 0 : e.logger) ? void 0 : t.url) && this.ignoreList.push(null == (t = null == e ? void 0 : e.logger) ? void 0 : t.url),
            this.isInYoda = !(null == (t = null == (e = this.weblog) ? void 0 : e.Utils) || !t.yoda),
            this.getSampleData()
        } else
            nt$1("106");
        this.setIsWhiteUser(),
        this.clearPreStoredLogQueue()
    }
    ,
    e.prototype.clearPreStoredLogQueue = function() {
        var e = this
          , t = [];
        0 < this.preStoredLogQueue.length && (this.preStoredLogQueue.forEach((function(n) {
            if (2 === e.whiteUserStatus ? n.dimension.sample_rate = 1 : void 0 !== (r = e.sampleData["load" === n.key ? "core" : n.key]) && (n.dimension.sample_rate = r),
            e.isHit(n)) {
                var r = e.getCommonData()
                  , o = (n.dimension.app_version_name = r.app_version_name,
                n.h5_extra_attr = JSON.stringify(f$3(f$3({}, null == (r = e.weblog.commonPackage) ? void 0 : r.getH5ExtraAttr()), JSON.parse(n.h5_extra_attr))),
                tt(n.base_href))
                  , i = null == (r = e.weblog.logConfig) ? void 0 : r.urlMap;
                r = {};
                if ("function" == typeof i)
                    try {
                        var a = i(o);
                        "string" == typeof a ? r = {
                            page: a
                        } : "object" == typeof a && (r = {
                            page: a.page,
                            params: a.params
                        })
                    } catch (l) {}
                else if ("object" == typeof i) {
                    var s, c = "";
                    for (s in i)
                        if (-1 < (o.page || o.url || "").indexOf(s)) {
                            c = i[s];
                            break
                        }
                    c && (r = {
                        page: c
                    })
                }
                n.url_package = {
                    page: r && r.page || o.page
                },
                a = e.referUrlPackage && e.referUrlPackage.toJSON(),
                n.refer_url_package = a,
                delete n.base_href,
                e.logQueue.push(n)
            } else
                0 === e.whiteUserStatus && t.push(n)
        }
        )),
        this.preStoredLogQueue = t,
        this.flush())
    }
    ,
    e.prototype.getSampleData = function() {
        var e, t, n = this;
        this.isInYoda ? (this.sampleData = {
            isHit: !0,
            core: this.sampling,
            api: 1,
            resource: .1,
            error: 1,
            event: 1
        },
        t = window.updateYodaSampleRateWithParams,
        window.updateYodaSampleRateWithParams = function(e) {
            i("104", e),
            n.updateYodaSampleRate(e),
            t && t(e)
        }
        ,
        window.__yodaCommonDataObject__ && window.__yodaCommonDataObject__.sampleData ? (this.updateYodaSampleRate(window.__yodaCommonDataObject__.sampleData),
        this.collect(s$1.EVENT, {
            name: "客户端采样率注入成功",
            event_type: "radar_sample_inject_success",
            extra_info: this.sampleData,
            sample_rate: 1
        }, {})) : "function" == typeof (null == (e = null == (e = null == (e = this.weblog) ? void 0 : e.Utils) ? void 0 : e.yoda) ? void 0 : e.getWebviewLoadPerf) && null != (e = this.weblog) && e.Utils.yoda.getWebviewLoadPerf().then((function(e) {
            null != e && e.sampleData && n.updateYodaSampleRate(e.sampleData)
        }
        ))) : (this.sampleData = {
            isHit: this.samplingControl(this.sampling),
            core: this.sampling
        },
        this.broadcastSample.emit(this.sampleData))
    }
    ,
    e.prototype.updateYodaSampleRate = function(e) {
        var t = this
          , n = null;
        try {
            var r = e;
            n = "string" == typeof r ? JSON.parse(r) : r
        } catch (o) {
            return void i("error: ", o)
        }
        try {
            n.extra && (n = f$3(f$3({}, n), n.extra))
        } catch (o) {
            i("error: ", o)
        }
        n && (Object.keys(n).forEach((function(e) {
            "load" === e ? t.sampleData.core = n[e] : "did_rate" === e ? t.didRate = n[e] : t.sampleData[e] = n[e]
        }
        )),
        this.broadcastSample.emit(this.sampleData))
    }
    ,
    e.prototype.updateUrlPackage = function() {
        var e;
        null != (e = this.weblog) && e.currentUrlPackage && (this.currentUrlPackage = this.weblog.currentUrlPackage,
        this.referUrlPackage = this.weblog.referUrlPackage)
    }
    ,
    e.prototype.setDimensions = function(e) {
        var t = this
          , n = Object.keys(e);
        n.some((function(e) {
            return -1 === y$4.indexOf(e)
        }
        )) && c$2("113", "".concat(n.join("、"))),
        n.forEach((function(n) {
            null == e[n] ? delete t.customDimension[n] : t.customDimension[n] = e[n]
        }
        ))
    }
    ,
    e.prototype.setCommonDimension = function(e, t, n) {
        this.commonDimension[e] = (n = void 0 === n || n) || null == (n = this.commonDimension[e]) ? t : n
    }
    ,
    e.prototype.decorateLog = function(e) {
        var t, n;
        this.currentUrlPackage || this.updateUrlPackage(),
        0 < Object.keys(this.customDimension).length && Object.assign(e.dimension, this.customDimension),
        0 < Object.keys(this.commonDimension).length && (t = {},
        (n = null != (n = null == (n = e.dimension) ? void 0 : n.happen_stage) ? n : null == (n = this.commonDimension) ? void 0 : n.happen_stage) && (t.happen_stage = n),
        Object.assign(e.dimension, this.commonDimension, t)),
        this.currentUrlPackage && this.currentUrlPackage.page !== (null == (e = null == (n = this.weblog) ? void 0 : n.currentUrlPackage) ? void 0 : e.page) && (this.flush(),
        this.updateUrlPackage())
    }
    ,
    e.prototype.isHit = function(e) {
        return "load" === e.key ? this.sampleData.isHit : this.sampleData.isHit && e.dimension.sample_rate >= this.randomSampling
    }
    ,
    e.prototype.samplingControl = function(e) {
        return null !== e && "number" == typeof e && this.randomSampling < e
    }
    ,
    e.prototype.getCommonData = function() {
        var e, t = null == (t = null == (t = null == (t = this.weblog) ? void 0 : t.commonPackage) ? void 0 : t.app_package) ? void 0 : t.version_name;
        t = {
            h5_extra_attr: JSON.stringify(f$3(f$3({}, null == (e = null == (e = this.weblog) ? void 0 : e.commonPackage) ? void 0 : e.getH5ExtraAttr()), {
                app_version_name: t,
                url: location.href,
                hash: location.hash,
                online: null === navigator || void 0 === navigator ? void 0 : navigator.onLine,
                downlink: null == (e = null === navigator || void 0 === navigator ? void 0 : navigator.connection) ? void 0 : e.downlink,
                rtt: null == (e = null === navigator || void 0 === navigator ? void 0 : navigator.connection) ? void 0 : e.rtt
            })),
            url_package: this.currentUrlPackage && this.currentUrlPackage.toJSON(),
            refer_url_package: this.referUrlPackage && this.referUrlPackage.toJSON(),
            app_version_name: t,
            project_id: null == (e = this.config) ? void 0 : e.projectId,
            event_trigger_source: "H5"
        };
        return "1" === Oe("radar_report_test") && (t.is_report_test = !0),
        t
    }
    ,
    e.prototype.reportByHttp = function() {
        var e = this.getCommonData()
          , t = (e = {
            project_id: this.config.projectId,
            radar_session_id: this.radarSessionId,
            h5_extra_attr: e.h5_extra_attr
        },
        this.logQueue.filter((function(e) {
            return "load" === e.key
        }
        )))
          , n = this.logQueue.filter((function(e) {
            return "load" !== e.key
        }
        ));
        Array.isArray(t) && t.length && this.collectLog(e, t, "radarSDK"),
        Array.isArray(n) && n.length && this.collectLog(e, n, "radarSDKSupplement")
    }
    ,
    e.prototype.collectLog = function(e, t, n) {
        var r;
        "function" != typeof (null == (r = this.weblog) ? void 0 : r.collect) && "function" != typeof (null == (r = this.weblog) ? void 0 : r.sendByHttp) ? c$2("114") : (this.weblog.sendByHttp || this.weblog.collect).call(this.weblog, "RADAR", {
            name: "radar_log",
            params: f$3(f$3({}, e), {
                data: _$2([], v$3(t), !1)
            }),
            serviceName: n
        })
    }
    ,
    e.prototype.reportByBridge = function() {
        var e = null == (n = null == (n = this.weblog) ? void 0 : n.Utils) ? void 0 : n.yoda;
        if (!e)
            return !1;
        var t, n = this.logQueue.filter((function(e) {
            return "load" === e.key
        }
        )), r = this.logQueue.filter((function(e) {
            return "load" !== e.key
        }
        ));
        try {
            return n.forEach((function(t) {
                "function" == typeof (null == (t = e.sendSummarizedLog({
                    key: "h5_load",
                    data: t
                })) ? void 0 : t.catch) && t.catch((function(e) {
                    c$2("123", e)
                }
                ))
            }
            )),
            r.length && "function" == typeof (null == (t = e.sendRadarLog({
                data: r
            })) ? void 0 : t.catch) && t.catch((function(e) {
                c$2("124", e)
            }
            )),
            !0
        } catch (o) {
            return !1
        }
    }
    ,
    e
}()
  , f$2 = function(e, t) {
    return (f$2 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}
  , _$1 = function() {
    return (_$1 = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
};
function h$2(e, t) {
    var n = {};
    for (o in e)
        Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
    if (null != e && "function" == typeof Object.getOwnPropertySymbols)
        for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
            t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
    return n
}
var v$2 = {
    redirect: {
        end: "redirectEnd",
        start: "redirectStart"
    },
    dns: {
        end: "domainLookupEnd",
        start: "domainLookupStart"
    },
    dns_start: {
        end: "domainLookupEnd",
        start: "navigationStart"
    },
    tcp: {
        end: "connectEnd",
        start: "connectStart"
    },
    tcp_start: {
        end: "connectEnd",
        start: "navigationStart"
    },
    redirect_count: {
        custom: function(e, t) {
            return t.redirectCount
        }
    },
    ssl: {
        custom: function(e, t) {
            return t.connectEnd && t.secureConnectionStart ? t.connectEnd - t.secureConnectionStart : null
        }
    },
    ssl_start: {
        custom: function(e, t) {
            return t.secureConnectionStart && t.navigationStart ? t.secureConnectionStart - t.navigationStart : null
        }
    },
    ttfb: {
        end: "responseStart",
        start: "requestStart"
    },
    request_start: {
        end: "requestStart",
        start: "navigationStart"
    },
    trans: {
        end: "responseEnd",
        start: "responseStart"
    },
    dom_parse: {
        end: "domInteractive",
        start: "responseEnd"
    },
    dom_parse_start: {
        end: "domInteractive",
        start: "navigationStart"
    },
    blank: {
        end: "domLoading",
        start: "navigationStart"
    },
    fb: {
        end: "responseStart",
        start: "navigationStart"
    },
    dom_ready: {
        end: "domContentLoadedEventEnd",
        start: "navigationStart"
    },
    total: {
        end: "loadEventStart",
        start: "navigationStart"
    },
    resource: {
        end: "loadEventStart",
        start: "domInteractive"
    },
    fp: {
        custom: function() {
            if ("function" != typeof performance.getEntries)
                return null;
            var e = performance.getEntries().filter((function(e) {
                return "first-paint" === e.name
            }
            ))[0];
            return e ? Math.ceil(e.startTime + e.duration) : null
        }
    },
    js_cost: {
        custom: function() {
            if ("function" != typeof performance.getEntries)
                return null;
            var e = p$2()
              , t = performance.getEntries()
              , n = performance.getEntries().filter((function(e) {
                return "navigation" === e.initiatorType
            }
            ))[0];
            t = t.filter((function(e) {
                return "script" === e.initiatorType
            }
            ))[0],
            n = n ? n.domComplete : e.domComplete - e.navigationStart;
            return t && n ? n - t.fetchStart : null
        }
    },
    tti: {
        end: "domInteractive",
        start: "navigationStart"
    },
    protocol: {
        custom: function(e, t) {
            return t.nextHopProtocol
        }
    },
    dom_num: {
        custom: function() {
            return "undefined" != typeof document && void 0 !== document.all ? document.all.length : null
        }
    }
}
  , g$3 = {
    main_api: {
        end: "apiEnd",
        start: "apiStart",
        notCatchIfUndefined: !0
    },
    main_api_offset: {
        end: "apiStart",
        start: "responseEnd",
        notCatchIfUndefined: !0
    },
    fmp: {
        end: "fmp_time",
        start: "navigationStart",
        notCatchIfUndefined: !0
    }
}
  , S$1 = {
    navigation_start_time: "navigationStart",
    fetch_start_time: "fetchStart",
    dns_start_time: "domainLookupStart",
    dns_end_time: "domainLookupEnd",
    connect_start_time: "connectStart",
    ssl_start_time: "secureConnectionStart",
    request_start_time: "requestStart",
    response_start_time: "responseStart",
    response_end_time: "responseEnd",
    dom_interactive_time: "domInteractive",
    dom_loading_time: "domLoading",
    dom_ready_time: "domContentLoadedEventEnd",
    load_event_time: "loadEventStart",
    connect_end_time: "connectEnd",
    load_event_end: "loadEventEnd",
    dom_complete: "domComplete",
    dom_content_loaded_event_start: "domContentLoadedEventStart",
    redirect_start: "redirectStart",
    redirect_end: "redirectEnd",
    radar_init_time: "radar_init_time",
    fmp_time: "fmp_time"
};
function y$3(e, t) {
    if (!Array.isArray(t))
        return -1;
    var n = -1;
    return t.forEach((function(t, r) {
        new RegExp(t).test(e) && (n = r)
    }
    )),
    n
}
var L$1 = function(e) {
    function t(t) {
        var n = this;
        return (n = e.call(this, {
            core: t.core,
            key: s$1.LOAD,
            version: "1.2.12",
            name: "RadarNavigationCollect"
        }) || this).hasFMP = !1,
        n.syncMetricNum = 0,
        n.customKeys = [],
        n.custom_metric = {},
        n.optionsMainAPI = [],
        n.mainAPIList = [],
        n.radarMainApiList = [],
        n.mainJSList = [],
        n.radarMainJSList = [],
        n.radarTiming = {
            radar_init_time: void 0,
            fmp_time: void 0,
            fmp: void 0,
            apiStart: void 0,
            apiEnd: void 0
        },
        n.h5Load = function() {
            var e = n.getPerformanceData();
            n.collect(_$1({
                event_name: "h5_load"
            }, e))
        }
        ,
        n.dealAPI = function(e) {
            return n.addMainApiResult(e),
            n.mainAPIList.filter((function(e) {
                return !!e.url
            }
            )).length !== n.mainAPIList.length
        }
        ,
        n.dealAPIHook = function(e) {
            return n.recordApiPeriod(e),
            n.addRadarMainApiResult(e),
            void 0 === n.radarTiming.fmp
        }
        ,
        n.addMainJSResult = function(e) {
            if (!n.mainJSList || 0 === n.mainJSList.length)
                return !1;
            var t, r, o, i, a, s, c, l, u, p, d, f, h, m, g, v = y$3((e.file || "").replace(/\?.+$/, ""), n.mainJSList);
            return -1 < v && !n.radarMainJSList[v].file && (t = e.file,
            r = e.cached,
            o = e.size,
            i = e.failed,
            a = e.res_type,
            s = e.protocol,
            c = e.fb,
            l = e.dns,
            u = e.tcp,
            p = e.ssl,
            d = e.ttfb,
            f = e.trans,
            h = e.total,
            m = e.fetch_start,
            g = e.duration,
            e = e.start_time,
            n.radarMainJSList[v] = {
                file: t,
                cached: r,
                size: o,
                failed: i,
                res_type: a,
                protocol: s,
                fb: c,
                dns: l,
                tcp: u,
                ssl: p,
                ttfb: d,
                trans: f,
                total: h,
                fetch_start: m,
                duration: g,
                start_time: e,
                reg: n.mainJSList[v]
            }),
            n.radarMainJSList.filter((function(e) {
                return !!e.file
            }
            )).length !== n.mainJSList.length
        }
        ,
        t.core || nt$1("212"),
        "string" == typeof t.mainApi ? (n.optionsMainAPI.push(t.mainApi),
        n.mainAPIList.push({}),
        n.radarMainApiList.push({})) : Array.isArray(t.mainApi) && (3 < t.mainApi.length && a$3("207"),
        n.optionsMainAPI = t.mainApi.slice(0, 3),
        n.optionsMainAPI.forEach((function() {
            n.mainAPIList.push({}),
            n.radarMainApiList.push({})
        }
        ))),
        "string" == typeof t.mainJs ? (n.mainJSList.push(t.mainJs),
        n.radarMainJSList.push({})) : Array.isArray(t.mainJs) && (3 < t.mainJs.length && a$3("211"),
        n.mainJSList = t.mainJs.slice(0, 3),
        n.mainJSList.forEach((function() {
            return n.radarMainJSList.push({})
        }
        ))),
        performance.timing ? n.init() : (null != (t = n.core) && t.collect("event", {
            name: "radar_error",
            message: "performance.timing 不存在无法收集数据",
            category: s$1.LOAD
        }),
        c$2("208")),
        n
    }
    var n = t
      , r = e;
    if ("function" != typeof r && null !== r)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    function o() {
        this.constructor = n
    }
    return f$2(n, r),
    n.prototype = null === r ? Object.create(r) : (o.prototype = r.prototype,
    new o),
    t.prototype.init = function() {
        var e, t, n = Xe(M);
        n = this.core.config.projectId === n ? Xe(N$1) : null;
        this.radarTiming.radar_init_time = n || Date.now(),
        null != (t = null == (e = this.core) ? void 0 : e.setCommonDimension) && t.call(e, "happen_stage", "during_fmp"),
        n || (t = this.getPerformanceData(),
        this.collect(_$1({
            event_name: "radar_init"
        }, t))),
        0 < performance.timing.loadEventStart ? this.h5Load() : de$1(window, "load", this.h5Load)
    }
    ,
    t.prototype.customStage = function(e, t) {
        var n, r;
        void 0 === t && (t = {
            sendTimeline: !0
        }),
        this.isHit ? (void 0 !== e && "string" == typeof e && "" !== e || nt$1("206"),
        this.isValidTimestamp(t.timestamp, "custom_stage " + e) && (n = t.timestamp || Date.now(),
        r = this.customKeys.length - this.syncMetricNum,
        this.customKeys.includes(e) ? c$2("204", e) : t.sendTimeline && 2 < this.syncMetricNum || !t.sendTimeline && 5 < r ? c$2("205", e) : n && (this.custom_metric[e + "_time"] = n,
        this.customKeys.push(e),
        !t || !0 !== t.sendTimeline && null != t.sendTimeline || (r = this.getPerformanceData(),
        this.collect(_$1(_$1({}, r), {
            stack: (new Error).stack,
            event_name: "h5_custom_metric",
            custom_metric_name: e,
            custom_metric_timestamp: n
        })),
        this.syncMetricNum++)))) : c$2("200")
    }
    ,
    t.prototype.isValidTimestamp = function(e, t) {
        var n;
        if (void 0 === t && (t = "fmp"),
        void 0 !== e && "number" != typeof e)
            nt$1("201");
        else if (void 0 !== e && e < performance.timing.navigationStart)
            return a$3("210", "".concat(t)),
            null != (n = this.core) && n.collect("event", {
                name: "radar_error",
                message: "【210】".concat(t),
                extra_info: {
                    timestamp: e,
                    navigationStart: performance.timing.navigationStart
                }
            }),
            !1;
        return !0
    }
    ,
    t.prototype.fmp = function(e) {
        var t;
        this.isHit ? this.isValidTimestamp(e) && (e = e || Date.now(),
        this.hasFMP ? a$3("202") : e && performance.timing && (this.hasFMP = !0,
        this.radarTiming.fmp_time = e,
        performance.timing.radarFmp = e,
        e = this.getPerformanceData(),
        performance.timing.fmp = this.radarTiming.fmp = e.fmp,
        this.collect(_$1({
            event_name: "fmp",
            stack: (new Error).stack
        }, e)),
        null != (t = null == (e = this.core) ? void 0 : e.setCommonDimension) && t.call(e, "happen_stage", "after_fmp"))) : a$3("200")
    }
    ,
    t.prototype.getPerformanceData = function() {
        var e = _$1(_$1({}, Ye(performance.timing)), this.radarTiming)
          , t = fe(_$1(_$1({}, v$2), g$3), e);
        return Object.keys(S$1).forEach((function(n) {
            0 <= e[S$1[n]] && (t[n] = e[S$1[n]])
        }
        )),
        ["radar_main_js_start", "lcp", "cls", "fid", "fcp"].forEach((function(e) {
            var n = Pe(e);
            !n && 0 !== n || (t[e] = n)
        }
        )),
        t
    }
    ,
    t.prototype.recordApiPeriod = function(e) {
        var t;
        void 0 === this.radarTiming.fmp && (e.before_hook_time && (t = this.radarTiming.apiStart,
        this.radarTiming.apiStart = t ? Math.min(t, e.before_hook_time) : e.before_hook_time),
        e.after_hook_time && (t = this.radarTiming.apiEnd,
        this.radarTiming.apiEnd = t ? Math.max(t, e.after_hook_time) : e.after_hook_time))
    }
    ,
    t.prototype.findApiIndex = function(e) {
        return y$3((e.api || "").replace(/\?.+$/, ""), this.optionsMainAPI)
    }
    ,
    t.prototype.addRadarMainApiResult = function(e) {
        var t, n = this.findApiIndex(e);
        -1 < n && (null == (t = this.radarMainApiList[n]) || !t.api) && e.before_hook_time && (t = e.before_hook_time - performance.timing.navigationStart,
        this.radarMainApiList[n] = _$1(_$1({}, e), {
            reg: this.optionsMainAPI[n],
            start_time: t
        }))
    }
    ,
    t.prototype.addMainApiResult = function(e) {
        var t, n, r, o, i, a, s, c, l, u, p = this.findApiIndex(e);
        -1 < p && (null == (t = this.mainAPIList[p]) || !t.url) && (t = e.api,
        n = e.status,
        r = e.size,
        o = e.cached,
        i = e.method,
        a = e.perfTime,
        s = e.protocol,
        c = e.custom_failed,
        l = e.res_type,
        u = h$2(e, ["api", "status", "size", "cached", "method", "perfTime", "protocol", "custom_failed", "res_type"]),
        this.mainAPIList[p] = _$1({
            url: t,
            status: n,
            size_radar: r,
            cached: o,
            method: i,
            perfTime: a,
            protocol: s,
            res_type: l,
            custom_failed: c
        }, u),
        this.radarTiming.fmp_time && e.after_hook_time && e.after_hook_time < this.radarTiming.fmp_time && (p = this.getPerformanceData(),
        this.collect(_$1({
            event_name: "main_api"
        }, p))))
    }
    ,
    t.prototype.destroy = function() {
        he$1(window, "load", this.h5Load),
        this.customStage = this.fmp = function() {
            a$3("213")
        }
    }
    ,
    t.prototype.collect = function(e) {
        var t = e.protocol
          , n = e.event_name
          , r = (e.custom_metric,
        e.custom_metric_name)
          , o = e.stack;
        e.main_api_list,
        e = h$2(e, ["protocol", "event_name", "custom_metric", "custom_metric_name", "stack", "main_api_list"]),
        this.baseCollect({
            value: e,
            dimension: {
                protocol: t,
                event_name: n,
                custom_metric_name: r,
                custom_metric: JSON.stringify(this.custom_metric),
                main_api_list: this.mainAPIList,
                radar_main_api_list: this.radarMainApiList,
                radar_main_js_list: this.radarMainJSList,
                is_official: 1,
                stack: o
            }
        }),
        null != (e = this.core) && e.flush()
    }
    ,
    t
}(f$4)
  , b$1 = function(e, t) {
    return (b$1 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}
  , k = function() {
    return (k = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
};
function S(e, t) {
    var n = {};
    for (o in e)
        Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
    if (null != e && "function" == typeof Object.getOwnPropertySymbols)
        for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
            t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
    return n
}
var L = X
  , O = {
    navigation_start: "startTime",
    redirect_start: "redirectStart",
    redirect_end: "redirectEnd",
    dns_start: "domainLookupStart",
    dns_end: "domainLookupEnd",
    connect_start: "connectStart",
    connect_end: "connectEnd",
    ssl_start: "secureConnectionStart",
    request_start: "requestStart",
    response_start: "responseStart",
    response_end: "responseEnd"
};
function z(e) {
    return N(e, "Content-Type")
}
function N(e, t) {
    if (e)
        return "function" == typeof e.get ? e.get(t) : e[t.toLowerCase()]
}
function P$2(e) {
    var t = "";
    if ("string" == typeof e)
        t = e;
    else
        try {
            t = JSON.stringify(e)
        } catch (i) {
            t = String(e)
        }
    for (var n = 0, r = 0; r < t.length; r++) {
        var o = t.charCodeAt(r);
        n += o < 128 ? 1 : o < 2048 ? 2 : o < 65536 ? 3 : o < 1 << 21 ? 4 : o < 1 << 26 ? 5 : o < 1 << 31 ? 6 : Number.NaN
    }
    return n
}
function q(e) {
    var t = (n = document.location).protocol
      , n = n.host;
    return 0 === e.indexOf("//") ? t + e : 0 === e.indexOf("/") ? "".concat(t, "//").concat(n).concat(e) : e
}
var I = "3"
  , A = function(e) {
    function t(t) {
        var n = e.call(this, {
            core: null == (t = void 0 === t ? {} : t) ? void 0 : t.core,
            sampling: null == t ? void 0 : t.sampling,
            key: s$1.API,
            version: "1.2.12",
            name: "RadarAPICollect"
        }) || this;
        return n.ignoreList = d$2,
        n.queue = [],
        n.logList = [],
        n.perfList = [],
        n.broadcastApi = Se(),
        n.broadcastApiHook = Se(),
        n.initiatorTypeList = [],
        n.enableKtrace = !1,
        n.sequenceNumber = Number(Date.now().toString().substr(-4)),
        n.beforeHook = function(e) {
            var t;
            0 === (null == (t = e.url) ? void 0 : t.indexOf("data:")) || z$1(e.url, n.ignoreList) || z$1(e.url, (null == (t = n.core) ? void 0 : t.ignoreList) || []) || "js" === F$1(e.url) || "css" === F$1(e.url) || (t = {
                api: q(e.url),
                method: e.method,
                request: e,
                startTime: Date.now()
            },
            n.queue.push(t))
        }
        ,
        n.afterHook = function(e, t, r, o) {
            var i = n.queue.find((function(e) {
                return e.request === t
            }
            ));
            if (i) {
                delete i.request;
                var a = i.startTime
                  , s = (i = S(i, ["startTime"]),
                Date.now())
                  , c = s - a
                  , l = r.status;
                if ("function" == typeof n.customizeRadarStatus)
                    try {
                        l = n.customizeRadarStatus(r)
                    } catch (f) {
                        console.error(f)
                    }
                var u = n.customHook({
                    type: e,
                    duration: c,
                    request: t,
                    response: r,
                    error: o
                })
                  , p = +N(r.headers, "Content-Length") || 0
                  , d = Me(N(r.headers, "Server-Timing"));
                p = k(k(k({
                    res_type: e,
                    duration: c,
                    logTime: Date.now(),
                    status: l,
                    size: +p,
                    content_type: z(r.headers),
                    aborted: r.aborted || void 0,
                    custom_failed: !(200 <= l && l < 300)
                }, i), u), {
                    before_hook_time: a,
                    after_hook_time: s,
                    trace_id: t.trace_id,
                    ktrace_segment_id: t.ktrace_segment_id,
                    ktrace_biz_name: t.ktrace_biz_name,
                    ktrace_service_name: t.ktrace_service_name,
                    sequence_number: t.sequence_number,
                    has_ktrace_str: t.has_ktrace_str,
                    error_occurred: t.error_occurred,
                    log_entity: t.log_entity,
                    server_timing: d,
                    happen_stage: null == (c = null == (e = n.core) ? void 0 : e.commonDimension) ? void 0 : c.happen_stage
                });
                2 === (null == (i = null == (l = N(r.headers, "Intercept-Result")) ? void 0 : l.split(";")) ? void 0 : i.length) && null != (a = n.core) && a.setCommonDimension && (n.core.setCommonDimension("intercept_result", i[0], !1),
                n.core.setCommonDimension("intercept_result_code", i[1], !1),
                p.api_intercept_result = i[0],
                p.api_intercept_result_code = i[1]),
                r.finalUrl && (p.api = r.finalUrl),
                "string" == typeof r.text && (p.responseData = r.text),
                0 !== k(k({}, r), {
                    status: p.status
                }).status || u.intercept_report ? n.mergeAPIPerf(void 0, p) || n.logList.push(p) : (p.size && 0 != p.size || !p.responseData || (p.size = P$2(p.responseData)),
                delete p.responseData,
                delete p.server_timing,
                n.collect(p)),
                !0 !== u.intercept_report && n.broadcastApiHook.emit(k(k({}, p), {
                    responseData: void 0,
                    server_timing: void 0
                })),
                n.queue = n.queue.filter((function(e) {
                    return e.request && e.request !== t
                }
                ))
            }
        }
        ,
        void 0 !== (n.option = t) && null != t && t.core || nt$1("310"),
        void 0 !== t.ignoreList && (Array.isArray(t.ignoreList) || nt$1("309"),
        t.ignoreList.forEach((function(e) {
            "string" != typeof e && nt$1("309")
        }
        )),
        n.ignoreList = n.ignoreList.concat(t.ignoreList)),
        t.enableKtrace && (t.ktraceBizName && t.ktraceServiceName ? (n.ktraceServiceName = t.ktraceServiceName,
        n.ktraceBizName = t.ktraceBizName,
        n.enableKtrace = !0) : c$2("312", t)),
        n.APIHook = t.APIHook,
        n.customizeRadarStatus = t.customizeRadarStatus,
        n.init(),
        n
    }
    var n = t
      , r = e;
    if ("function" != typeof r && null !== r)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    function o() {
        this.constructor = n
    }
    return b$1(n, r),
    n.prototype = null === r ? Object.create(r) : (o.prototype = r.prototype,
    new o),
    t.prototype.init = function() {
        var e, t = this;
        try {
            this.observer = new PerformanceObserver((function(e) {
                return t.observeAPI(e)
            }
            )),
            this.observer.observe({
                entryTypes: ["resource"]
            }),
            this.initiatorTypeList = [],
            !0 !== this.option.ignoreXHR && (this.initiatorTypeList.push("xmlhttprequest"),
            this.unhookXML = be((function(e) {
                return t.beforeHook(e)
            }
            ), (function(e, n) {
                return t.afterHook("xmlhttprequest", e, n)
            }
            ), this.enableKtrace ? function(e) {
                return t.getKtraceStr(e)
            }
            : void 0)),
            !0 !== this.option.ignoreFetch && (this.initiatorTypeList.push("fetch"),
            this.unhookFetch = _e((function(e) {
                return t.beforeHook(e)
            }
            ), (function(e, n, r) {
                return t.afterHook("fetch", e, n, r)
            }
            ), this.enableKtrace ? function(e) {
                return t.getKtraceStr(e)
            }
            : void 0))
        } catch (n) {
            c$2("308"),
            null != (e = this.core) && e.collect("event", {
                name: "radar_error",
                message: "PerformanceObserver 不存在无法收集数据",
                category: s$1.API
            })
        }
    }
    ,
    t.prototype.getKtraceStr = function(e) {
        if (this.option.ktraceWhitelist && 0 < this.option.ktraceWhitelist.length && !z$1(e.url, this.option.ktraceWhitelist))
            return "";
        e = le(this.ktraceServiceName);
        var t = le(this.ktraceServiceName);
        return [I, t, e, 0, this.ktraceServiceName, this.ktraceBizName, !0, "src:Js,seqn:".concat(this.sequenceNumber, ",rsi:").concat(null == (t = this.core) ? void 0 : t.radarSessionId, ",path:").concat(location.pathname, ",rpi:").concat(null == (t = null == (e = this.core) ? void 0 : e.config) ? void 0 : t.projectId)].join("|")
    }
    ,
    t.prototype.customHook = function(e) {
        var t = {};
        if (void 0 === this.APIHook)
            return t;
        if ("function" != typeof this.APIHook)
            return a$3("300"),
            t;
        var n = {};
        try {
            n = this.APIHook(e)
        } catch (c) {
            return a$3("301", c),
            {}
        }
        if (!n)
            return a$3("302"),
            t;
        e = n.response_msg;
        var r = n.response_code
          , o = n.status
          , i = n.custom_failed
          , a = n.intercept_report;
        n = n.broadcast_info;
        if (!0 === Boolean(a) && (t.intercept_report = !0),
        void 0 !== e)
            try {
                var s = JSON.stringify(e);
                100 < s.length && a$3("307"),
                t.response_msg = s.slice(0, 100)
            } catch (c) {
                t.response_msg = "response_msg返回结果异常",
                a$3("303")
            }
        return void 0 !== r && (a = Number(r),
        isNaN(a) ? a$3("304") : t.response_code = a),
        void 0 !== o && (e = Number(o),
        isNaN(e) ? a$3("305") : t.status = e),
        void 0 !== i && (!0 === i || !1 === i ? t.custom_failed = i : a$3("306")),
        t.broadcast_info = n,
        t
    }
    ,
    t.prototype.observeAPI = function(e) {
        var t = this;
        e.getEntriesByType("resource").forEach((function(e) {
            var n, r, o;
            if (0 === (null == (o = e.name) ? void 0 : o.indexOf("data:")) || z$1(e.name, t.ignoreList) || z$1(e.name, (null == (o = t.core) ? void 0 : o.ignoreList) || []))
                return !1;
            "api" === ne(e) && ((o = fe(L, e)).perfTime = Date.now(),
            null != (n = null == (n = e.serverTiming) ? void 0 : n.map((function(e) {
                return {
                    name: e.name,
                    duration: e.duration,
                    description: e.description || void 0
                }
            }
            ))) && n.length || (n = void 0),
            r = {
                encoded_body_size: e.encodedBodySize,
                decoded_body_size: e.decodedBodySize
            },
            Object.keys(O).forEach((function(t) {
                r[t] = Number(e[O[t]] + performance.timing.navigationStart)
            }
            )),
            o = k(k(k(k({}, o), {
                api: o.file
            }), r), {
                server_timing: n
            }),
            t.mergeAPIPerf(o) || t.perfList.push(o))
        }
        ))
    }
    ,
    t.prototype.destroy = function() {
        this.unhookXML && this.unhookXML(),
        this.unhookFetch && this.unhookFetch(),
        this.observer && this.observer.disconnect()
    }
    ,
    t.prototype.mergeAPIPerf = function(e, t) {
        if (e ? t = this.takeItem(e, this.logList) : t && (e = this.takeItem(t, this.perfList)),
        !e || !t)
            return !1;
        if (!0 === t.intercept_report)
            return !0;
        var n, r = Object.assign({}, t, e, {
            size: e.size || t.size
        });
        return delete r.file,
        r.size && 0 != r.size || !r.responseData || (r.size = P$2(r.responseData)),
        delete r.responseData,
        (t = t.server_timing || e.server_timing) && (n = null,
        t.map((function(e) {
            "total-timing" === e.name && (n = null != (e = e.duration) ? e : null)
        }
        )),
        r.total_server_timing = n,
        r.server_data_list = JSON.stringify(t)),
        delete r.server_timing,
        this.collect(r),
        !0
    }
    ,
    t.prototype.takeItem = function(e, t) {
        var n, r = (e.api || "").replace(/\?.+$/, "");
        if (-1 !== (e = t.findIndex((function(e) {
            return e = (e.api || "").replace(/\?.+$/, ""),
            r === e
        }
        ))))
            return n = t[e],
            t.splice(e, 1),
            n
    }
    ,
    t.prototype.collect = function(e) {
        var t, n = this, r = e.res_type, o = e.protocol, a = e.api, s = e.custom_failed, c = e.status, l = e.cached, u = e.method, p = e.response_code, d = e.response_msg, f = e.server_data_list, h = e.content_type, m = e.broadcast_info, g = e.before_hook_time, v = e.after_hook_time, y = e.api_intercept_result, _ = e.api_intercept_result_code, b = e.trace_id, E = e.ktrace_segment_id, w = e.ktrace_biz_name, O = e.ktrace_service_name, T = e.sequence_number, A = e.has_ktrace_str, R = e.has_timing_allow, k = e.error_occurred, P = e.log_entity, C = e.aborted, I = e.happen_stage, N = {
            dimension: {
                before_hook_time: g,
                after_hook_time: v,
                res_type: r,
                protocol: o,
                api: a,
                custom_failed: s,
                status: c,
                cached: l,
                method: u,
                response_code: p,
                response_msg: d,
                content_type: h,
                broadcast_info: m,
                is_official: 1,
                server_data_list: f,
                trace_id: b,
                ktrace_segment_id: E,
                ktrace_biz_name: w,
                ktrace_service_name: O,
                sequence_number: T,
                has_ktrace_str: A,
                api_intercept_result: y,
                api_intercept_result_code: _,
                has_timing_allow: R,
                error_occurred: k,
                log_entity: P,
                aborted: C
            },
            value: S(e, ["res_type", "protocol", "api", "custom_failed", "status", "cached", "method", "response_code", "response_msg", "server_data_list", "content_type", "broadcast_info", "before_hook_time", "after_hook_time", "api_intercept_result", "api_intercept_result_code", "trace_id", "ktrace_segment_id", "ktrace_biz_name", "ktrace_service_name", "sequence_number", "has_ktrace_str", "has_timing_allow", "error_occurred", "log_entity", "aborted", "happen_stage"])
        };
        I && (N.dimension.happen_stage = I),
        this.broadcastApi.emit(Ye(e)),
        0 !== c ? this.baseCollect(N) : (v = (g = this.option).ignoreAborted,
        t = g.isIgnoreInvalidStatusCode,
        C && v ? i("311") : $(t) ? new Promise((function(n, r) {
            var o, i = t(e);
            Q(i) ? (o = setTimeout((function() {
                return n(!1)
            }
            ), 2e3),
            i.then((function(e) {
                clearTimeout(o),
                n(!0 === e)
            }
            ), r)) : n(!0 === i)
        }
        )).then((function(e) {
            e ? a$3("异步拦截日志") : n.baseCollect(N)
        }
        ), (function(e) {
            n.baseCollect(N),
            c$2(e)
        }
        )) : this.baseCollect(N))
    }
    ,
    t
}(f$4)
  , h$1 = function(e, t) {
    return (h$1 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}
  , g$2 = function() {
    return (g$2 = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
}
  , _$3 = Object.assign({}, X, {
    duration: {
        end: "responseEnd",
        start: "fetchStart"
    },
    cached_type: {
        custom: function(e, t) {
            var n = "hit_browser";
            if (0 === t.transferSize || 0 === t.duration)
                return n;
            if (null == t.transferSize && (0 === t.domainLookupStart || t.responseStart === t.fetchStart))
                return n;
            if (t.serverTiming && t.serverTiming.some((function(e) {
                return "cdn" === e.name
            }
            ))) {
                if (t.serverTiming.some((function(e) {
                    return "miss" === e.name
                }
                )))
                    return "miss_cdn";
                if (t.serverTiming.some((function(e) {
                    return "hit" === e.name
                }
                )))
                    return "hit_cdn"
            }
            return "miss_browser"
        },
        crossOriginSkip: !0
    },
    cdn_duration: {
        custom: function(e, t) {
            return t.serverTiming && t.serverTiming.some((function(e) {
                return "cdn" === e.name
            }
            )) ? null == (t = null == (t = t.serverTiming) ? void 0 : t.find((function(e) {
                return "total-timing" === e.name
            }
            ))) ? void 0 : t.duration : null
        },
        crossOriginSkip: !0,
        cachedSkip: !0
    },
    cdn_ip: {
        custom: function(e, t) {
            if (t.serverTiming && t.serverTiming.some((function(e) {
                return "cdn" === e.name
            }
            )))
                return null == (t = t.serverTiming.find((function(e) {
                    return "miss" === e.name || "hit" === e.name
                }
                ))) ? void 0 : t.description
        },
        crossOriginSkip: !0,
        cachedSkip: !0
    }
})
  , y$2 = {
    fetch_start_time: "fetchStart",
    redirect_start: "redirectStart",
    redirect_end: "redirectEnd",
    dns_start: "domainLookupStart",
    dns_end: "domainLookupEnd",
    connect_start: "connectStart",
    connect_end: "connectEnd",
    ssl_start: "secureConnectionStart",
    request_start: "requestStart",
    response_start: "responseStart",
    response_end: "responseEnd"
};
function v$1(e) {
    return Array.isArray(e) ? e.map((function(e) {
        var t = e.id
          , n = e.getAttribute ? e.getAttribute("class") : e.className || "";
        return e = e.tagName || "",
        t && (e += "#" + t),
        n && (e += n.split(/\s+/g).map((function(e) {
            return "." + e
        }
        )).join("")),
        e
    }
    )).filter((function(e) {
        return e
    }
    )).join(",") : ""
}
var r$2, o$2, l$1, u$3, b = function(e) {
    function t(t) {
        var n, r = this;
        return (r = e.call(this, {
            core: null == t ? void 0 : t.core,
            sampling: null != (n = null == t ? void 0 : t.sampling) ? n : .1,
            version: "1.2.12",
            key: s$1.RES,
            name: "RadarResourceCollect"
        }) || this).ignoreList = d$2,
        r.broadcastJs = Se(),
        r.resErrorListener = function(e) {
            r.onResError(e)
        }
        ,
        r.onResError = function(e, t) {
            var n;
            me(e) || (n = (e.target.src || e.target.href || "").toString(),
            n = {
                failed: !0,
                file: n = "function" != typeof e.target.getAttribute || "" !== e.target.getAttribute("src") && "" !== e.target.getAttribute("href") ? n : "",
                res_path: v$1(e && e.path || e && e.composedPath && e.composedPath())
            },
            r.collect(n, t),
            r.broadcastJs.emit(n))
        }
        ,
        r.observeResource = function(e) {
            e.getEntriesByType("resource").forEach((function(e) {
                var t, n, o;
                if (0 === e.name.indexOf("data:") || z$1(e.name, r.ignoreList) || z$1(e.name, (null == (t = r.core) ? void 0 : t.ignoreList) || []))
                    return !1;
                "resource" === ne(e) && (t = fe(_$3, e),
                n = {
                    encoded_body_size: e.encodedBodySize,
                    decoded_body_size: e.decodedBodySize
                },
                Object.keys(y$2).forEach((function(t) {
                    n[t] = Number(e[y$2[t]] + performance.timing.navigationStart)
                }
                )),
                o = g$2(g$2({
                    failed: !1
                }, t), n),
                r.collect(o),
                setTimeout((function() {
                    r.broadcastJs.emit(o)
                }
                )))
            }
            ))
        }
        ,
        r.resourceHook = t.resourceHook,
        void 0 !== t.ignoreList && (Array.isArray(t.ignoreList) || nt$1("802"),
        t.ignoreList.forEach((function(e) {
            "string" != typeof e && nt$1("802")
        }
        )),
        r.ignoreList = r.ignoreList.concat(t.ignoreList)),
        r.init(),
        t.seedLogs && r.parseSeedLog(t.seedLogs),
        r
    }
    var n = t
      , r = e;
    if ("function" != typeof r && null !== r)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    function o() {
        this.constructor = n
    }
    return h$1(n, r),
    n.prototype = null === r ? Object.create(r) : (o.prototype = r.prototype,
    new o),
    t.prototype.init = function() {
        var e, t = this;
        try {
            this.observeResource(performance),
            this.observer = new PerformanceObserver((function(e) {
                return t.observeResource(e)
            }
            )),
            this.observer.observe({
                entryTypes: ["resource"]
            })
        } catch (n) {
            c$2("801"),
            null != (e = this.core) && e.collect("event", {
                name: "radar_error",
                message: "PerformanceObserver 不存在无法收集数据",
                category: s$1.RES
            })
        }
        de$1(window, "error", this.resErrorListener, !0)
    }
    ,
    t.prototype.parseSeedLog = function(e) {
        var t = this;
        e.map((function(e) {
            var n, r = e.data;
            (n = {})[A$1] = e[A$1],
            n[P$1] = e[P$1],
            t.onResError(r, n)
        }
        ))
    }
    ,
    t.prototype.collect = function(e, t) {
        var n = e.cached
          , r = e.failed
          , o = e.file
          , i = e.protocol
          , a = e.res_type
          , s = e.res_path
          , c = e.cached_type
          , l = e.cdn_ip
          , u = e.has_timing_allow;
        e = function(e, t) {
            var n = {};
            for (o in e)
                Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols)
                for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
                    t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
            return n
        }(e, ["cached", "failed", "file", "protocol", "res_type", "res_path", "cached_type", "cdn_ip", "has_timing_allow"]);
        try {
            var p = this.resourceHook && this.resourceHook({
                file: o,
                cached: n,
                protocol: i,
                res_type: a,
                failed: r
            });
            if (null != p && p.intercept_report)
                return
        } catch (d) {
            c$2("803", d)
        }
        this.baseCollect(((p = {
            value: e,
            dimension: g$2({
                cached: n,
                failed: r,
                file: o,
                protocol: i,
                res_type: a,
                res_path: s,
                sample_rate: this.sampling,
                is_official: 1,
                cached_type: c,
                cdn_ip: l,
                has_timing_allow: u
            }, t && t[A$1] || {})
        })[P$1] = t ? t[P$1] : void 0,
        p))
    }
    ,
    t.prototype.destroy = function() {
        this.isHit && (he$1(window, "error", this.resErrorListener, !0),
        this.observer && this.observer.disconnect())
    }
    ,
    t
}(f$4), a$2 = function(e, t) {
    return (a$2 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}, c$1 = function() {
    return "".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12)
}, s$2 = function(e) {
    return {
        name: e,
        value: 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : -1,
        delta: 0,
        entries: [],
        id: c$1(),
        isFinal: !1
    }
}, u$1$1 = function(e, t) {
    try {
        var n;
        if (PerformanceObserver.supportedEntryTypes.includes(e))
            return (n = new PerformanceObserver((function(e) {
                return e.getEntries().map(t)
            }
            ))).observe({
                type: e,
                buffered: !0
            }),
            n
    } catch (r) {}
}, l$1$1 = !1, p$1 = !1, f$1 = function(e) {
    l$1$1 = !e.persisted
}, m$1 = function() {
    addEventListener("pagehide", f$1),
    addEventListener("beforeunload", (function() {}
    ))
}, d$1 = function(e) {
    var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
    p$1 || (m$1(),
    p$1 = !0),
    addEventListener("visibilitychange", (function(t) {
        t = t.timeStamp,
        "hidden" === document.visibilityState && e({
            timeStamp: t,
            isUnloading: l$1$1
        })
    }
    ), {
        capture: !0,
        once: t
    })
}, v = function(e, t, n, r) {
    var o;
    return function() {
        n && t.isFinal && n.disconnect(),
        0 <= t.value && (r || t.isFinal || "hidden" === document.visibilityState) && (t.delta = t.value - (o || 0),
        (t.delta || t.isFinal || void 0 === o) && (e(t),
        o = t.value))
    }
}, h$3 = function() {
    return void 0 === r$2 && (r$2 = "hidden" === document.visibilityState ? 0 : 1 / 0,
    d$1((function(e) {
        return e = e.timeStamp,
        r$2 = e
    }
    ), !0)),
    {
        get timeStamp() {
            return r$2
        }
    }
}, y$1 = function() {
    return o$2 = o$2 || new Promise((function(e) {
        return ["scroll", "keydown", "pointerdown"].map((function(t) {
            addEventListener(t, e, {
                once: !0,
                passive: !0,
                capture: !0
            })
        }
        ))
    }
    ))
}, F = [{
    name: "fid",
    collectFn: function(e) {
        function t(e) {
            e.startTime < r.timeStamp && (n.value = e.processingStart - e.startTime,
            n.entries.push(e),
            n.isFinal = !0,
            i())
        }
        var n = s$2("FID")
          , r = h$3()
          , o = u$1$1("first-input", t)
          , i = v(e, n, o);
        o ? d$1((function() {
            o.takeRecords().map(t),
            o.disconnect()
        }
        ), !0) : window.perfMetrics && window.perfMetrics.onFirstInputDelay && window.perfMetrics.onFirstInputDelay((function(e, t) {
            t.timeStamp < r.timeStamp && (n.value = e,
            n.isFinal = !0,
            n.entries = [{
                entryType: "first-input",
                name: t.type,
                target: t.target,
                cancelable: t.cancelable,
                startTime: t.timeStamp,
                processingStart: t.timeStamp + e
            }],
            i())
        }
        ))
    }
}, {
    name: "lcp",
    collectFn: function(e) {
        function t(e) {
            var t = e.startTime;
            t < i.timeStamp ? (o.value = t,
            o.entries.push(e)) : o.isFinal = !0,
            n()
        }
        var n, r = 1 < arguments.length && void 0 !== arguments[1] && arguments[1], o = s$2("LCP"), i = h$3(), a = u$1$1("largest-contentful-paint", t);
        a && (n = v(e, o, a, r),
        r = function() {
            o.isFinal || (a.takeRecords().map(t),
            o.isFinal = !0,
            n())
        }
        ,
        y$1().then(r),
        d$1(r, !0))
    }
}, {
    name: "cls",
    collectFn: function(e) {
        function t(e) {
            e.hadRecentInput || (o.value += e.value,
            o.entries.push(e),
            n())
        }
        var n, r = 1 < arguments.length && void 0 !== arguments[1] && arguments[1], o = s$2("CLS", 0), i = u$1$1("layout-shift", t);
        i && (n = v(e, o, i, r),
        d$1((function(e) {
            e = e.isUnloading,
            i.takeRecords().map(t),
            e && (o.isFinal = !0),
            n()
        }
        )))
    }
}, {
    name: "fcp",
    collectFn: function(e) {
        var t, n = s$2("FCP"), r = h$3(), o = u$1$1("paint", (function(e) {
            "first-contentful-paint" === e.name && e.startTime < r.timeStamp && (n.value = e.startTime,
            n.isFinal = !0,
            n.entries.push(e),
            t())
        }
        ));
        o && (t = v(e, n, o))
    }
}], g$1 = function(e) {
    function t(t) {
        var n = e.call(this, {
            core: t.core,
            sampling: t.sampling,
            version: "1.2.12",
            key: s$1.EVENT,
            name: "RadarChromeMetricsCollect"
        }) || this;
        return n.options = {
            lcp: !1,
            cls: !1,
            fid: !1,
            fcp: !1
        },
        n.init = function() {
            var e = n.options;
            F.forEach((function(t) {
                var r = t.name;
                e && !e[r] || t.collectFn((function(e) {
                    var t = e.name;
                    e = e.value,
                    Ue(t.toLocaleLowerCase(), Number(e)),
                    n.baseCollect({
                        dimension: {
                            name: t.toLocaleLowerCase(),
                            is_official: 1
                        },
                        value: {
                            duration: Number(e)
                        }
                    })
                }
                ))
            }
            ))
        }
        ,
        Object.assign(n.options, t.options),
        F.forEach((function(e) {
            var t = Oe("radar_" + e.name);
            t && (n.options[e.name] = "1" === t)
        }
        )),
        n.init(),
        n
    }
    var n = t
      , r = e;
    if ("function" != typeof r && null !== r)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    function o() {
        this.constructor = n
    }
    return a$2(n, r),
    n.prototype = null === r ? Object.create(r) : (o.prototype = r.prototype,
    new o),
    t
}(f$4), a$1$1 = function(e, t) {
    return (a$1$1 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}, c = function(e) {
    function t(t) {
        var n = e.call(this, {
            core: t.core,
            sampling: t.sampling,
            key: s$1.EVENT,
            version: "1.2.12",
            name: "RadarEventCollect"
        }) || this;
        return n.action = {
            start: function(e) {
                n._checkActionDimension(e),
                n.event({
                    name: e.name,
                    extra_info: e.extra_info,
                    event_type: "radar_action_start"
                })
            },
            end: function(e) {
                n._checkActionDimension(e),
                n.event({
                    name: e.name,
                    extra_info: e.extra_info,
                    result_type: e.result_type,
                    event_type: "radar_action_end"
                })
            }
        },
        t.seedLogs && n.parseSeedLog(t.seedLogs),
        n
    }
    var n = t
      , r = e;
    if ("function" != typeof r && null !== r)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    function o() {
        this.constructor = n
    }
    return a$1$1(n, r),
    n.prototype = null === r ? Object.create(r) : (o.prototype = r.prototype,
    new o),
    t.prototype.parseSeedLog = function(e) {
        var t = this;
        e.map((function(e) {
            var n = e.dimension
              , r = e.value;
            t.event(n, r, e[P$1])
        }
        ))
    }
    ,
    t.prototype.event = function(e, t, n) {
        this.isHit ? (e || nt$1("402"),
        void 0 !== e.name && "string" == typeof e.name || nt$1("402"),
        127 < e.name.length && (c$2("403"),
        e.name = e.name.slice(0, 127)),
        e.is_official = 1,
        t && void 0 !== t.duration && ("number" != typeof t.duration || t.duration < 0) && nt$1("404"),
        t && void 0 !== t.event_count && ("number" != typeof t.event_count || t.event_count < 0) && nt$1("405，".concat(t.event_count)),
        (t = {
            dimension: e,
            value: t
        })[P$1] = n,
        n = t,
        e && e.extra_info && "object" == typeof e.extra_info && (n.dimension.extra_info = JSON.stringify(e.extra_info)),
        this.baseCollect(n)) : a$3("401")
    }
    ,
    t.prototype.destroy = function() {
        this.event = function() {
            a$3("407")
        }
        ,
        this.action = {
            start: function() {
                a$3("407")
            },
            end: function() {
                a$3("407")
            }
        }
    }
    ,
    t.prototype._checkActionDimension = function(e) {
        if (!e)
            throw Error("408");
        void 0 === e.extra_info || e.extra_info instanceof Object || nt$1("406")
    }
    ,
    t
}(f$4), a$4 = function(e, t) {
    return (a$4 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}, p = function() {
    return (p = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
};
function f$5(e, t) {
    var n = {};
    for (o in e)
        Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
    if (null != e && "function" == typeof Object.getOwnPropertySymbols)
        for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
            t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
    return n
}
(u$3 = l$1 = l$1 || {}).SCRIPT = "script",
u$3.RES = "res",
u$3.API = "api",
u$3.VIDEO = "video";
var y = [];
function m(e, t, n) {
    var r, o;
    if (t instanceof Error)
        if ("BridgeError" === (r = t.name || "Error") && "function" == typeof t.toJSON)
            try {
                var i = t.toJSON();
                delete i.name,
                delete i.message,
                o = "".concat(t.message, " (").concat(JSON.stringify(i), ")")
            } catch (a) {
                o = t.message || ""
            }
        else
            o = t.message || "";
    else
        o = null == t && "Script error." === (null == n ? void 0 : n.message) ? (r = "CrossOriginError",
        "".concat(e, " - message: ").concat((null == n ? void 0 : n.message) || "<UNKNOWN>")) : null == t && null != n && n.message && "Uncaught undefined" !== n.message && "Uncaught null" !== n.message ? (r = "Error",
        "".concat(e, " - message: ").concat(n.message)) : (r = null == t ? "".concat(t) : typeof t,
        i = function(e) {
            var t;
            try {
                t = e.toString(),
                e && "object" == typeof e && (t = JSON.stringify(e))
            } catch (n) {}
            return "string" != typeof t || "" === t ? t = null === e ? "<NULL>" : void 0 === e ? "<UNDEFINED>" : "" === t ? "<EMPTY>" : "<UNKNOWN>" : 2e3 < t.length && (t = t.substring(0, 2e3) + "<<< ……"),
            t
        }(t),
        "".concat(e, " - value: ").concat(i));
    return {
        error_type: l$1.SCRIPT,
        error_cons_type: r,
        msg: o,
        stack: t && t.stack || n && n.stack || void 0
    }
}
function d(e) {
    for (var t = 0; t < y.length; t++)
        if (g(y[t], e))
            return t;
    return -1
}
function g(e, t) {
    return e.msg === t.msg && e.stack === t.stack && e.file === t.file && e.line === t.line && e.col === t.col
}
var E = function(e) {
    function t(t) {
        var n = e.call(this, {
            core: t.core,
            sampling: t.sampling,
            key: s$1.ERROR,
            version: "1.2.12",
            name: "RadarErrorCollect"
        }) || this;
        return n.errorListener = function(e) {
            n.onError(e)
        }
        ,
        n.promiseErrorListener = function(e) {
            n.onPromiseError(e)
        }
        ,
        n.onError = function(e, t) {
            var r;
            !(r = e).message && null == r.lineno || (e = p(p({}, m("Global Uncaught Exception", e.error, e)), {
                file: e.filename,
                line: e.lineno,
                col: e.colno
            }),
            n.isSameErrorAndReport(e, t))
        }
        ,
        n.onPromiseError = function(e, t) {
            e = m("Unhandled Promise Rejection", e.reason),
            n.isSameErrorAndReport(e, t)
        }
        ,
        n.core = t.core,
        n.init(),
        t.seedLogs && n.parseSeedLog(t.seedLogs),
        n
    }
    var n = t
      , r = e;
    if ("function" != typeof r && null !== r)
        throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    function o() {
        this.constructor = n
    }
    return a$4(n, r),
    n.prototype = null === r ? Object.create(r) : (o.prototype = r.prototype,
    new o),
    t.prototype.init = function() {
        y.splice(0),
        de$1(window, "error", this.errorListener, !0),
        de$1(window, "unhandledrejection", this.promiseErrorListener)
    }
    ,
    t.prototype.destroy = function() {
        he$1(window, "error", this.errorListener, !0),
        he$1(window, "unhandledrejection", this.promiseErrorListener),
        this.captureException = function() {
            a$3("600")
        }
    }
    ,
    t.prototype.parseSeedLog = function(e) {
        var t = this;
        (e || []).map((function(e) {
            var n, r = e.data;
            (n = {})[A$1] = e[A$1],
            n[P$1] = e[P$1],
            e = n,
            r && r.type ? "unhandledrejection" === r.type ? t.onPromiseError(r, e) : t.onError(r, e) : t.captureException(r)
        }
        ))
    }
    ,
    t.prototype.isSameErrorAndReport = function(e, t) {
        0 <= d(e) || (y.push(e),
        setTimeout((function() {
            y.splice(d(e), 1)
        }
        ), 2e3),
        this.collect(e, t))
    }
    ,
    t.prototype.collect = function(e, t) {
        n = (l = e).error_cons_type,
        r = l.file,
        o = l.error_type,
        i = l.msg,
        a = l.col,
        s = l.line,
        c = l.stack;
        var n, r, o, i, a, s, c, l = ie$1((e = {
            key: "error",
            value: f$5(l, ["error_cons_type", "file", "error_type", "msg", "col", "line", "stack"]),
            dimension: {
                error_cons_type: n,
                file: r,
                error_type: o,
                msg: i,
                col: a,
                line: s,
                stack: c
            }
        })[A$1], t && t[A$1] || {});
        this.baseCollect(((l = {
            dimension: l,
            value: e.value
        })[P$1] = t ? t[P$1] : void 0,
        l))
    }
    ,
    t.prototype.captureException = function(e) {
        this.isSameErrorAndReport(m("Captured Exception", e))
    }
    ,
    t
}(f$4);
function parseSeedLog(e) {
    var t = Xe(M);
    if (!t || e !== t)
        return {};
    if (!(e = Xe(V, [])).length)
        return {};
    var n = []
      , r = []
      , o = [];
    return e.map((function(e) {
        e.key === O$1 ? n.push(e) : e.key === x ? r.push(e) : e.key === k$1 && o.push(e)
    }
    )),
    ze(),
    {
        errorQueue: n,
        resourceQueue: r,
        eventQueue: o
    }
}
var Radar = function() {
    function e(e) {
        var t = this
          , n = (o = (this.core = new b$2({
            weblogger: e.weblog,
            projectId: e.projectId,
            sampling: null != (o = e.sampling) ? o : 1,
            httpReportFirst: e.httpReportFirst,
            customDimensions: e.customDimensions
        }),
        this.navigationCollect = new L$1({
            core: this.core,
            mainApi: e.mainApi,
            mainJs: e.mainJs
        }),
        e.unuseAPIPlugin || (this.apiCollect = new A({
            core: this.core,
            sampling: e.apiSampling,
            APIHook: e.APIHook,
            customizeRadarStatus: e.customizeRadarStatus,
            ignoreList: e.ignoreList,
            ignoreXHR: e.ignoreXHR,
            ignoreFetch: e.ignoreFetch,
            ignoreAborted: e.ignoreAborted,
            isIgnoreInvalidStatusCode: e.isIgnoreInvalidStatusCode,
            enableKtrace: e.enableKtrace,
            ktraceServiceName: e.ktraceServiceName,
            ktraceBizName: e.ktraceBizName,
            ktraceWhitelist: e.ktraceWhitelist
        }),
        this.apiCollect.broadcastApiHook.on((function(e) {
            return t.navigationCollect.dealAPIHook(e)
        }
        )),
        this.apiCollect.broadcastApi.on((function(e) {
            return t.navigationCollect.dealAPI(e)
        }
        ))),
        parseSeedLog(this.core.config.projectId))).errorQueue
          , r = o.resourceQueue
          , o = o.eventQueue;
        e.unuseResourcePlugin || (this.resourceCollect = new b({
            sampling: e.resourceSampling,
            core: this.core,
            ignoreList: e.ignoreList,
            resourceHook: e.resourceHook,
            seedLogs: r
        }),
        this.resourceCollect.broadcastJs.on((function(e) {
            return t.navigationCollect.addMainJSResult(e)
        }
        ))),
        this.chromeMetricsCollect = new g$1({
            core: this.core,
            options: {
                lcp: e.lcp,
                cls: e.cls,
                fid: e.fid,
                fcp: e.fcp
            }
        }),
        this.eventCollect = new c({
            core: this.core,
            seedLogs: o
        }),
        this.action = this.eventCollect.action,
        e.unuseErrorPlugin || (this.errorCollect = new E({
            core: this.core,
            seedLogs: n
        })),
        We()
    }
    return e.prototype.apply = function(e) {
        e && this.bindWeblogger(e)
    }
    ,
    e.prototype.bindWeblogger = function(e) {
        this.weblogger = e,
        this.core.bindWeblogger(this.weblogger)
    }
    ,
    e.prototype.event = function(e, t) {
        this.eventCollect.event(e, t)
    }
    ,
    e.prototype.customStage = function(e, t) {
        this.navigationCollect.customStage(e, t)
    }
    ,
    e.prototype.setDimensions = function(e) {
        this.core.setDimensions(e)
    }
    ,
    e.prototype.fmp = function(e) {
        "number" == typeof e ? this.navigationCollect.fmp(e) : "object" == typeof e && e.timestamp ? this.navigationCollect.fmp(e.timestamp) : this.navigationCollect.fmp()
    }
    ,
    e.prototype.captureException = function(e) {
        var t;
        this.errorCollect ? null != (t = this.errorCollect) && t.captureException(e) : console.warn("902")
    }
    ,
    e.prototype.destroy = function() {
        var e;
        null != (e = this.navigationCollect) && e.destroy(),
        null != (e = this.apiCollect) && e.destroy(),
        null != (e = this.resourceCollect) && e.destroy(),
        null != (e = this.eventCollect) && e.destroy(),
        null != (e = this.errorCollect) && e.destroy()
    }
    ,
    e.key = "radar",
    e.version = "1.2.12",
    e
}();
"undefined" != typeof window && "function" != typeof window.Radar && (window.Radar = Radar);
var e = function() {
    return (e = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var o in t = arguments[n])
                Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
    }
    ).apply(this, arguments)
}
  , r = console
  , o$1 = "ksurl.cn/csHfgepO, radar:";
r.log.bind(r, o$1);
var a$1 = r.warn.bind(r, o$1);
r.error.bind(r, o$1);
var s, u$1, f = ((u$1 = s = s || {}).LOAD = "load",
u$1.RES = "resource",
u$1.API = "api",
u$1.ERROR = "error",
u$1.SDK_ERROR = "sdk_error",
u$1.CUSTOM = "custom",
u$1.BATCH = "batch",
u$1.EVENT = "event",
u$1.BLOOD = "blood",
u$1.RUNTIME = "runtime",
function() {
    function t(e) {
        void 0 === e && (e = {});
        var t = this;
        this.broadcastSampleFb = function() {
            if (2 === (null == (e = t.core) ? void 0 : e.getWhiteUserStatus()))
                return t.sampling = 1,
                void (t.isHit = !0);
            var e = t.getSample(t.baseOptions.sampling);
            e !== t.sampling && (t.sampling = e,
            t.sampling && (t.isHit = t.samplingControl(t.sampling)))
        }
        ,
        void 0 === e && nt("100"),
        e.key || nt("101"),
        !e.core || "object" == typeof e.core.sampleData && "function" == typeof e.core.collect || nt("121"),
        this.baseOptions = e,
        this.key = e.key,
        this.version = e.version,
        this.name = e.name,
        this.isHit = !1,
        e.core && this.updateCore(e.core)
    }
    return t.prototype.updateCore = function(e) {
        var t;
        "object" == typeof e.sampleData && "function" == typeof e.collect || nt("121"),
        null != (t = this.core) && t.broadcastSample.off(this.broadcastSampleFb),
        this.core = e,
        this.sampling = this.getSample(this.baseOptions.sampling),
        this.sampling && (this.isHit = this.samplingControl(this.sampling)),
        null != (e = null == (t = this.core) ? void 0 : t.broadcastSample) && e.on(this.broadcastSampleFb)
    }
    ,
    t.prototype.getSample = function(e) {
        var t = null != (t = null == (t = this.core) ? void 0 : t.sampleData.core) ? t : 1;
        if (this.key === s.LOAD)
            return t;
        if ("number" != typeof (e = void 0 === e ? 1 : e) || e < 0 || 1 < e)
            return a$1("102", "".concat(this.key, "，采用Core的采样率").concat(null == (n = this.core) ? void 0 : n.sampleData.core)),
            t;
        var n = null != (n = this.core) && n.isInYoda ? void 0 === (null == (n = this.core) ? void 0 : n.sampleData[this.key]) ? 1 : this.core.sampleData[this.key] : e;
        return t && t < n ? (a$1("115", "".concat(this.key)),
        t) : n
    }
    ,
    t.prototype.samplingControl = function(e) {
        var t;
        return !(null == (t = this.core) || !t.sampleData.isHit) && (null == (t = this.core) ? void 0 : t.samplingControl(e / this.core.sampleData.core))
    }
    ,
    t.prototype.baseCollect = function(t) {
        var n;
        if (this.core) {
            if (this.isHit || 1 !== (null == (n = this.core) ? void 0 : n.getWhiteUserStatus())) {
                var r = t.value || {};
                r = Object.keys(r).filter((function(e) {
                    return null !== r[e] && void 0 !== r[e]
                }
                )).reduce((function(t, n) {
                    return e(e({}, t), ((t = {})[n] = r[n],
                    t))
                }
                ), {});
                try {
                    this.core.collect(t.key || this.key, e(e({
                        collect_version: this.version,
                        collect_name: this.name
                    }, t.dimension), {
                        sample_rate: this.sampling
                    }), r, t[P])
                } catch (o) {
                    a$1("126")
                }
            }
        } else
            a$1("110", "".concat(this.key))
    }
    ,
    t
}()), P = "commonData";
function oe() {
    for (var e = arguments, t = e[0], n = 1; n < e.length; n++) {
        var r = e[n];
        if (r)
            for (var o in r)
                t[o] = r[o]
    }
    return t
}
function ie(e, t, n) {
    return void 0 === n && (n = {}),
    (Object.assign || oe)({}, e, t, n)
}
function de(e, t, n, r) {
    return e.addEventListener(t, n, r)
}
function he(e, t, n, r) {
    return e.removeEventListener(t, n, r)
}
function nt(e) {
    throw new Error("radar error " + e)
}
var a = function(e, t) {
    return (a = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
}, o, l, h = {
    autoStart: !0,
    isDebug: !1,
    interval: 1e3,
    duration: 3,
    threshold: 24,
    badCostThreshold: 5
}, u = 1e3, _ = ((l = o = o || {})[l.ShortLag = 1] = "ShortLag",
l[l.MiddleLag = 2] = "MiddleLag",
l[l.LongLag = 3] = "LongLag",
function(e) {
    function t(t) {
        var n, r = this, o = ((r = e.call(this, {
            core: t.core,
            sampling: t.sampling,
            key: s.RUNTIME,
            version: "1.2.12",
            name: "RadarRunTimeCollect"
        }) || this).ticks = 0,
        r.last = 0,
        r.lastFrameTime = 0,
        r.lagList = [],
        r.lagListBuffer = [],
        r.lagStartTime = 0,
        r.handleVisibilityChange = function() {
            "hidden" === document.visibilityState && r.stop("visibilityChange"),
            "visible" === document.visibilityState && r.start()
        }
        ,
        r.callback = function(e) {
            try {
                var t, n = performance.now();
                if ("stop" === r._loopStatus)
                    return r.stop("callback"),
                    !1;
                e = e || n,
                r.handleLongFrame(e),
                r.ticks += 1,
                e - r.last >= r._interval && (t = r.fpsCounter(e),
                r.fpsReport(t)),
                r._costList.push(performance.now() - n),
                r._reportCost(),
                r._rafId = requestAnimationFrame(r.callback)
            } catch (o) {
                r.reportError(o)
            }
        }
        ,
        performance.now());
        t = ie({}, h, t),
        r._costList = [],
        r._fpsList = [],
        r._rafId = 0,
        r._isDebug = t.isDebug,
        r._interval = t.interval,
        r._threshold = t.threshold,
        r._badCostThreshold = t.badCostThreshold,
        r._loopStatus = "stop",
        r._duration = t.duration,
        r._startTimestamp = null,
        r._addListener = null == (n = t.yoda) ? void 0 : n.addListener,
        r._removeListener = null == (n = t.yoda) ? void 0 : n.removeListener,
        r.debounceReportLag = function(e) {
            var t, n = 0;
            return function() {
                for (var r = this, o = [], i = 0; i < arguments.length; i++)
                    o[i] = arguments[i];
                var a = Date.now()
                  , s = (clearTimeout(t),
                a - (n = n || a));
                s = Math.min(1050, 5e3 - s),
                t = setTimeout((function() {
                    n = a,
                    e.apply(r, o)
                }
                ), s)
            }
        }(r.reportLag);
        try {
            if ("function" != typeof requestAnimationFrame)
                return r.destroy(!1),
                r;
            if (!r.isHit)
                return r.destroy(!1),
                r;
            t.autoStart && r.start(),
            de(document, "visibilitychange", r.handleVisibilityChange.bind(r)),
            r.removeYodaListener = r.initYodaListener(),
            r._isDebug && console.log("初始化耗时: ", performance.now() - o)
        } catch (i) {
            r.reportError(i)
        }
        return r
    }
    return function(e, t) {
        if ("function" != typeof t && null !== t)
            throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        function n() {
            this.constructor = e
        }
        a(e, t),
        e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
        new n)
    }(t, e),
    t.prototype.initYodaListener = function() {
        var e, t, n, r, o, i, a = this;
        if (this._addListener && this._removeListener)
            return e = function(e) {
                a.stop("native_background")
            }
            ,
            this._addListener("native_background", e),
            t = function(e) {
                a.start()
            }
            ,
            this._addListener("native_foreground", t),
            n = function(e) {
                a.stop("native_leave")
            }
            ,
            this._addListener("native_leave", n),
            r = function(e) {
                a.stop("will_leave")
            }
            ,
            this._addListener("will_leave", r),
            o = function(e) {
                a.start()
            }
            ,
            this._addListener("native_reentry", o),
            i = function(e) {
                !0 === e.visible ? a.start() : !1 === e.visible && a.stop()
            }
            ,
            this._addListener("native_visible", i),
            function() {
                a._removeListener && (a._removeListener("native_background", e),
                a._removeListener("native_foreground", t),
                a._removeListener("native_leave", n),
                a._removeListener("will_leave", r),
                a._removeListener("native_reentry", o),
                a._removeListener("native_visible", i))
            }
    }
    ,
    t.prototype.reportError = function(e) {
        console.error(e),
        this.baseCollect({
            dimension: {
                name: "radar_run_time_error",
                event_type: "radar_run_time",
                extra_info: e
            },
            key: "event"
        }),
        this.stop()
    }
    ,
    t.prototype.handleLongFrame = function(e) {
        var t = e - this.lastFrameTime;
        this.lastFrameTime = e,
        84 <= t && this.lagList.push(t),
        e - this.lagStartTime < u || 0 === this.lagList.length || (this.lagListBuffer = this.lagListBuffer.concat(this.lagList),
        this.lagList = [],
        this.debounceReportLag(),
        this.lagStartTime = e)
    }
    ,
    t.prototype.reportLag = function() {
        var e = []
          , t = []
          , n = []
          , r = []
          , i = (this.lagListBuffer.forEach((function(e) {
            (e < 232 ? t : e < 5e3 ? n : r).push(e)
        }
        )),
        e.push(this.handleLagList(t, o.ShortLag)),
        e.push(this.handleLagList(n, o.MiddleLag)),
        e.push(this.handleLagList(r, o.LongLag)),
        performance.now())
          , a = i - (this._startTimestamp || 0);
        this._startTimestamp = i,
        this.baseCollect({
            dimension: {
                name: "radar_run_time_frame_lag",
                event_type: "radar_run_time",
                extra_info: e.filter((function(e) {
                    return !!e
                }
                ))
            },
            value: {
                duration: a
            },
            key: "event"
        }),
        this.lagListBuffer = []
    }
    ,
    t.prototype.handleLagList = function(e, t) {
        if (e.length)
            return {
                type: t,
                duration: e.reduce((function(e, t) {
                    return e + t
                }
                )),
                times: e.length,
                detail: e
            }
    }
    ,
    t.prototype.fpsCounter = function(e) {
        var t = e - this.last;
        return t = Math.round(1e3 / (t / this.ticks)),
        this.last = e,
        this.ticks = 0,
        this._isDebug && console.log("fps: ", t),
        t
    }
    ,
    t.prototype.fpsReport = function(e) {
        e < this._threshold ? this._fpsList.push(e) : this._fpsList = [],
        this._fpsList.length >= this._duration && (this.baseCollect({
            dimension: {
                name: "radar_run_time_fps",
                event_type: "radar_run_time",
                extra_info: JSON.stringify(this._fpsList)
            },
            key: "event"
        }),
        this._fpsList = [])
    }
    ,
    t.prototype.start = function() {
        if ("start" !== this._loopStatus)
            return this._rafId || (this._rafId = requestAnimationFrame(this.callback),
            this._loopStatus = "start",
            this.last = performance.now(),
            this._startTimestamp = this.last,
            this.lagStartTime = this.last,
            this.lastFrameTime = this.last,
            this._rafId)
    }
    ,
    t.prototype.stop = function(e) {
        var t;
        "stop" !== this._loopStatus && (t = performance.now(),
        this._loopStatus = "stop",
        cancelAnimationFrame(this._rafId),
        this._rafId = 0,
        this.lagList.length || this.lagListBuffer.length ? (this.lagListBuffer = this.lagListBuffer.concat(this.lagList),
        this.reportLag()) : this.baseCollect({
            dimension: {
                name: "radar_run_time_duration",
                event_type: "radar_run_time",
                category: e
            },
            value: {
                duration: t - (this._startTimestamp || 0)
            },
            key: "event"
        }),
        null != (e = this.core) && e.flush())
    }
    ,
    t.prototype._reportCost = function() {
        this._costList.length < 100 || (this._costList.filter((function(e) {
            return .5 < e
        }
        )).length >= this._badCostThreshold && this.baseCollect({
            dimension: {
                name: "radar_run_time_fps_cost",
                event_type: "radar_run_time",
                extra_info: JSON.stringify(this._costList)
            },
            key: "event"
        }),
        this._costList = [])
    }
    ,
    t.prototype.destroy = function(e) {
        (e = void 0 === e || e) && this.stop("destroy"),
        this.start = function() {
            return a$1("407"),
            -1
        }
        ,
        this.stop = function() {
            a$1("407")
        }
        ,
        he(document, "visibilitychange", this.handleVisibilityChange.bind(this)),
        this.removeYodaListener && this.removeYodaListener()
    }
    ,
    t
}(f));
function getCookie(e) {
    const t = document.cookie.split("; ");
    let n;
    for (const r of t)
        if (n = r.split("="),
        n[0] === e)
            return decodeURIComponent(n[1] || "");
    return null
}
const isInYoda = () => {
    const e = navigator.userAgent
      , t = e.indexOf("Kim/") > -1;
    return e.indexOf("Yoda/") > -1 && !t
}
  , defaultInitParams = {
    env: "production"
}
  , defaultBaseParams = {
    product_name: getCookie("kpn") || "KUAISHOU",
    user_id: getCookie("ud") || getCookie("userId") || ""
}
  , defaultRadarOptions = {
    sampling: 1,
    lcp: !0,
    cls: !0,
    fid: !0,
    fcp: !0,
    customDimensions: {
        release_tag: null == (_a = window.kfxEnv) ? void 0 : _a.channelId,
        product_version: (null == (_b = window.kfxEnv) ? void 0 : _b.version) || ("undefined" != typeof __COMMIT_ID__ ? __COMMIT_ID__ : ""),
        c_dimension1: window.__USE_SSR__,
        c_dimension2: null == (_c = window.ENV_INFO) ? void 0 : _c.icfo
    }
};
class LockableQueue {
    constructor() {
        __publicField(this, "data", []),
        __publicField(this, "transformers", []),
        __publicField(this, "listeners", []),
        __publicField(this, "locked", null),
        __publicField(this, "unlockHandler", null),
        __publicField(this, "registerMapper", ( (e, t) => {
            this.transformers.push([e, t])
        }
        )),
        __publicField(this, "unregisterMapper", ( (e, t) => {
            this.transformers = this.transformers.filter(( ([n,r]) => n !== e && r !== t))
        }
        ))
    }
    async add(e) {
        this.locked && await this.locked,
        this.data.push(e),
        this.emit()
    }
    emit() {
        this.data.forEach((e => {
            this.transformers.forEach(( ([t,n]) => {
                t(e) && (e = n(e))
            }
            )),
            this.listeners.forEach((t => {
                t(e)
            }
            ))
        }
        )),
        this.data = []
    }
    on(e) {
        this.listeners.push(e)
    }
    off(e) {
        this.listeners = this.listeners.filter((t => t !== e))
    }
    lock() {
        this.locked || (this.locked = new Promise((e => {
            this.unlockHandler = e
        }
        )))
    }
    unlock() {
        var e;
        null == (e = this.unlockHandler) || e.call(this),
        this.locked = null
    }
}
let weblog, radar;
const debugLog = (e, t) => t
  , sendFmp$1 = e => {
    radar ? radar.fmp(e) : console.error("上报Fmp依赖初始化radar，请先使用initLogger进行初始化")
}
  , initLogger = (e, t=!0, n=!1) => {
    var r, o;
    const i = Object.assign({}, defaultInitParams, e.initParamsConfig)
      , a = Object.assign({}, defaultBaseParams, e.baseParamsConfig);
    if (weblog = new lt(i,a),
    !e.radarId)
        throw new Error("请设置radarId，来保证雷达功能正常使用");
    radar = new Radar(Object.assign({}, defaultRadarOptions, {
        weblog: weblog,
        projectId: e.radarId,
        ...(null == (r = e.pluginsOption) ? void 0 : r.radar) || {}
    })),
    n && (console.log("Send FMP in SSR"),
    radar.fmp(null == (o = performance.timing) ? void 0 : o.ssrFmp)),
    t && isInYoda() && __vitePreload((async () => {
        const {addListener: e, removeListener: t} = await Promise.resolve().then(( () => yoda$1));
        return {
            addListener: e,
            removeListener: t
        }
    }
    ), [], "").then(( ({addListener: e, removeListener: t}) => {
        new _({
            core: null == radar ? void 0 : radar.core,
            yoda: {
                addListener: e,
                removeListener: t
            }
        })
    }
    ), ( () => {
        console.log("import @yoda/bridge failed")
    }
    ));
    const s = new LockableQueue;
    s.lock(),
    s.on((e => {
        "show" === e.logType ? null == weblog || weblog.collect("SHOW", debugLog("SHOW", {
            action: e.data.action,
            params: e.data.params
        })) : "click" === e.logType && (null == weblog || weblog.collect("CLICK", debugLog("CLICK", {
            action: e.data.action,
            params: e.data.params
        })))
    }
    ));
    return {
        weblog: weblog,
        radar: radar,
        queue: s,
        sendClick: (e, t={}) => {
            s.add({
                logType: "click",
                data: {
                    action: e,
                    params: t
                }
            })
        }
        ,
        sendClickImmediately: (e, t) => {
            null == weblog || weblog.sendImmediately("CLICK", debugLog("CLICK", {
                action: e,
                params: t
            }))
        }
        ,
        sendShow: (e, t={}) => {
            s.add({
                logType: "show",
                data: {
                    action: e,
                    params: t
                }
            })
        }
        ,
        sendShowImmediately: (e, t) => {
            null == weblog || weblog.sendImmediately("SHOW", debugLog("SHOW", {
                action: e,
                params: t
            }))
        }
        ,
        registerMapper: s.registerMapper,
        unregisterMapper: s.unregisterMapper,
        registerPV: function(e) {},
        sendFmp: sendFmp$1
    }
}
  , getClickDirectiveHook = e => (t, n) => {
    if (!n.value)
        return;
    t.__currentLogClickHandler && (t.removeEventListener("click", t.__currentLogClickHandler, !0),
    t.__currentLogClickHandler = null);
    const r = () => {
        const {action: t, params: r={}} = n.value;
        e.sendClick(t, r)
    }
    ;
    t.__currentLogClickHandler = r,
    t.addEventListener("click", r, !0)
}
  , getShowDirectiveHook = e => (t, n) => {
    if (!n.value)
        return;
    const r = new IntersectionObserver((r => {
        if (0 !== r.length && r[r.length - 1].isIntersecting) {
            if (JSON.stringify(n.value) === t.__currentLogInfo && !n.modifiers.every)
                return;
            const {action: r, params: o={}} = n.value;
            e.sendShow(r, o),
            t.__currentLogInfo = JSON.stringify(n.value)
        }
    }
    ))
      , o = t.__currentShowObserver || null;
    o && o.unobserve(t),
    r.observe(t),
    t.__currentShowObserver = r
}
;
function createUseLogger() {
    return function() {
        const e = inject("logger");
        return {
            ...e,
            usePV: function() {
                let t = e => {}
                ;
                const n = new Promise((e => {
                    t = e
                }
                ));
                return e.registerPV(( () => n)),
                {
                    addParamsToPV: t
                }
            }
        }
    }
}
function useAutoPv(e, t, n) {
    let r = null;
    t.registerPV = e => {
        r && console.error("[useAutoPV] 当前页面存在多个 registerPV 调用，请检查"),
        r = e,
        onBeforeRouteLeave(( (e, t, n) => {
            r = null,
            n()
        }
        ))
    }
    ,
    e.beforeEach(( (e, n, r) => {
        t.queue.lock(),
        r()
    }
    )),
    e.afterEach((async (e, o) => {
        await nextTick(),
        e.meta.LOG_PAGE || console.warn("[useAutoPV] 路由 ".concat(e.path, " 没有设置 LOG_PAGE，请检查 router 配置"));
        const [i,a] = await Promise.all([(null == n ? void 0 : n(e, o)) || {}, (null == r ? void 0 : r(e, o)) || {}]);
        t.weblog.sendImmediately("PV", debugLog("PV", {
            type: "enter",
            page: e.meta.LOG_PAGE || e.fullPath,
            params: {
                ...i.params,
                ...a.params
            },
            ...e.meta.IS_CO_PAGE ? {
                coPage: !0
            } : {}
        })),
        t.queue.unlock()
    }
    ))
}
function createLoggerDirective() {
    return {
        mounted(e, t, ...n) {
            var r, o, i, a;
            const s = (null == (o = null == (r = t.instance) ? void 0 : r.$.appContext.provides) ? void 0 : o.logger) || (null == (a = null == (i = t.instance) ? void 0 : i.$.provides) ? void 0 : a.logger) || null;
            if (!s)
                return void console.error("[createLoggerDirective] 请在组件上通过 `logger` 的 key 注入 LoggerUtils");
            if (!t.value)
                return;
            const c = getClickDirectiveHook(s)
              , l = getShowDirectiveHook(s);
            if (t.modifiers.both)
                c(e, t),
                l(e, t);
            else if ("click" === t.value.type)
                c(e, t);
            else if ("show" === t.value.type)
                return void l(e, t)
        },
        updated(e, t, ...n) {
            var r, o, i, a;
            const s = (null == (o = null == (r = t.instance) ? void 0 : r.$.appContext.provides) ? void 0 : o.logger) || (null == (a = null == (i = t.instance) ? void 0 : i.$.provides) ? void 0 : a.logger) || null;
            if (!s)
                return void console.error("[createLoggerDirective] 请在组件上通过 `logger` 的 key 注入 LoggerUtils");
            if (!t.value)
                return;
            const c = getClickDirectiveHook(s)
              , l = getShowDirectiveHook(s);
            if (t.modifiers.both)
                c(e, t),
                l(e, t);
            else if ("click" === t.value.type)
                c(e, t);
            else if ("show" === t.value.type)
                return void l(e, t)
        },
        unmounted(e) {
            e.__currentLogClickHandler && (e.removeEventListener("click", e.__currentLogClickHandler),
            e.__currentLogClickHandler = null),
            e.__currentShowObserver && (e.__currentShowObserver.unobserve(e),
            e.__currentShowObserver.disconnect(),
            e.__currentShowObserver = null)
        }
    }
}
function bind$1(e, t) {
    return function() {
        return e.apply(t, arguments)
    }
}
const {toString: toString} = Object.prototype
  , {getPrototypeOf: getPrototypeOf} = Object
  , kindOf = (e => t => {
    const n = toString.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , kindOfTest = e => (e = e.toLowerCase(),
t => kindOf(t) === e)
  , typeOfTest = e => t => typeof t === e
  , {isArray: isArray} = Array
  , isUndefined = typeOfTest("undefined");
function isBuffer(e) {
    return null !== e && !isUndefined(e) && null !== e.constructor && !isUndefined(e.constructor) && isFunction$1(e.constructor.isBuffer) && e.constructor.isBuffer(e)
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(e) {
    let t;
    return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && isArrayBuffer(e.buffer),
    t
}
const isString$1 = typeOfTest("string")
  , isFunction$1 = typeOfTest("function")
  , isNumber = typeOfTest("number")
  , isObject = e => null !== e && "object" == typeof e
  , isBoolean = e => !0 === e || !1 === e
  , isPlainObject = e => {
    if ("object" !== kindOf(e))
        return !1;
    const t = getPrototypeOf(e);
    return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e)
}
  , isDate = kindOfTest("Date")
  , isFile = kindOfTest("File")
  , isBlob = kindOfTest("Blob")
  , isFileList = kindOfTest("FileList")
  , isStream = e => isObject(e) && isFunction$1(e.pipe)
  , isFormData = e => {
    let t;
    return e && ("function" == typeof FormData && e instanceof FormData || isFunction$1(e.append) && ("formdata" === (t = kindOf(e)) || "object" === t && isFunction$1(e.toString) && "[object FormData]" === e.toString()))
}
  , isURLSearchParams = kindOfTest("URLSearchParams")
  , [isReadableStream,isRequest,isResponse,isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest)
  , trim$1 = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(e, t, {allOwnKeys: n=!1}={}) {
    if (null == e)
        return;
    let r, o;
    if ("object" != typeof e && (e = [e]),
    isArray(e))
        for (r = 0,
        o = e.length; r < o; r++)
            t.call(null, e[r], r, e);
    else {
        const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
          , i = o.length;
        let a;
        for (r = 0; r < i; r++)
            a = o[r],
            t.call(null, e[a], a, e)
    }
}
function findKey(e, t) {
    t = t.toLowerCase();
    const n = Object.keys(e);
    let r, o = n.length;
    for (; o-- > 0; )
        if (r = n[o],
        t === r.toLowerCase())
            return r;
    return null
}
const _global$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
  , isContextDefined = e => !isUndefined(e) && e !== _global$1;
function merge$1() {
    const {caseless: e} = isContextDefined(this) && this || {}
      , t = {}
      , n = (n, r) => {
        const o = e && findKey(t, r) || r;
        isPlainObject(t[o]) && isPlainObject(n) ? t[o] = merge$1(t[o], n) : isPlainObject(n) ? t[o] = merge$1({}, n) : isArray(n) ? t[o] = n.slice() : t[o] = n
    }
    ;
    for (let r = 0, o = arguments.length; r < o; r++)
        arguments[r] && forEach(arguments[r], n);
    return t
}
const extend$1 = (e, t, n, {allOwnKeys: r}={}) => (forEach(t, ( (t, r) => {
    n && isFunction$1(t) ? e[r] = bind$1(t, n) : e[r] = t
}
), {
    allOwnKeys: r
}),
e)
  , stripBOM = e => (65279 === e.charCodeAt(0) && (e = e.slice(1)),
e)
  , inherits = (e, t, n, r) => {
    e.prototype = Object.create(t.prototype, r),
    e.prototype.constructor = e,
    Object.defineProperty(e, "super", {
        value: t.prototype
    }),
    n && Object.assign(e.prototype, n)
}
  , toFlatObject = (e, t, n, r) => {
    let o, i, a;
    const s = {};
    if (t = t || {},
    null == e)
        return t;
    do {
        for (o = Object.getOwnPropertyNames(e),
        i = o.length; i-- > 0; )
            a = o[i],
            r && !r(a, e, t) || s[a] || (t[a] = e[a],
            s[a] = !0);
        e = !1 !== n && getPrototypeOf(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t
}
  , endsWith = (e, t, n) => {
    e = String(e),
    (void 0 === n || n > e.length) && (n = e.length),
    n -= t.length;
    const r = e.indexOf(t, n);
    return -1 !== r && r === n
}
  , toArray = e => {
    if (!e)
        return null;
    if (isArray(e))
        return e;
    let t = e.length;
    if (!isNumber(t))
        return null;
    const n = new Array(t);
    for (; t-- > 0; )
        n[t] = e[t];
    return n
}
  , isTypedArray = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && getPrototypeOf(Uint8Array))
  , forEachEntry = (e, t) => {
    const n = (e && e[Symbol.iterator]).call(e);
    let r;
    for (; (r = n.next()) && !r.done; ) {
        const n = r.value;
        t.call(e, n[0], n[1])
    }
}
  , matchAll = (e, t) => {
    let n;
    const r = [];
    for (; null !== (n = e.exec(t)); )
        r.push(n);
    return r
}
  , isHTMLForm = kindOfTest("HTMLFormElement")
  , toCamelCase = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, n) {
    return t.toUpperCase() + n
}
))
  , hasOwnProperty = ( ({hasOwnProperty: e}) => (t, n) => e.call(t, n))(Object.prototype)
  , isRegExp = kindOfTest("RegExp")
  , reduceDescriptors = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e)
      , r = {};
    forEach(n, ( (n, o) => {
        let i;
        !1 !== (i = t(n, o, e)) && (r[o] = i || n)
    }
    )),
    Object.defineProperties(e, r)
}
  , freezeMethods = e => {
    reduceDescriptors(e, ( (t, n) => {
        if (isFunction$1(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
            return !1;
        const r = e[n];
        isFunction$1(r) && (t.enumerable = !1,
        "writable"in t ? t.writable = !1 : t.set || (t.set = () => {
            throw Error("Can not rewrite read-only method '" + n + "'")
        }
        ))
    }
    ))
}
  , toObjectSet = (e, t) => {
    const n = {}
      , r = e => {
        e.forEach((e => {
            n[e] = !0
        }
        ))
    }
    ;
    return isArray(e) ? r(e) : r(String(e).split(t)),
    n
}
  , noop$1 = () => {}
  , toFiniteNumber = (e, t) => null != e && Number.isFinite(e = +e) ? e : t
  , ALPHA = "abcdefghijklmnopqrstuvwxyz"
  , DIGIT = "0123456789"
  , ALPHABET = {
    DIGIT: DIGIT,
    ALPHA: ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}
  , generateString = (e=16, t=ALPHABET.ALPHA_DIGIT) => {
    let n = "";
    const {length: r} = t;
    for (; e--; )
        n += t[Math.random() * r | 0];
    return n
}
;
function isSpecCompliantForm(e) {
    return !!(e && isFunction$1(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
}
const toJSONObject = e => {
    const t = new Array(10)
      , n = (e, r) => {
        if (isObject(e)) {
            if (t.indexOf(e) >= 0)
                return;
            if (!("toJSON"in e)) {
                t[r] = e;
                const o = isArray(e) ? [] : {};
                return forEach(e, ( (e, t) => {
                    const i = n(e, r + 1);
                    !isUndefined(i) && (o[t] = i)
                }
                )),
                t[r] = void 0,
                o
            }
        }
        return e
    }
    ;
    return n(e, 0)
}
  , isAsyncFn = kindOfTest("AsyncFunction")
  , isThenable = e => e && (isObject(e) || isFunction$1(e)) && isFunction$1(e.then) && isFunction$1(e.catch)
  , _setImmediate = (setImmediateSupported = "function" == typeof setImmediate,
postMessageSupported = isFunction$1(_global$1.postMessage),
setImmediateSupported ? setImmediate : postMessageSupported ? (token = "axios@".concat(Math.random()),
callbacks = [],
_global$1.addEventListener("message", ( ({source: e, data: t}) => {
    e === _global$1 && t === token && callbacks.length && callbacks.shift()()
}
), !1),
e => {
    callbacks.push(e),
    _global$1.postMessage(token, "*")
}
) : e => setTimeout(e));
var setImmediateSupported, postMessageSupported, token, callbacks;
const asap = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(_global$1) : "undefined" != typeof process && process.nextTick || _setImmediate
  , utils$1 = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber,
    isBoolean: isBoolean,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isReadableStream: isReadableStream,
    isRequest: isRequest,
    isResponse: isResponse,
    isHeaders: isHeaders,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isRegExp: isRegExp,
    isFunction: isFunction$1,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isTypedArray: isTypedArray,
    isFileList: isFileList,
    forEach: forEach,
    merge: merge$1,
    extend: extend$1,
    trim: trim$1,
    stripBOM: stripBOM,
    inherits: inherits,
    toFlatObject: toFlatObject,
    kindOf: kindOf,
    kindOfTest: kindOfTest,
    endsWith: endsWith,
    toArray: toArray,
    forEachEntry: forEachEntry,
    matchAll: matchAll,
    isHTMLForm: isHTMLForm,
    hasOwnProperty: hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors: reduceDescriptors,
    freezeMethods: freezeMethods,
    toObjectSet: toObjectSet,
    toCamelCase: toCamelCase,
    noop: noop$1,
    toFiniteNumber: toFiniteNumber,
    findKey: findKey,
    global: _global$1,
    isContextDefined: isContextDefined,
    ALPHABET: ALPHABET,
    generateString: generateString,
    isSpecCompliantForm: isSpecCompliantForm,
    toJSONObject: toJSONObject,
    isAsyncFn: isAsyncFn,
    isThenable: isThenable,
    setImmediate: _setImmediate,
    asap: asap
};
function AxiosError(e, t, n, r, o) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
    this.message = e,
    this.name = "AxiosError",
    t && (this.code = t),
    n && (this.config = n),
    r && (this.request = r),
    o && (this.response = o,
    this.status = o.status ? o.status : null)
}
utils$1.inherits(AxiosError, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const prototype$1 = AxiosError.prototype
  , descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => {
    descriptors[e] = {
        value: e
    }
}
)),
Object.defineProperties(AxiosError, descriptors),
Object.defineProperty(prototype$1, "isAxiosError", {
    value: !0
}),
AxiosError.from = (e, t, n, r, o, i) => {
    const a = Object.create(prototype$1);
    return utils$1.toFlatObject(e, a, (function(e) {
        return e !== Error.prototype
    }
    ), (e => "isAxiosError" !== e)),
    AxiosError.call(a, e.message, t, n, r, o),
    a.cause = e,
    a.name = e.name,
    i && Object.assign(a, i),
    a
}
;
const httpAdapter = null;
function isVisitable(e) {
    return utils$1.isPlainObject(e) || utils$1.isArray(e)
}
function removeBrackets(e) {
    return utils$1.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function renderKey(e, t, n) {
    return e ? e.concat(t).map((function(e, t) {
        return e = removeBrackets(e),
        !n && t ? "[" + e + "]" : e
    }
    )).join(n ? "." : "") : t
}
function isFlatArray(e) {
    return utils$1.isArray(e) && !e.some(isVisitable)
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, (function(e) {
    return /^is[A-Z]/.test(e)
}
));
function toFormData(e, t, n) {
    if (!utils$1.isObject(e))
        throw new TypeError("target must be an object");
    t = t || new FormData;
    const r = (n = utils$1.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, (function(e, t) {
        return !utils$1.isUndefined(t[e])
    }
    ))).metaTokens
      , o = n.visitor || l
      , i = n.dots
      , a = n.indexes
      , s = (n.Blob || "undefined" != typeof Blob && Blob) && utils$1.isSpecCompliantForm(t);
    if (!utils$1.isFunction(o))
        throw new TypeError("visitor must be a function");
    function c(e) {
        if (null === e)
            return "";
        if (utils$1.isDate(e))
            return e.toISOString();
        if (!s && utils$1.isBlob(e))
            throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        return utils$1.isArrayBuffer(e) || utils$1.isTypedArray(e) ? s && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e
    }
    function l(e, n, o) {
        let s = e;
        if (e && !o && "object" == typeof e)
            if (utils$1.endsWith(n, "{}"))
                n = r ? n : n.slice(0, -2),
                e = JSON.stringify(e);
            else if (utils$1.isArray(e) && isFlatArray(e) || (utils$1.isFileList(e) || utils$1.endsWith(n, "[]")) && (s = utils$1.toArray(e)))
                return n = removeBrackets(n),
                s.forEach((function(e, r) {
                    !utils$1.isUndefined(e) && null !== e && t.append(!0 === a ? renderKey([n], r, i) : null === a ? n : n + "[]", c(e))
                }
                )),
                !1;
        return !!isVisitable(e) || (t.append(renderKey(o, n, i), c(e)),
        !1)
    }
    const u = []
      , p = Object.assign(predicates, {
        defaultVisitor: l,
        convertValue: c,
        isVisitable: isVisitable
    });
    if (!utils$1.isObject(e))
        throw new TypeError("data must be an object");
    return function e(n, r) {
        if (!utils$1.isUndefined(n)) {
            if (-1 !== u.indexOf(n))
                throw Error("Circular reference detected in " + r.join("."));
            u.push(n),
            utils$1.forEach(n, (function(n, i) {
                !0 === (!(utils$1.isUndefined(n) || null === n) && o.call(t, n, utils$1.isString(i) ? i.trim() : i, r, p)) && e(n, r ? r.concat(i) : [i])
            }
            )),
            u.pop()
        }
    }(e),
    t
}
function encode$3(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
        return t[e]
    }
    ))
}
function AxiosURLSearchParams(e, t) {
    this._pairs = [],
    e && toFormData(e, this, t)
}
const prototype = AxiosURLSearchParams.prototype;
function encode$2(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function buildURL(e, t, n) {
    if (!t)
        return e;
    const r = n && n.encode || encode$2
      , o = n && n.serialize;
    let i;
    if (i = o ? o(t, n) : utils$1.isURLSearchParams(t) ? t.toString() : new AxiosURLSearchParams(t,n).toString(r),
    i) {
        const t = e.indexOf("#");
        -1 !== t && (e = e.slice(0, t)),
        e += (-1 === e.indexOf("?") ? "?" : "&") + i
    }
    return e
}
prototype.append = function(e, t) {
    this._pairs.push([e, t])
}
,
prototype.toString = function(e) {
    const t = e ? function(t) {
        return e.call(this, t, encode$3)
    }
    : encode$3;
    return this._pairs.map((function(e) {
        return t(e[0]) + "=" + t(e[1])
    }
    ), "").join("&")
}
;
class InterceptorManager {
    constructor() {
        this.handlers = []
    }
    use(e, t, n) {
        return this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        utils$1.forEach(this.handlers, (function(t) {
            null !== t && e(t)
        }
        ))
    }
}
const transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , URLSearchParams$1 = "undefined" != typeof URLSearchParams ? URLSearchParams : AxiosURLSearchParams
  , FormData$1 = "undefined" != typeof FormData ? FormData : null
  , Blob$1 = "undefined" != typeof Blob ? Blob : null
  , platform$1 = {
    isBrowser: !0,
    classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , hasBrowserEnv = "undefined" != typeof window && "undefined" != typeof document
  , _navigator = "object" == typeof navigator && navigator || void 0
  , hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0)
  , hasStandardBrowserWebWorkerEnv = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts
  , origin$1 = hasBrowserEnv && window.location.href || "http://localhost"
  , utils = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin: origin$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , platform = {
    ...utils,
    ...platform$1
};
function toURLEncodedForm(e, t) {
    return toFormData(e, new platform.classes.URLSearchParams, Object.assign({
        visitor: function(e, t, n, r) {
            return platform.isNode && utils$1.isBuffer(e) ? (this.append(t, e.toString("base64")),
            !1) : r.defaultVisitor.apply(this, arguments)
        }
    }, t))
}
function parsePropPath(e) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0]))
}
function arrayToObject(e) {
    const t = {}
      , n = Object.keys(e);
    let r;
    const o = n.length;
    let i;
    for (r = 0; r < o; r++)
        i = n[r],
        t[i] = e[i];
    return t
}
function formDataToJSON(e) {
    function t(e, n, r, o) {
        let i = e[o++];
        if ("__proto__" === i)
            return !0;
        const a = Number.isFinite(+i)
          , s = o >= e.length;
        if (i = !i && utils$1.isArray(r) ? r.length : i,
        s)
            return utils$1.hasOwnProp(r, i) ? r[i] = [r[i], n] : r[i] = n,
            !a;
        r[i] && utils$1.isObject(r[i]) || (r[i] = []);
        return t(e, n, r[i], o) && utils$1.isArray(r[i]) && (r[i] = arrayToObject(r[i])),
        !a
    }
    if (utils$1.isFormData(e) && utils$1.isFunction(e.entries)) {
        const n = {};
        return utils$1.forEachEntry(e, ( (e, r) => {
            t(parsePropPath(e), r, n, 0)
        }
        )),
        n
    }
    return null
}
function stringifySafely(e, t, n) {
    if (utils$1.isString(e))
        try {
            return (t || JSON.parse)(e),
            utils$1.trim(e)
        } catch (e2) {
            if ("SyntaxError" !== e2.name)
                throw e2
        }
    return (0,
    JSON.stringify)(e)
}
const defaults$1 = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, t) {
        const n = t.getContentType() || ""
          , r = n.indexOf("application/json") > -1
          , o = utils$1.isObject(e);
        o && utils$1.isHTMLForm(e) && (e = new FormData(e));
        if (utils$1.isFormData(e))
            return r ? JSON.stringify(formDataToJSON(e)) : e;
        if (utils$1.isArrayBuffer(e) || utils$1.isBuffer(e) || utils$1.isStream(e) || utils$1.isFile(e) || utils$1.isBlob(e) || utils$1.isReadableStream(e))
            return e;
        if (utils$1.isArrayBufferView(e))
            return e.buffer;
        if (utils$1.isURLSearchParams(e))
            return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            e.toString();
        let i;
        if (o) {
            if (n.indexOf("application/x-www-form-urlencoded") > -1)
                return toURLEncodedForm(e, this.formSerializer).toString();
            if ((i = utils$1.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
                const t = this.env && this.env.FormData;
                return toFormData(i ? {
                    "files[]": e
                } : e, t && new t, this.formSerializer)
            }
        }
        return o || r ? (t.setContentType("application/json", !1),
        stringifySafely(e)) : e
    }
    ],
    transformResponse: [function(e) {
        const t = this.transitional || defaults$1.transitional
          , n = t && t.forcedJSONParsing
          , r = "json" === this.responseType;
        if (utils$1.isResponse(e) || utils$1.isReadableStream(e))
            return e;
        if (e && utils$1.isString(e) && (n && !this.responseType || r)) {
            const n = !(t && t.silentJSONParsing) && r;
            try {
                return JSON.parse(e)
            } catch (e2) {
                if (n) {
                    if ("SyntaxError" === e2.name)
                        throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                    throw e2
                }
            }
        }
        return e
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (e => {
    defaults$1.headers[e] = {}
}
));
const ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , parseHeaders = e => {
    const t = {};
    let n, r, o;
    return e && e.split("\n").forEach((function(e) {
        o = e.indexOf(":"),
        n = e.substring(0, o).trim().toLowerCase(),
        r = e.substring(o + 1).trim(),
        !n || t[n] && ignoreDuplicateOf[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r)
    }
    )),
    t
}
  , $internals = Symbol("internals");
function normalizeHeader(e) {
    return e && String(e).trim().toLowerCase()
}
function normalizeValue(e) {
    return !1 === e || null == e ? e : utils$1.isArray(e) ? e.map(normalizeValue) : String(e)
}
function parseTokens(e) {
    const t = Object.create(null)
      , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(e); )
        t[r[1]] = r[2];
    return t
}
const isValidHeaderName = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function matchHeaderValue(e, t, n, r, o) {
    return utils$1.isFunction(r) ? r.call(this, t, n) : (o && (t = n),
    utils$1.isString(t) ? utils$1.isString(r) ? -1 !== t.indexOf(r) : utils$1.isRegExp(r) ? r.test(t) : void 0 : void 0)
}
function formatHeader(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ( (e, t, n) => t.toUpperCase() + n))
}
function buildAccessors(e, t) {
    const n = utils$1.toCamelCase(" " + t);
    ["get", "set", "has"].forEach((r => {
        Object.defineProperty(e, r + n, {
            value: function(e, n, o) {
                return this[r].call(this, t, e, n, o)
            },
            configurable: !0
        })
    }
    ))
}
class AxiosHeaders {
    constructor(e) {
        e && this.set(e)
    }
    set(e, t, n) {
        const r = this;
        function o(e, t, n) {
            const o = normalizeHeader(t);
            if (!o)
                throw new Error("header name must be a non-empty string");
            const i = utils$1.findKey(r, o);
            (!i || void 0 === r[i] || !0 === n || void 0 === n && !1 !== r[i]) && (r[i || t] = normalizeValue(e))
        }
        const i = (e, t) => utils$1.forEach(e, ( (e, n) => o(e, n, t)));
        if (utils$1.isPlainObject(e) || e instanceof this.constructor)
            i(e, t);
        else if (utils$1.isString(e) && (e = e.trim()) && !isValidHeaderName(e))
            i(parseHeaders(e), t);
        else if (utils$1.isHeaders(e))
            for (const [a,s] of e.entries())
                o(s, a, n);
        else
            null != e && o(t, e, n);
        return this
    }
    get(e, t) {
        if (e = normalizeHeader(e)) {
            const n = utils$1.findKey(this, e);
            if (n) {
                const e = this[n];
                if (!t)
                    return e;
                if (!0 === t)
                    return parseTokens(e);
                if (utils$1.isFunction(t))
                    return t.call(this, e, n);
                if (utils$1.isRegExp(t))
                    return t.exec(e);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, t) {
        if (e = normalizeHeader(e)) {
            const n = utils$1.findKey(this, e);
            return !(!n || void 0 === this[n] || t && !matchHeaderValue(this, this[n], n, t))
        }
        return !1
    }
    delete(e, t) {
        const n = this;
        let r = !1;
        function o(e) {
            if (e = normalizeHeader(e)) {
                const o = utils$1.findKey(n, e);
                !o || t && !matchHeaderValue(n, n[o], o, t) || (delete n[o],
                r = !0)
            }
        }
        return utils$1.isArray(e) ? e.forEach(o) : o(e),
        r
    }
    clear(e) {
        const t = Object.keys(this);
        let n = t.length
          , r = !1;
        for (; n--; ) {
            const o = t[n];
            e && !matchHeaderValue(this, this[o], o, e, !0) || (delete this[o],
            r = !0)
        }
        return r
    }
    normalize(e) {
        const t = this
          , n = {};
        return utils$1.forEach(this, ( (r, o) => {
            const i = utils$1.findKey(n, o);
            if (i)
                return t[i] = normalizeValue(r),
                void delete t[o];
            const a = e ? formatHeader(o) : String(o).trim();
            a !== o && delete t[o],
            t[a] = normalizeValue(r),
            n[a] = !0
        }
        )),
        this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const t = Object.create(null);
        return utils$1.forEach(this, ( (n, r) => {
            null != n && !1 !== n && (t[r] = e && utils$1.isArray(n) ? n.join(", ") : n)
        }
        )),
        t
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(( ([e,t]) => e + ": " + t)).join("\n")
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...t) {
        const n = new this(e);
        return t.forEach((e => n.set(e))),
        n
    }
    static accessor(e) {
        const t = (this[$internals] = this[$internals] = {
            accessors: {}
        }).accessors
          , n = this.prototype;
        function r(e) {
            const r = normalizeHeader(e);
            t[r] || (buildAccessors(n, e),
            t[r] = !0)
        }
        return utils$1.isArray(e) ? e.forEach(r) : r(e),
        this
    }
}
function transformData(e, t) {
    const n = this || defaults$1
      , r = t || n
      , o = AxiosHeaders.from(r.headers);
    let i = r.data;
    return utils$1.forEach(e, (function(e) {
        i = e.call(n, i, o.normalize(), t ? t.status : void 0)
    }
    )),
    o.normalize(),
    i
}
function isCancel(e) {
    return !(!e || !e.__CANCEL__)
}
function CanceledError(e, t, n) {
    AxiosError.call(this, null == e ? "canceled" : e, AxiosError.ERR_CANCELED, t, n),
    this.name = "CanceledError"
}
function settle(e, t, n) {
    const r = n.config.validateStatus;
    n.status && r && !r(n.status) ? t(new AxiosError("Request failed with status code " + n.status,[AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : e(n)
}
function parseProtocol(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || ""
}
function speedometer(e, t) {
    e = e || 10;
    const n = new Array(e)
      , r = new Array(e);
    let o, i = 0, a = 0;
    return t = void 0 !== t ? t : 1e3,
    function(s) {
        const c = Date.now()
          , l = r[a];
        o || (o = c),
        n[i] = s,
        r[i] = c;
        let u = a
          , p = 0;
        for (; u !== i; )
            p += n[u++],
            u %= e;
        if (i = (i + 1) % e,
        i === a && (a = (a + 1) % e),
        c - o < t)
            return;
        const d = l && c - l;
        return d ? Math.round(1e3 * p / d) : void 0
    }
}
function throttle(e, t) {
    let n, r, o = 0, i = 1e3 / t;
    const a = (t, i=Date.now()) => {
        o = i,
        n = null,
        r && (clearTimeout(r),
        r = null),
        e.apply(null, t)
    }
    ;
    return [ (...e) => {
        const t = Date.now()
          , s = t - o;
        s >= i ? a(e, t) : (n = e,
        r || (r = setTimeout(( () => {
            r = null,
            a(n)
        }
        ), i - s)))
    }
    , () => n && a(n)]
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
utils$1.reduceDescriptors(AxiosHeaders.prototype, ( ({value: e}, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
        get: () => e,
        set(e) {
            this[n] = e
        }
    }
}
)),
utils$1.freezeMethods(AxiosHeaders),
utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: !0
});
const progressEventReducer = (e, t, n=3) => {
    let r = 0;
    const o = speedometer(50, 250);
    return throttle((n => {
        const i = n.loaded
          , a = n.lengthComputable ? n.total : void 0
          , s = i - r
          , c = o(s);
        r = i;
        e({
            loaded: i,
            total: a,
            progress: a ? i / a : void 0,
            bytes: s,
            rate: c || void 0,
            estimated: c && a && i <= a ? (a - i) / c : void 0,
            event: n,
            lengthComputable: null != a,
            [t ? "download" : "upload"]: !0
        })
    }
    ), n)
}
  , progressEventDecorator = (e, t) => {
    const n = null != e;
    return [r => t[0]({
        lengthComputable: n,
        total: e,
        loaded: r
    }), t[1]]
}
  , asyncDecorator = e => (...t) => utils$1.asap(( () => e(...t)))
  , isURLSameOrigin = platform.hasStandardBrowserEnv ? function() {
    const e = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
      , t = document.createElement("a");
    let n;
    function r(n) {
        let r = n;
        return e && (t.setAttribute("href", r),
        r = t.href),
        t.setAttribute("href", r),
        {
            href: t.href,
            protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
            host: t.host,
            search: t.search ? t.search.replace(/^\?/, "") : "",
            hash: t.hash ? t.hash.replace(/^#/, "") : "",
            hostname: t.hostname,
            port: t.port,
            pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname
        }
    }
    return n = r(window.location.href),
    function(e) {
        const t = utils$1.isString(e) ? r(e) : e;
        return t.protocol === n.protocol && t.host === n.host
    }
}() : function() {
    return function() {
        return !0
    }
}()
  , cookies = platform.hasStandardBrowserEnv ? {
    write(e, t, n, r, o, i) {
        const a = [e + "=" + encodeURIComponent(t)];
        utils$1.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()),
        utils$1.isString(r) && a.push("path=" + r),
        utils$1.isString(o) && a.push("domain=" + o),
        !0 === i && a.push("secure"),
        document.cookie = a.join("; ")
    },
    read(e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null
    },
    remove(e) {
        this.write(e, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read: () => null,
    remove() {}
};
function isAbsoluteURL(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function combineURLs(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
}
function buildFullPath(e, t) {
    return e && !isAbsoluteURL(t) ? combineURLs(e, t) : t
}
const headersToObject = e => e instanceof AxiosHeaders ? {
    ...e
} : e;
function mergeConfig(e, t) {
    t = t || {};
    const n = {};
    function r(e, t, n) {
        return utils$1.isPlainObject(e) && utils$1.isPlainObject(t) ? utils$1.merge.call({
            caseless: n
        }, e, t) : utils$1.isPlainObject(t) ? utils$1.merge({}, t) : utils$1.isArray(t) ? t.slice() : t
    }
    function o(e, t, n) {
        return utils$1.isUndefined(t) ? utils$1.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n)
    }
    function i(e, t) {
        if (!utils$1.isUndefined(t))
            return r(void 0, t)
    }
    function a(e, t) {
        return utils$1.isUndefined(t) ? utils$1.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t)
    }
    function s(n, o, i) {
        return i in t ? r(n, o) : i in e ? r(void 0, n) : void 0
    }
    const c = {
        url: i,
        method: i,
        data: i,
        baseURL: a,
        transformRequest: a,
        transformResponse: a,
        paramsSerializer: a,
        timeout: a,
        timeoutMessage: a,
        withCredentials: a,
        withXSRFToken: a,
        adapter: a,
        responseType: a,
        xsrfCookieName: a,
        xsrfHeaderName: a,
        onUploadProgress: a,
        onDownloadProgress: a,
        decompress: a,
        maxContentLength: a,
        maxBodyLength: a,
        beforeRedirect: a,
        transport: a,
        httpAgent: a,
        httpsAgent: a,
        cancelToken: a,
        socketPath: a,
        responseEncoding: a,
        validateStatus: s,
        headers: (e, t) => o(headersToObject(e), headersToObject(t), !0)
    };
    return utils$1.forEach(Object.keys(Object.assign({}, e, t)), (function(r) {
        const i = c[r] || o
          , a = i(e[r], t[r], r);
        utils$1.isUndefined(a) && i !== s || (n[r] = a)
    }
    )),
    n
}
const resolveConfig = e => {
    const t = mergeConfig({}, e);
    let n, {data: r, withXSRFToken: o, xsrfHeaderName: i, xsrfCookieName: a, headers: s, auth: c} = t;
    if (t.headers = s = AxiosHeaders.from(s),
    t.url = buildURL(buildFullPath(t.baseURL, t.url), e.params, e.paramsSerializer),
    c && s.set("Authorization", "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))),
    utils$1.isFormData(r))
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
            s.setContentType(void 0);
        else if (!1 !== (n = s.getContentType())) {
            const [e,...t] = n ? n.split(";").map((e => e.trim())).filter(Boolean) : [];
            s.setContentType([e || "multipart/form-data", ...t].join("; "))
        }
    if (platform.hasStandardBrowserEnv && (o && utils$1.isFunction(o) && (o = o(t)),
    o || !1 !== o && isURLSameOrigin(t.url))) {
        const e = i && a && cookies.read(a);
        e && s.set(i, e)
    }
    return t
}
  , isXHRAdapterSupported = "undefined" != typeof XMLHttpRequest
  , xhrAdapter = isXHRAdapterSupported && function(e) {
    return new Promise((function(t, n) {
        const r = resolveConfig(e);
        let o = r.data;
        const i = AxiosHeaders.from(r.headers).normalize();
        let a, s, c, l, u, {responseType: p, onUploadProgress: d, onDownloadProgress: f} = r;
        function h() {
            l && l(),
            u && u(),
            r.cancelToken && r.cancelToken.unsubscribe(a),
            r.signal && r.signal.removeEventListener("abort", a)
        }
        let m = new XMLHttpRequest;
        function g() {
            if (!m)
                return;
            const r = AxiosHeaders.from("getAllResponseHeaders"in m && m.getAllResponseHeaders());
            settle((function(e) {
                t(e),
                h()
            }
            ), (function(e) {
                n(e),
                h()
            }
            ), {
                data: p && "text" !== p && "json" !== p ? m.response : m.responseText,
                status: m.status,
                statusText: m.statusText,
                headers: r,
                config: e,
                request: m
            }),
            m = null
        }
        m.open(r.method.toUpperCase(), r.url, !0),
        m.timeout = r.timeout,
        "onloadend"in m ? m.onloadend = g : m.onreadystatechange = function() {
            m && 4 === m.readyState && (0 !== m.status || m.responseURL && 0 === m.responseURL.indexOf("file:")) && setTimeout(g)
        }
        ,
        m.onabort = function() {
            m && (n(new AxiosError("Request aborted",AxiosError.ECONNABORTED,e,m)),
            m = null)
        }
        ,
        m.onerror = function() {
            n(new AxiosError("Network Error",AxiosError.ERR_NETWORK,e,m)),
            m = null
        }
        ,
        m.ontimeout = function() {
            let t = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
            const o = r.transitional || transitionalDefaults;
            r.timeoutErrorMessage && (t = r.timeoutErrorMessage),
            n(new AxiosError(t,o.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,e,m)),
            m = null
        }
        ,
        void 0 === o && i.setContentType(null),
        "setRequestHeader"in m && utils$1.forEach(i.toJSON(), (function(e, t) {
            m.setRequestHeader(t, e)
        }
        )),
        utils$1.isUndefined(r.withCredentials) || (m.withCredentials = !!r.withCredentials),
        p && "json" !== p && (m.responseType = r.responseType),
        f && ([c,u] = progressEventReducer(f, !0),
        m.addEventListener("progress", c)),
        d && m.upload && ([s,l] = progressEventReducer(d),
        m.upload.addEventListener("progress", s),
        m.upload.addEventListener("loadend", l)),
        (r.cancelToken || r.signal) && (a = t => {
            m && (n(!t || t.type ? new CanceledError(null,e,m) : t),
            m.abort(),
            m = null)
        }
        ,
        r.cancelToken && r.cancelToken.subscribe(a),
        r.signal && (r.signal.aborted ? a() : r.signal.addEventListener("abort", a)));
        const v = parseProtocol(r.url);
        v && -1 === platform.protocols.indexOf(v) ? n(new AxiosError("Unsupported protocol " + v + ":",AxiosError.ERR_BAD_REQUEST,e)) : m.send(o || null)
    }
    ))
}
  , composeSignals = (e, t) => {
    const {length: n} = e = e ? e.filter(Boolean) : [];
    if (t || n) {
        let n, r = new AbortController;
        const o = function(e) {
            if (!n) {
                n = !0,
                a();
                const t = e instanceof Error ? e : this.reason;
                r.abort(t instanceof AxiosError ? t : new CanceledError(t instanceof Error ? t.message : t))
            }
        };
        let i = t && setTimeout(( () => {
            i = null,
            o(new AxiosError("timeout ".concat(t, " of ms exceeded"),AxiosError.ETIMEDOUT))
        }
        ), t);
        const a = () => {
            e && (i && clearTimeout(i),
            i = null,
            e.forEach((e => {
                e.unsubscribe ? e.unsubscribe(o) : e.removeEventListener("abort", o)
            }
            )),
            e = null)
        }
        ;
        e.forEach((e => e.addEventListener("abort", o)));
        const {signal: s} = r;
        return s.unsubscribe = () => utils$1.asap(a),
        s
    }
}
  , streamChunk = function*(e, t) {
    let n = e.byteLength;
    if (n < t)
        return void (yield e);
    let r, o = 0;
    for (; o < n; )
        r = o + t,
        yield e.slice(o, r),
        o = r
}
  , readBytes = async function*(e, t) {
    for await(const n of readStream(e))
        yield*streamChunk(n, t)
}
  , readStream = async function*(e) {
    if (e[Symbol.asyncIterator])
        return void (yield*e);
    const t = e.getReader();
    try {
        for (; ; ) {
            const {done: e, value: n} = await t.read();
            if (e)
                break;
            yield n
        }
    } finally {
        await t.cancel()
    }
}
  , trackStream = (e, t, n, r) => {
    const o = readBytes(e, t);
    let i, a = 0, s = e => {
        i || (i = !0,
        r && r(e))
    }
    ;
    return new ReadableStream({
        async pull(e) {
            try {
                const {done: t, value: r} = await o.next();
                if (t)
                    return s(),
                    void e.close();
                let i = r.byteLength;
                if (n) {
                    let e = a += i;
                    n(e)
                }
                e.enqueue(new Uint8Array(r))
            } catch (t) {
                throw s(t),
                t
            }
        },
        cancel: e => (s(e),
        o.return())
    },{
        highWaterMark: 2
    })
}
  , isFetchSupported = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response
  , isReadableStreamSupported = isFetchSupported && "function" == typeof ReadableStream
  , encodeText = isFetchSupported && ("function" == typeof TextEncoder ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer()))
  , test = (e, ...t) => {
    try {
        return !!e(...t)
    } catch (e2) {
        return !1
    }
}
  , supportsRequestStream = isReadableStreamSupported && test(( () => {
    let e = !1;
    const t = new Request(platform.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return e = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return e && !t
}
))
  , DEFAULT_CHUNK_SIZE = 65536
  , supportsResponseStream = isReadableStreamSupported && test(( () => utils$1.isReadableStream(new Response("").body)))
  , resolvers = {
    stream: supportsResponseStream && (e => e.body)
};
var res;
isFetchSupported && (res = new Response,
["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e => {
    !resolvers[e] && (resolvers[e] = utils$1.isFunction(res[e]) ? t => t[e]() : (t, n) => {
        throw new AxiosError("Response type '".concat(e, "' is not supported"),AxiosError.ERR_NOT_SUPPORT,n)
    }
    )
}
)));
const getBodyLength = async e => {
    if (null == e)
        return 0;
    if (utils$1.isBlob(e))
        return e.size;
    if (utils$1.isSpecCompliantForm(e)) {
        const t = new Request(platform.origin,{
            method: "POST",
            body: e
        });
        return (await t.arrayBuffer()).byteLength
    }
    return utils$1.isArrayBufferView(e) || utils$1.isArrayBuffer(e) ? e.byteLength : (utils$1.isURLSearchParams(e) && (e += ""),
    utils$1.isString(e) ? (await encodeText(e)).byteLength : void 0)
}
  , resolveBodyLength = async (e, t) => {
    const n = utils$1.toFiniteNumber(e.getContentLength());
    return null == n ? getBodyLength(t) : n
}
  , fetchAdapter = isFetchSupported && (async e => {
    let {url: t, method: n, data: r, signal: o, cancelToken: i, timeout: a, onDownloadProgress: s, onUploadProgress: c, responseType: l, headers: u, withCredentials: p="same-origin", fetchOptions: d} = resolveConfig(e);
    l = l ? (l + "").toLowerCase() : "text";
    let f, h = composeSignals([o, i && i.toAbortSignal()], a);
    const m = h && h.unsubscribe && ( () => {
        h.unsubscribe()
    }
    );
    let g;
    try {
        if (c && supportsRequestStream && "get" !== n && "head" !== n && 0 !== (g = await resolveBodyLength(u, r))) {
            let e, n = new Request(t,{
                method: "POST",
                body: r,
                duplex: "half"
            });
            if (utils$1.isFormData(r) && (e = n.headers.get("content-type")) && u.setContentType(e),
            n.body) {
                const [e,t] = progressEventDecorator(g, progressEventReducer(asyncDecorator(c)));
                r = trackStream(n.body, DEFAULT_CHUNK_SIZE, e, t)
            }
        }
        utils$1.isString(p) || (p = p ? "include" : "omit");
        const o = "credentials"in Request.prototype;
        f = new Request(t,{
            ...d,
            signal: h,
            method: n.toUpperCase(),
            headers: u.normalize().toJSON(),
            body: r,
            duplex: "half",
            credentials: o ? p : void 0
        });
        let i = await fetch(f);
        const a = supportsResponseStream && ("stream" === l || "response" === l);
        if (supportsResponseStream && (s || a && m)) {
            const e = {};
            ["status", "statusText", "headers"].forEach((t => {
                e[t] = i[t]
            }
            ));
            const t = utils$1.toFiniteNumber(i.headers.get("content-length"))
              , [n,r] = s && progressEventDecorator(t, progressEventReducer(asyncDecorator(s), !0)) || [];
            i = new Response(trackStream(i.body, DEFAULT_CHUNK_SIZE, n, ( () => {
                r && r(),
                m && m()
            }
            )),e)
        }
        l = l || "text";
        let v = await resolvers[utils$1.findKey(resolvers, l) || "text"](i, e);
        return !a && m && m(),
        await new Promise(( (t, n) => {
            settle(t, n, {
                data: v,
                headers: AxiosHeaders.from(i.headers),
                status: i.status,
                statusText: i.statusText,
                config: e,
                request: f
            })
        }
        ))
    } catch (v) {
        if (m && m(),
        v && "TypeError" === v.name && /fetch/i.test(v.message))
            throw Object.assign(new AxiosError("Network Error",AxiosError.ERR_NETWORK,e,f), {
                cause: v.cause || v
            });
        throw AxiosError.from(v, v && v.code, e, f)
    }
}
)
  , knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, ( (e, t) => {
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            })
        } catch (e2) {}
        Object.defineProperty(e, "adapterName", {
            value: t
        })
    }
}
));
const renderReason = e => "- ".concat(e)
  , isResolvedHandle = e => utils$1.isFunction(e) || null === e || !1 === e
  , adapters = {
    getAdapter: e => {
        e = utils$1.isArray(e) ? e : [e];
        const {length: t} = e;
        let n, r;
        const o = {};
        for (let i = 0; i < t; i++) {
            let t;
            if (n = e[i],
            r = n,
            !isResolvedHandle(n) && (r = knownAdapters[(t = String(n)).toLowerCase()],
            void 0 === r))
                throw new AxiosError("Unknown adapter '".concat(t, "'"));
            if (r)
                break;
            o[t || "#" + i] = r
        }
        if (!r) {
            const e = Object.entries(o).map(( ([e,t]) => "adapter ".concat(e, " ") + (!1 === t ? "is not supported by the environment" : "is not available in the build")));
            throw new AxiosError("There is no suitable adapter to dispatch the request " + (t ? e.length > 1 ? "since :\n" + e.map(renderReason).join("\n") : " " + renderReason(e[0]) : "as no adapter specified"),"ERR_NOT_SUPPORT")
        }
        return r
    }
    ,
    adapters: knownAdapters
};
function throwIfCancellationRequested(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
        throw new CanceledError(null,e)
}
function dispatchRequest(e) {
    throwIfCancellationRequested(e),
    e.headers = AxiosHeaders.from(e.headers),
    e.data = transformData.call(e, e.transformRequest),
    -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
    return adapters.getAdapter(e.adapter || defaults$1.adapter)(e).then((function(t) {
        return throwIfCancellationRequested(e),
        t.data = transformData.call(e, e.transformResponse, t),
        t.headers = AxiosHeaders.from(t.headers),
        t
    }
    ), (function(t) {
        return isCancel(t) || (throwIfCancellationRequested(e),
        t && t.response && (t.response.data = transformData.call(e, e.transformResponse, t.response),
        t.response.headers = AxiosHeaders.from(t.response.headers))),
        Promise.reject(t)
    }
    ))
}
const VERSION$1 = "1.7.7"
  , validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(( (e, t) => {
    validators$1[e] = function(n) {
        return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
    }
}
));
const deprecatedWarnings = {};
function assertOptions(e, t, n) {
    if ("object" != typeof e)
        throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(e);
    let o = r.length;
    for (; o-- > 0; ) {
        const i = r[o]
          , a = t[i];
        if (a) {
            const t = e[i]
              , n = void 0 === t || a(t, i, e);
            if (!0 !== n)
                throw new AxiosError("option " + i + " must be " + n,AxiosError.ERR_BAD_OPTION_VALUE)
        } else if (!0 !== n)
            throw new AxiosError("Unknown option " + i,AxiosError.ERR_BAD_OPTION)
    }
}
validators$1.transitional = function(e, t, n) {
    function r(e, t) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
    }
    return (n, o, i) => {
        if (!1 === e)
            throw new AxiosError(r(o, " has been removed" + (t ? " in " + t : "")),AxiosError.ERR_DEPRECATED);
        return t && !deprecatedWarnings[o] && (deprecatedWarnings[o] = !0,
        console.warn(r(o, " has been deprecated since v" + t + " and will be removed in the near future"))),
        !e || e(n, o, i)
    }
}
;
const validator = {
    assertOptions: assertOptions,
    validators: validators$1
}
  , validators = validator.validators;
class Axios {
    constructor(e) {
        this.defaults = e,
        this.interceptors = {
            request: new InterceptorManager,
            response: new InterceptorManager
        }
    }
    async request(e, t) {
        try {
            return await this._request(e, t)
        } catch (n) {
            if (n instanceof Error) {
                let e;
                Error.captureStackTrace ? Error.captureStackTrace(e = {}) : e = new Error;
                const t = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                try {
                    n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t
                } catch (e2) {}
            }
            throw n
        }
    }
    _request(e, t) {
        "string" == typeof e ? (t = t || {}).url = e : t = e || {},
        t = mergeConfig(this.defaults, t);
        const {transitional: n, paramsSerializer: r, headers: o} = t;
        void 0 !== n && validator.assertOptions(n, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, !1),
        null != r && (utils$1.isFunction(r) ? t.paramsSerializer = {
            serialize: r
        } : validator.assertOptions(r, {
            encode: validators.function,
            serialize: validators.function
        }, !0)),
        t.method = (t.method || this.defaults.method || "get").toLowerCase();
        let i = o && utils$1.merge(o.common, o[t.method]);
        o && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => {
            delete o[e]
        }
        )),
        t.headers = AxiosHeaders.concat(i, o);
        const a = [];
        let s = !0;
        this.interceptors.request.forEach((function(e) {
            "function" == typeof e.runWhen && !1 === e.runWhen(t) || (s = s && e.synchronous,
            a.unshift(e.fulfilled, e.rejected))
        }
        ));
        const c = [];
        let l;
        this.interceptors.response.forEach((function(e) {
            c.push(e.fulfilled, e.rejected)
        }
        ));
        let u, p = 0;
        if (!s) {
            const e = [dispatchRequest.bind(this), void 0];
            for (e.unshift.apply(e, a),
            e.push.apply(e, c),
            u = e.length,
            l = Promise.resolve(t); p < u; )
                l = l.then(e[p++], e[p++]);
            return l
        }
        u = a.length;
        let d = t;
        for (p = 0; p < u; ) {
            const e = a[p++]
              , t = a[p++];
            try {
                d = e(d)
            } catch (f) {
                t.call(this, f);
                break
            }
        }
        try {
            l = dispatchRequest.call(this, d)
        } catch (f) {
            return Promise.reject(f)
        }
        for (p = 0,
        u = c.length; p < u; )
            l = l.then(c[p++], c[p++]);
        return l
    }
    getUri(e) {
        return buildURL(buildFullPath((e = mergeConfig(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
    }
}
utils$1.forEach(["delete", "get", "head", "options"], (function(e) {
    Axios.prototype[e] = function(t, n) {
        return this.request(mergeConfig(n || {}, {
            method: e,
            url: t,
            data: (n || {}).data
        }))
    }
}
)),
utils$1.forEach(["post", "put", "patch"], (function(e) {
    function t(t) {
        return function(n, r, o) {
            return this.request(mergeConfig(o || {}, {
                method: e,
                headers: t ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: n,
                data: r
            }))
        }
    }
    Axios.prototype[e] = t(),
    Axios.prototype[e + "Form"] = t(!0)
}
));
class CancelToken {
    constructor(e) {
        if ("function" != typeof e)
            throw new TypeError("executor must be a function.");
        let t;
        this.promise = new Promise((function(e) {
            t = e
        }
        ));
        const n = this;
        this.promise.then((e => {
            if (!n._listeners)
                return;
            let t = n._listeners.length;
            for (; t-- > 0; )
                n._listeners[t](e);
            n._listeners = null
        }
        )),
        this.promise.then = e => {
            let t;
            const r = new Promise((e => {
                n.subscribe(e),
                t = e
            }
            )).then(e);
            return r.cancel = function() {
                n.unsubscribe(t)
            }
            ,
            r
        }
        ,
        e((function(e, r, o) {
            n.reason || (n.reason = new CanceledError(e,r,o),
            t(n.reason))
        }
        ))
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(e) {
        this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners)
            return;
        const t = this._listeners.indexOf(e);
        -1 !== t && this._listeners.splice(t, 1)
    }
    toAbortSignal() {
        const e = new AbortController
          , t = t => {
            e.abort(t)
        }
        ;
        return this.subscribe(t),
        e.signal.unsubscribe = () => this.unsubscribe(t),
        e.signal
    }
    static source() {
        let e;
        return {
            token: new CancelToken((function(t) {
                e = t
            }
            )),
            cancel: e
        }
    }
}
function spread(e) {
    return function(t) {
        return e.apply(null, t)
    }
}
function isAxiosError(e) {
    return utils$1.isObject(e) && !0 === e.isAxiosError
}
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
function createInstance(e) {
    const t = new Axios(e)
      , n = bind$1(Axios.prototype.request, t);
    return utils$1.extend(n, Axios.prototype, t, {
        allOwnKeys: !0
    }),
    utils$1.extend(n, t, null, {
        allOwnKeys: !0
    }),
    n.create = function(t) {
        return createInstance(mergeConfig(e, t))
    }
    ,
    n
}
Object.entries(HttpStatusCode).forEach(( ([e,t]) => {
    HttpStatusCode[t] = e
}
));
const axios = createInstance(defaults$1);
axios.Axios = Axios,
axios.CanceledError = CanceledError,
axios.CancelToken = CancelToken,
axios.isCancel = isCancel,
axios.VERSION = VERSION$1,
axios.toFormData = toFormData,
axios.AxiosError = AxiosError,
axios.Cancel = axios.CanceledError,
axios.all = function(e) {
    return Promise.all(e)
}
,
axios.spread = spread,
axios.isAxiosError = isAxiosError,
axios.mergeConfig = mergeConfig,
axios.AxiosHeaders = AxiosHeaders,
axios.formToJSON = e => formDataToJSON(utils$1.isHTMLForm(e) ? new FormData(e) : e),
axios.getAdapter = adapters.getAdapter,
axios.HttpStatusCode = HttpStatusCode,
axios.default = axios;
const requestInterceptors = []
  , responseInterceptors = []
  , defaultConfig = {
    timeout: 1e4,
    headers: {
        Accept: "application/json"
    },
    withCredentials: !0
};
let request;
function addResponseInterceptors({onResponseFulfilled: e=function(e) {
    return e
}
, onResponseRejected: t=function(e) {
    return Promise.reject(e)
}
}) {
    request.interceptors.response.use(e, t),
    responseInterceptors.push([e, t])
}
const isNodeJS = "undefined" != typeof process && process.versions && process.versions.node;
let defaultAdapter = axios.getAdapter((null == (_e2 = null == (_d = null) ? void 0 : _d.env) ? void 0 : _e2.SSR) || isNodeJS ? "http" : "xhr");
const adapterChain = [];
function adapter(e) {
    const t = [defaultAdapter].concat(adapterChain.slice(0));
    let n = t.length - 1;
    return async function e(r) {
        if (n >= 0) {
            return (0,
            t[n--])(r, e)
        }
        return {
            data: "",
            status: -1,
            statusText: "",
            headers: {},
            config: r
        }
    }(e)
}
function addAdapter(e) {
    adapterChain.includes(e) || adapterChain.push(e)
}
function init$1(e) {
    const t = {
        ...defaultConfig,
        ...e
    };
    return "string" == typeof t.adapter && (t.adapter = axios.getAdapter(t.adapter)),
    "function" == typeof t.adapter && (defaultAdapter = t.adapter),
    t.adapter = adapter,
    request = axios.create(t),
    requestInterceptors.forEach((e => {
        request.interceptors.request.use(...e)
    }
    )),
    responseInterceptors.forEach((e => {
        request.interceptors.response.use(...e)
    }
    )),
    request
}
init$1({});
var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function getDefaultExportFromCjs(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var balancedMatch = balanced$1;
function balanced$1(e, t, n) {
    e instanceof RegExp && (e = maybeMatch(e, n)),
    t instanceof RegExp && (t = maybeMatch(t, n));
    var r = range(e, t, n);
    return r && {
        start: r[0],
        end: r[1],
        pre: n.slice(0, r[0]),
        body: n.slice(r[0] + e.length, r[1]),
        post: n.slice(r[1] + t.length)
    }
}
function maybeMatch(e, t) {
    var n = t.match(e);
    return n ? n[0] : null
}
function range(e, t, n) {
    var r, o, i, a, s, c = n.indexOf(e), l = n.indexOf(t, c + 1), u = c;
    if (c >= 0 && l > 0) {
        if (e === t)
            return [c, l];
        for (r = [],
        i = n.length; u >= 0 && !s; )
            u == c ? (r.push(u),
            c = n.indexOf(e, u + 1)) : 1 == r.length ? s = [r.pop(), l] : ((o = r.pop()) < i && (i = o,
            a = l),
            l = n.indexOf(t, u + 1)),
            u = c < l && c >= 0 ? c : l;
        r.length && (s = [i, a])
    }
    return s
}
balanced$1.range = range;
var balanced = balancedMatch
  , braceExpansion = expandTop
  , escSlash = "\0SLASH" + Math.random() + "\0"
  , escOpen = "\0OPEN" + Math.random() + "\0"
  , escClose = "\0CLOSE" + Math.random() + "\0"
  , escComma = "\0COMMA" + Math.random() + "\0"
  , escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(e) {
    return parseInt(e, 10) == e ? parseInt(e, 10) : e.charCodeAt(0)
}
function escapeBraces(e) {
    return e.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod)
}
function unescapeBraces(e) {
    return e.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".")
}
function parseCommaParts(e) {
    if (!e)
        return [""];
    var t = []
      , n = balanced("{", "}", e);
    if (!n)
        return e.split(",");
    var r = n.pre
      , o = n.body
      , i = n.post
      , a = r.split(",");
    a[a.length - 1] += "{" + o + "}";
    var s = parseCommaParts(i);
    return i.length && (a[a.length - 1] += s.shift(),
    a.push.apply(a, s)),
    t.push.apply(t, a),
    t
}
function expandTop(e) {
    return e ? ("{}" === e.substr(0, 2) && (e = "\\{\\}" + e.substr(2)),
    expand(escapeBraces(e), !0).map(unescapeBraces)) : []
}
function embrace(e) {
    return "{" + e + "}"
}
function isPadded(e) {
    return /^-?0\d/.test(e)
}
function lte(e, t) {
    return e <= t
}
function gte(e, t) {
    return e >= t
}
function expand(e, t) {
    var n = []
      , r = balanced("{", "}", e);
    if (!r)
        return [e];
    var o = r.pre
      , i = r.post.length ? expand(r.post, !1) : [""];
    if (/\$$/.test(r.pre))
        for (var a = 0; a < i.length; a++) {
            var s = o + "{" + r.body + "}" + i[a];
            n.push(s)
        }
    else {
        var c, l, u = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(r.body), p = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(r.body), d = u || p, f = r.body.indexOf(",") >= 0;
        if (!d && !f)
            return r.post.match(/,.*\}/) ? expand(e = r.pre + "{" + r.body + escClose + r.post) : [e];
        if (d)
            c = r.body.split(/\.\./);
        else if (1 === (c = parseCommaParts(r.body)).length && 1 === (c = expand(c[0], !1).map(embrace)).length)
            return i.map((function(e) {
                return r.pre + c[0] + e
            }
            ));
        if (d) {
            var h = numeric(c[0])
              , m = numeric(c[1])
              , g = Math.max(c[0].length, c[1].length)
              , v = 3 == c.length ? Math.abs(numeric(c[2])) : 1
              , y = lte;
            m < h && (v *= -1,
            y = gte);
            var _ = c.some(isPadded);
            l = [];
            for (var b = h; y(b, m); b += v) {
                var E;
                if (p)
                    "\\" === (E = String.fromCharCode(b)) && (E = "");
                else if (E = String(b),
                _) {
                    var w = g - E.length;
                    if (w > 0) {
                        var S = new Array(w + 1).join("0");
                        E = b < 0 ? "-" + S + E.slice(1) : S + E
                    }
                }
                l.push(E)
            }
        } else {
            l = [];
            for (var O = 0; O < c.length; O++)
                l.push.apply(l, expand(c[O], !1))
        }
        for (O = 0; O < l.length; O++)
            for (a = 0; a < i.length; a++) {
                s = o + l[O] + i[a];
                (!t || d || s) && n.push(s)
            }
    }
    return n
}
const expand$1 = getDefaultExportFromCjs(braceExpansion)
  , MAX_PATTERN_LENGTH = 65536
  , assertValidPattern = e => {
    if ("string" != typeof e)
        throw new TypeError("invalid pattern");
    if (e.length > MAX_PATTERN_LENGTH)
        throw new TypeError("pattern is too long")
}
  , posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
    "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
    "[:ascii:]": ["\\x00-\\x7f", !1],
    "[:blank:]": ["\\p{Zs}\\t", !0],
    "[:cntrl:]": ["\\p{Cc}", !0],
    "[:digit:]": ["\\p{Nd}", !0],
    "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
    "[:lower:]": ["\\p{Ll}", !0],
    "[:print:]": ["\\p{C}", !0],
    "[:punct:]": ["\\p{P}", !0],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
    "[:upper:]": ["\\p{Lu}", !0],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
    "[:xdigit:]": ["A-Fa-f0-9", !1]
}
  , braceEscape = e => e.replace(/[[\]\\-]/g, "\\$&")
  , regexpEscape = e => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
  , rangesToString = e => e.join("")
  , parseClass = (e, t) => {
    const n = t;
    if ("[" !== e.charAt(n))
        throw new Error("not in a brace expression");
    const r = []
      , o = [];
    let i = n + 1
      , a = !1
      , s = !1
      , c = !1
      , l = !1
      , u = n
      , p = "";
    e: for (; i < e.length; ) {
        const t = e.charAt(i);
        if ("!" !== t && "^" !== t || i !== n + 1) {
            if ("]" === t && a && !c) {
                u = i + 1;
                break
            }
            if (a = !0,
            "\\" !== t || c) {
                if ("[" === t && !c)
                    for (const [t,[a,c,l]] of Object.entries(posixClasses))
                        if (e.startsWith(t, i)) {
                            if (p)
                                return ["$.", !1, e.length - n, !0];
                            i += t.length,
                            l ? o.push(a) : r.push(a),
                            s = s || c;
                            continue e
                        }
                c = !1,
                p ? (t > p ? r.push(braceEscape(p) + "-" + braceEscape(t)) : t === p && r.push(braceEscape(t)),
                p = "",
                i++) : e.startsWith("-]", i + 1) ? (r.push(braceEscape(t + "-")),
                i += 2) : e.startsWith("-", i + 1) ? (p = t,
                i += 2) : (r.push(braceEscape(t)),
                i++)
            } else
                c = !0,
                i++
        } else
            l = !0,
            i++
    }
    if (u < i)
        return ["", !1, 0, !1];
    if (!r.length && !o.length)
        return ["$.", !1, e.length - n, !0];
    if (0 === o.length && 1 === r.length && /^\\?.$/.test(r[0]) && !l) {
        const e = 2 === r[0].length ? r[0].slice(-1) : r[0];
        return [regexpEscape(e), !1, u - n, !1]
    }
    const d = "[" + (l ? "^" : "") + rangesToString(r) + "]"
      , f = "[" + (l ? "" : "^") + rangesToString(o) + "]";
    return [r.length && o.length ? "(" + d + "|" + f + ")" : r.length ? d : f, s, u - n, !0]
}
  , unescape$1 = (e, {windowsPathsNoEscape: t=!1}={}) => t ? e.replace(/\[([^\/\\])\]/g, "$1") : e.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1")
  , types = new Set(["!", "?", "+", "*", "@"])
  , isExtglobType = e => types.has(e)
  , startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))"
  , startNoDot = "(?!\\.)"
  , addPatternStart = new Set(["[", "."])
  , justDots = new Set(["..", "."])
  , reSpecials = new Set("().*{}+?[]^$\\!")
  , regExpEscape$1 = e => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
  , qmark$1 = "[^/]"
  , star$1 = qmark$1 + "*?"
  , starNoEmpty = qmark$1 + "+?"
  , _AST = class e {
    constructor(e, t, n={}) {
        __privateAdd(this, _AST_instances),
        __publicField(this, "type"),
        __privateAdd(this, _root),
        __privateAdd(this, _hasMagic),
        __privateAdd(this, _uflag, !1),
        __privateAdd(this, _parts, []),
        __privateAdd(this, _parent),
        __privateAdd(this, _parentIndex),
        __privateAdd(this, _negs),
        __privateAdd(this, _filledNegs, !1),
        __privateAdd(this, _options),
        __privateAdd(this, _toString),
        __privateAdd(this, _emptyExt, !1),
        this.type = e,
        e && __privateSet(this, _hasMagic, !0),
        __privateSet(this, _parent, t),
        __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this),
        __privateSet(this, _options, __privateGet(this, _root) === this ? n : __privateGet(__privateGet(this, _root), _options)),
        __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs)),
        "!" !== e || __privateGet(__privateGet(this, _root), _filledNegs) || __privateGet(this, _negs).push(this),
        __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0)
    }
    get hasMagic() {
        if (void 0 !== __privateGet(this, _hasMagic))
            return __privateGet(this, _hasMagic);
        for (const e of __privateGet(this, _parts))
            if ("string" != typeof e && (e.type || e.hasMagic))
                return __privateSet(this, _hasMagic, !0);
        return __privateGet(this, _hasMagic)
    }
    toString() {
        return void 0 !== __privateGet(this, _toString) ? __privateGet(this, _toString) : this.type ? __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((e => String(e))).join("|") + ")") : __privateSet(this, _toString, __privateGet(this, _parts).map((e => String(e))).join(""))
    }
    push(...t) {
        for (const n of t)
            if ("" !== n) {
                if ("string" != typeof n && !(n instanceof e && __privateGet(n, _parent) === this))
                    throw new Error("invalid part: " + n);
                __privateGet(this, _parts).push(n)
            }
    }
    toJSON() {
        var e;
        const t = null === this.type ? __privateGet(this, _parts).slice().map((e => "string" == typeof e ? e : e.toJSON())) : [this.type, ...__privateGet(this, _parts).map((e => e.toJSON()))];
        return this.isStart() && !this.type && t.unshift([]),
        this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && "!" === (null == (e = __privateGet(this, _parent)) ? void 0 : e.type)) && t.push({}),
        t
    }
    isStart() {
        var t;
        if (__privateGet(this, _root) === this)
            return !0;
        if (!(null == (t = __privateGet(this, _parent)) ? void 0 : t.isStart()))
            return !1;
        if (0 === __privateGet(this, _parentIndex))
            return !0;
        const n = __privateGet(this, _parent);
        for (let r = 0; r < __privateGet(this, _parentIndex); r++) {
            const t = __privateGet(n, _parts)[r];
            if (!(t instanceof e && "!" === t.type))
                return !1
        }
        return !0
    }
    isEnd() {
        var e, t, n;
        if (__privateGet(this, _root) === this)
            return !0;
        if ("!" === (null == (e = __privateGet(this, _parent)) ? void 0 : e.type))
            return !0;
        if (!(null == (t = __privateGet(this, _parent)) ? void 0 : t.isEnd()))
            return !1;
        if (!this.type)
            return null == (n = __privateGet(this, _parent)) ? void 0 : n.isEnd();
        const r = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
        return __privateGet(this, _parentIndex) === r - 1
    }
    copyIn(e) {
        "string" == typeof e ? this.push(e) : this.push(e.clone(this))
    }
    clone(t) {
        const n = new e(this.type,t);
        for (const e of __privateGet(this, _parts))
            n.copyIn(e);
        return n
    }
    static fromGlob(t, n={}) {
        var r;
        const o = new e(null,void 0,n);
        return __privateMethod(r = e, _AST_static, parseAST_fn).call(r, t, o, 0, n),
        o
    }
    toMMPattern() {
        if (this !== __privateGet(this, _root))
            return __privateGet(this, _root).toMMPattern();
        const e = this.toString()
          , [t,n,r,o] = this.toRegExpSource();
        if (!(r || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && e.toUpperCase() !== e.toLowerCase()))
            return n;
        const i = (__privateGet(this, _options).nocase ? "i" : "") + (o ? "u" : "");
        return Object.assign(new RegExp("^".concat(t, "$"),i), {
            _src: t,
            _glob: e
        })
    }
    get options() {
        return __privateGet(this, _options)
    }
    toRegExpSource(t) {
        var n;
        const r = null != t ? t : !!__privateGet(this, _options).dot;
        if (__privateGet(this, _root) === this && __privateMethod(this, _AST_instances, fillNegs_fn).call(this),
        !this.type) {
            const o = this.isStart() && this.isEnd()
              , i = __privateGet(this, _parts).map((n => {
                var r;
                const [i,a,s,c] = "string" == typeof n ? __privateMethod(r = e, _AST_static, parseGlob_fn).call(r, n, __privateGet(this, _hasMagic), o) : n.toRegExpSource(t);
                return __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || s),
                __privateSet(this, _uflag, __privateGet(this, _uflag) || c),
                i
            }
            )).join("");
            let a = "";
            if (this.isStart() && "string" == typeof __privateGet(this, _parts)[0]) {
                if (!(1 === __privateGet(this, _parts).length && justDots.has(__privateGet(this, _parts)[0]))) {
                    const e = addPatternStart
                      , n = r && e.has(i.charAt(0)) || i.startsWith("\\.") && e.has(i.charAt(2)) || i.startsWith("\\.\\.") && e.has(i.charAt(4))
                      , o = !r && !t && e.has(i.charAt(0));
                    a = n ? startNoTraversal : o ? startNoDot : ""
                }
            }
            let s = "";
            this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && "!" === (null == (n = __privateGet(this, _parent)) ? void 0 : n.type) && (s = "(?:$|\\/)");
            return [a + i + s, unescape$1(i), __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)), __privateGet(this, _uflag)]
        }
        const o = "*" === this.type || "+" === this.type
          , i = "!" === this.type ? "(?:(?!(?:" : "(?:";
        let a = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, r);
        if (this.isStart() && this.isEnd() && !a && "!" !== this.type) {
            const e = this.toString();
            return __privateSet(this, _parts, [e]),
            this.type = null,
            __privateSet(this, _hasMagic, void 0),
            [e, unescape$1(this.toString()), !1, !1]
        }
        let s = !o || t || r || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, !0);
        s === a && (s = ""),
        s && (a = "(?:".concat(a, ")(?:").concat(s, ")*?"));
        let c = "";
        if ("!" === this.type && __privateGet(this, _emptyExt))
            c = (this.isStart() && !r ? startNoDot : "") + starNoEmpty;
        else {
            c = i + a + ("!" === this.type ? "))" + (!this.isStart() || r || t ? "" : startNoDot) + star$1 + ")" : "@" === this.type ? ")" : "?" === this.type ? ")?" : "+" === this.type && s ? ")" : "*" === this.type && s ? ")?" : ")".concat(this.type))
        }
        return [c, unescape$1(a), __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)), __privateGet(this, _uflag)]
    }
}
;
_root = new WeakMap,
_hasMagic = new WeakMap,
_uflag = new WeakMap,
_parts = new WeakMap,
_parent = new WeakMap,
_parentIndex = new WeakMap,
_negs = new WeakMap,
_filledNegs = new WeakMap,
_options = new WeakMap,
_toString = new WeakMap,
_emptyExt = new WeakMap,
_AST_instances = new WeakSet,
fillNegs_fn = function() {
    if (this !== __privateGet(this, _root))
        throw new Error("should only call on root");
    if (__privateGet(this, _filledNegs))
        return this;
    let e;
    for (this.toString(),
    __privateSet(this, _filledNegs, !0); e = __privateGet(this, _negs).pop(); ) {
        if ("!" !== e.type)
            continue;
        let t = e
          , n = __privateGet(t, _parent);
        for (; n; ) {
            for (let r = __privateGet(t, _parentIndex) + 1; !n.type && r < __privateGet(n, _parts).length; r++)
                for (const t of __privateGet(e, _parts)) {
                    if ("string" == typeof t)
                        throw new Error("string part in extglob AST??");
                    t.copyIn(__privateGet(n, _parts)[r])
                }
            t = n,
            n = __privateGet(t, _parent)
        }
    }
    return this
}
,
_AST_static = new WeakSet,
parseAST_fn = function(e, t, n, r) {
    var o, i;
    let a = !1
      , s = !1
      , c = -1
      , l = !1;
    if (null === t.type) {
        let i = n
          , u = "";
        for (; i < e.length; ) {
            const n = e.charAt(i++);
            if (a || "\\" === n)
                a = !a,
                u += n;
            else if (s)
                i === c + 1 ? "^" !== n && "!" !== n || (l = !0) : "]" !== n || i === c + 2 && l || (s = !1),
                u += n;
            else if ("[" !== n)
                if (r.noext || !isExtglobType(n) || "(" !== e.charAt(i))
                    u += n;
                else {
                    t.push(u),
                    u = "";
                    const a = new _AST(n,t);
                    i = __privateMethod(o = _AST, _AST_static, parseAST_fn).call(o, e, a, i, r),
                    t.push(a)
                }
            else
                s = !0,
                c = i,
                l = !1,
                u += n
        }
        return t.push(u),
        i
    }
    let u = n + 1
      , p = new _AST(null,t);
    const d = [];
    let f = "";
    for (; u < e.length; ) {
        const n = e.charAt(u++);
        if (a || "\\" === n)
            a = !a,
            f += n;
        else if (s)
            u === c + 1 ? "^" !== n && "!" !== n || (l = !0) : "]" !== n || u === c + 2 && l || (s = !1),
            f += n;
        else if ("[" !== n)
            if (isExtglobType(n) && "(" === e.charAt(u)) {
                p.push(f),
                f = "";
                const t = new _AST(n,p);
                p.push(t),
                u = __privateMethod(i = _AST, _AST_static, parseAST_fn).call(i, e, t, u, r)
            } else if ("|" !== n) {
                if (")" === n)
                    return "" === f && 0 === __privateGet(t, _parts).length && __privateSet(t, _emptyExt, !0),
                    p.push(f),
                    f = "",
                    t.push(...d, p),
                    u;
                f += n
            } else
                p.push(f),
                f = "",
                d.push(p),
                p = new _AST(null,t);
        else
            s = !0,
            c = u,
            l = !1,
            f += n
    }
    return t.type = null,
    __privateSet(t, _hasMagic, void 0),
    __privateSet(t, _parts, [e.substring(n - 1)]),
    u
}
,
partsToRegExp_fn = function(e) {
    return __privateGet(this, _parts).map((t => {
        if ("string" == typeof t)
            throw new Error("string type in extglob ast??");
        const [n,r,o,i] = t.toRegExpSource(e);
        return __privateSet(this, _uflag, __privateGet(this, _uflag) || i),
        n
    }
    )).filter((e => !(this.isStart() && this.isEnd() && !e))).join("|")
}
,
parseGlob_fn = function(e, t, n=!1) {
    let r = !1
      , o = ""
      , i = !1;
    for (let a = 0; a < e.length; a++) {
        const s = e.charAt(a);
        if (r)
            r = !1,
            o += (reSpecials.has(s) ? "\\" : "") + s;
        else if ("\\" !== s) {
            if ("[" === s) {
                const [n,r,s,c] = parseClass(e, a);
                if (s) {
                    o += n,
                    i = i || r,
                    a += s - 1,
                    t = t || c;
                    continue
                }
            }
            "*" !== s ? "?" !== s ? o += regExpEscape$1(s) : (o += qmark$1,
            t = !0) : (o += n && "*" === e ? starNoEmpty : star$1,
            t = !0)
        } else
            a === e.length - 1 ? o += "\\\\" : r = !0
    }
    return [o, unescape$1(e), !!t, i]
}
,
__privateAdd(_AST, _AST_static);
let AST = _AST;
const escape$2 = (e, {windowsPathsNoEscape: t=!1}={}) => t ? e.replace(/[?*()[\]]/g, "[$&]") : e.replace(/[?*()[\]\\]/g, "\\$&");
var define_process_env_default$1 = {};
const minimatch = (e, t, n={}) => (assertValidPattern(t),
!(!n.nocomment && "#" === t.charAt(0)) && new Minimatch(t,n).match(e))
  , starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/
  , starDotExtTest = e => t => !t.startsWith(".") && t.endsWith(e)
  , starDotExtTestDot = e => t => t.endsWith(e)
  , starDotExtTestNocase = e => (e = e.toLowerCase(),
t => !t.startsWith(".") && t.toLowerCase().endsWith(e))
  , starDotExtTestNocaseDot = e => (e = e.toLowerCase(),
t => t.toLowerCase().endsWith(e))
  , starDotStarRE = /^\*+\.\*+$/
  , starDotStarTest = e => !e.startsWith(".") && e.includes(".")
  , starDotStarTestDot = e => "." !== e && ".." !== e && e.includes(".")
  , dotStarRE = /^\.\*+$/
  , dotStarTest = e => "." !== e && ".." !== e && e.startsWith(".")
  , starRE = /^\*+$/
  , starTest = e => 0 !== e.length && !e.startsWith(".")
  , starTestDot = e => 0 !== e.length && "." !== e && ".." !== e
  , qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/
  , qmarksTestNocase = ([e,t=""]) => {
    const n = qmarksTestNoExt([e]);
    return t ? (t = t.toLowerCase(),
    e => n(e) && e.toLowerCase().endsWith(t)) : n
}
  , qmarksTestNocaseDot = ([e,t=""]) => {
    const n = qmarksTestNoExtDot([e]);
    return t ? (t = t.toLowerCase(),
    e => n(e) && e.toLowerCase().endsWith(t)) : n
}
  , qmarksTestDot = ([e,t=""]) => {
    const n = qmarksTestNoExtDot([e]);
    return t ? e => n(e) && e.endsWith(t) : n
}
  , qmarksTest = ([e,t=""]) => {
    const n = qmarksTestNoExt([e]);
    return t ? e => n(e) && e.endsWith(t) : n
}
  , qmarksTestNoExt = ([e]) => {
    const t = e.length;
    return e => e.length === t && !e.startsWith(".")
}
  , qmarksTestNoExtDot = ([e]) => {
    const t = e.length;
    return e => e.length === t && "." !== e && ".." !== e
}
  , defaultPlatform = "object" == typeof process && process ? "object" == typeof define_process_env_default$1 && define_process_env_default$1 && define_process_env_default$1.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix"
  , path = {
    win32: {
        sep: "\\"
    },
    posix: {
        sep: "/"
    }
}
  , sep = "win32" === defaultPlatform ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
const qmark = "[^/]"
  , star = qmark + "*?"
  , twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?"
  , twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?"
  , filter = (e, t={}) => n => minimatch(n, e, t);
minimatch.filter = filter;
const ext = (e, t={}) => Object.assign({}, e, t)
  , defaults = e => {
    if (!e || "object" != typeof e || !Object.keys(e).length)
        return minimatch;
    const t = minimatch;
    return Object.assign(( (n, r, o={}) => t(n, r, ext(e, o))), {
        Minimatch: class extends t.Minimatch {
            constructor(t, n={}) {
                super(t, ext(e, n))
            }
            static defaults(n) {
                return t.defaults(ext(e, n)).Minimatch
            }
        }
        ,
        AST: class extends t.AST {
            constructor(t, n, r={}) {
                super(t, n, ext(e, r))
            }
            static fromGlob(n, r={}) {
                return t.AST.fromGlob(n, ext(e, r))
            }
        }
        ,
        unescape: (n, r={}) => t.unescape(n, ext(e, r)),
        escape: (n, r={}) => t.escape(n, ext(e, r)),
        filter: (n, r={}) => t.filter(n, ext(e, r)),
        defaults: n => t.defaults(ext(e, n)),
        makeRe: (n, r={}) => t.makeRe(n, ext(e, r)),
        braceExpand: (n, r={}) => t.braceExpand(n, ext(e, r)),
        match: (n, r, o={}) => t.match(n, r, ext(e, o)),
        sep: t.sep,
        GLOBSTAR: GLOBSTAR
    })
}
;
minimatch.defaults = defaults;
const braceExpand = (e, t={}) => (assertValidPattern(e),
t.nobrace || !/\{(?:(?!\{).)*\}/.test(e) ? [e] : expand$1(e));
minimatch.braceExpand = braceExpand;
const makeRe = (e, t={}) => new Minimatch(e,t).makeRe();
minimatch.makeRe = makeRe;
const match$1 = (e, t, n={}) => {
    const r = new Minimatch(t,n);
    return e = e.filter((e => r.match(e))),
    r.options.nonull && !e.length && e.push(t),
    e
}
;
minimatch.match = match$1;
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/
  , regExpEscape = e => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class Minimatch {
    constructor(e, t={}) {
        __publicField(this, "options"),
        __publicField(this, "set"),
        __publicField(this, "pattern"),
        __publicField(this, "windowsPathsNoEscape"),
        __publicField(this, "nonegate"),
        __publicField(this, "negate"),
        __publicField(this, "comment"),
        __publicField(this, "empty"),
        __publicField(this, "preserveMultipleSlashes"),
        __publicField(this, "partial"),
        __publicField(this, "globSet"),
        __publicField(this, "globParts"),
        __publicField(this, "nocase"),
        __publicField(this, "isWindows"),
        __publicField(this, "platform"),
        __publicField(this, "windowsNoMagicRoot"),
        __publicField(this, "regexp"),
        assertValidPattern(e),
        t = t || {},
        this.options = t,
        this.pattern = e,
        this.platform = t.platform || defaultPlatform,
        this.isWindows = "win32" === this.platform,
        this.windowsPathsNoEscape = !!t.windowsPathsNoEscape || !1 === t.allowWindowsEscape,
        this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")),
        this.preserveMultipleSlashes = !!t.preserveMultipleSlashes,
        this.regexp = null,
        this.negate = !1,
        this.nonegate = !!t.nonegate,
        this.comment = !1,
        this.empty = !1,
        this.partial = !!t.partial,
        this.nocase = !!this.options.nocase,
        this.windowsNoMagicRoot = void 0 !== t.windowsNoMagicRoot ? t.windowsNoMagicRoot : !(!this.isWindows || !this.nocase),
        this.globSet = [],
        this.globParts = [],
        this.set = [],
        this.make()
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1)
            return !0;
        for (const e of this.set)
            for (const t of e)
                if ("string" != typeof t)
                    return !0;
        return !1
    }
    debug(...e) {}
    make() {
        const e = this.pattern
          , t = this.options;
        if (!t.nocomment && "#" === e.charAt(0))
            return void (this.comment = !0);
        if (!e)
            return void (this.empty = !0);
        this.parseNegate(),
        this.globSet = [...new Set(this.braceExpand())],
        t.debug && (this.debug = (...e) => console.error(...e)),
        this.debug(this.pattern, this.globSet);
        const n = this.globSet.map((e => this.slashSplit(e)));
        this.globParts = this.preprocess(n),
        this.debug(this.pattern, this.globParts);
        let r = this.globParts.map(( (e, t, n) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                const t = !("" !== e[0] || "" !== e[1] || "?" !== e[2] && globMagic.test(e[2]) || globMagic.test(e[3]))
                  , n = /^[a-z]:/i.test(e[0]);
                if (t)
                    return [...e.slice(0, 4), ...e.slice(4).map((e => this.parse(e)))];
                if (n)
                    return [e[0], ...e.slice(1).map((e => this.parse(e)))]
            }
            return e.map((e => this.parse(e)))
        }
        ));
        if (this.debug(this.pattern, r),
        this.set = r.filter((e => -1 === e.indexOf(!1))),
        this.isWindows)
            for (let o = 0; o < this.set.length; o++) {
                const e = this.set[o];
                "" === e[0] && "" === e[1] && "?" === this.globParts[o][2] && "string" == typeof e[3] && /^[a-z]:$/i.test(e[3]) && (e[2] = "?")
            }
        this.debug(this.pattern, this.set)
    }
    preprocess(e) {
        if (this.options.noglobstar)
            for (let n = 0; n < e.length; n++)
                for (let t = 0; t < e[n].length; t++)
                    "**" === e[n][t] && (e[n][t] = "*");
        const {optimizationLevel: t=1} = this.options;
        return t >= 2 ? (e = this.firstPhasePreProcess(e),
        e = this.secondPhasePreProcess(e)) : e = t >= 1 ? this.levelOneOptimize(e) : this.adjascentGlobstarOptimize(e),
        e
    }
    adjascentGlobstarOptimize(e) {
        return e.map((e => {
            let t = -1;
            for (; -1 !== (t = e.indexOf("**", t + 1)); ) {
                let n = t;
                for (; "**" === e[n + 1]; )
                    n++;
                n !== t && e.splice(t, n - t)
            }
            return e
        }
        ))
    }
    levelOneOptimize(e) {
        return e.map((e => 0 === (e = e.reduce(( (e, t) => {
            const n = e[e.length - 1];
            return "**" === t && "**" === n ? e : ".." === t && n && ".." !== n && "." !== n && "**" !== n ? (e.pop(),
            e) : (e.push(t),
            e)
        }
        ), [])).length ? [""] : e))
    }
    levelTwoFileOptimize(e) {
        Array.isArray(e) || (e = this.slashSplit(e));
        let t = !1;
        do {
            if (t = !1,
            !this.preserveMultipleSlashes) {
                for (let n = 1; n < e.length - 1; n++) {
                    const r = e[n];
                    1 === n && "" === r && "" === e[0] || ("." !== r && "" !== r || (t = !0,
                    e.splice(n, 1),
                    n--))
                }
                "." !== e[0] || 2 !== e.length || "." !== e[1] && "" !== e[1] || (t = !0,
                e.pop())
            }
            let n = 0;
            for (; -1 !== (n = e.indexOf("..", n + 1)); ) {
                const r = e[n - 1];
                r && "." !== r && ".." !== r && "**" !== r && (t = !0,
                e.splice(n - 1, 2),
                n -= 2)
            }
        } while (t);
        return 0 === e.length ? [""] : e
    }
    firstPhasePreProcess(e) {
        let t = !1;
        do {
            t = !1;
            for (let n of e) {
                let r = -1;
                for (; -1 !== (r = n.indexOf("**", r + 1)); ) {
                    let o = r;
                    for (; "**" === n[o + 1]; )
                        o++;
                    o > r && n.splice(r + 1, o - r);
                    let i = n[r + 1];
                    const a = n[r + 2]
                      , s = n[r + 3];
                    if (".." !== i)
                        continue;
                    if (!a || "." === a || ".." === a || !s || "." === s || ".." === s)
                        continue;
                    t = !0,
                    n.splice(r, 1);
                    const c = n.slice(0);
                    c[r] = "**",
                    e.push(c),
                    r--
                }
                if (!this.preserveMultipleSlashes) {
                    for (let e = 1; e < n.length - 1; e++) {
                        const r = n[e];
                        1 === e && "" === r && "" === n[0] || ("." !== r && "" !== r || (t = !0,
                        n.splice(e, 1),
                        e--))
                    }
                    "." !== n[0] || 2 !== n.length || "." !== n[1] && "" !== n[1] || (t = !0,
                    n.pop())
                }
                let o = 0;
                for (; -1 !== (o = n.indexOf("..", o + 1)); ) {
                    const e = n[o - 1];
                    if (e && "." !== e && ".." !== e && "**" !== e) {
                        t = !0;
                        const e = 1 === o && "**" === n[o + 1] ? ["."] : [];
                        n.splice(o - 1, 2, ...e),
                        0 === n.length && n.push(""),
                        o -= 2
                    }
                }
            }
        } while (t);
        return e
    }
    secondPhasePreProcess(e) {
        for (let t = 0; t < e.length - 1; t++)
            for (let n = t + 1; n < e.length; n++) {
                const r = this.partsMatch(e[t], e[n], !this.preserveMultipleSlashes);
                if (r) {
                    e[t] = [],
                    e[n] = r;
                    break
                }
            }
        return e.filter((e => e.length))
    }
    partsMatch(e, t, n=!1) {
        let r = 0
          , o = 0
          , i = []
          , a = "";
        for (; r < e.length && o < t.length; )
            if (e[r] === t[o])
                i.push("b" === a ? t[o] : e[r]),
                r++,
                o++;
            else if (n && "**" === e[r] && t[o] === e[r + 1])
                i.push(e[r]),
                r++;
            else if (n && "**" === t[o] && e[r] === t[o + 1])
                i.push(t[o]),
                o++;
            else if ("*" !== e[r] || !t[o] || !this.options.dot && t[o].startsWith(".") || "**" === t[o]) {
                if ("*" !== t[o] || !e[r] || !this.options.dot && e[r].startsWith(".") || "**" === e[r])
                    return !1;
                if ("a" === a)
                    return !1;
                a = "b",
                i.push(t[o]),
                r++,
                o++
            } else {
                if ("b" === a)
                    return !1;
                a = "a",
                i.push(e[r]),
                r++,
                o++
            }
        return e.length === t.length && i
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const e = this.pattern;
        let t = !1
          , n = 0;
        for (let r = 0; r < e.length && "!" === e.charAt(r); r++)
            t = !t,
            n++;
        n && (this.pattern = e.slice(n)),
        this.negate = t
    }
    matchOne(e, t, n=!1) {
        const r = this.options;
        if (this.isWindows) {
            const n = "string" == typeof e[0] && /^[a-z]:$/i.test(e[0])
              , r = !n && "" === e[0] && "" === e[1] && "?" === e[2] && /^[a-z]:$/i.test(e[3])
              , o = "string" == typeof t[0] && /^[a-z]:$/i.test(t[0])
              , i = r ? 3 : n ? 0 : void 0
              , a = !o && "" === t[0] && "" === t[1] && "?" === t[2] && "string" == typeof t[3] && /^[a-z]:$/i.test(t[3]) ? 3 : o ? 0 : void 0;
            if ("number" == typeof i && "number" == typeof a) {
                const [n,r] = [e[i], t[a]];
                n.toLowerCase() === r.toLowerCase() && (t[a] = n,
                a > i ? t = t.slice(a) : i > a && (e = e.slice(i)))
            }
        }
        const {optimizationLevel: o=1} = this.options;
        o >= 2 && (e = this.levelTwoFileOptimize(e)),
        this.debug("matchOne", this, {
            file: e,
            pattern: t
        }),
        this.debug("matchOne", e.length, t.length);
        for (var i = 0, a = 0, s = e.length, c = t.length; i < s && a < c; i++,
        a++) {
            this.debug("matchOne loop");
            var l = t[a]
              , u = e[i];
            if (this.debug(t, l, u),
            !1 === l)
                return !1;
            if (l === GLOBSTAR) {
                this.debug("GLOBSTAR", [t, l, u]);
                var p = i
                  , d = a + 1;
                if (d === c) {
                    for (this.debug("** at the end"); i < s; i++)
                        if ("." === e[i] || ".." === e[i] || !r.dot && "." === e[i].charAt(0))
                            return !1;
                    return !0
                }
                for (; p < s; ) {
                    var f = e[p];
                    if (this.debug("\nglobstar while", e, p, t, d, f),
                    this.matchOne(e.slice(p), t.slice(d), n))
                        return this.debug("globstar found match!", p, s, f),
                        !0;
                    if ("." === f || ".." === f || !r.dot && "." === f.charAt(0)) {
                        this.debug("dot detected!", e, p, t, d);
                        break
                    }
                    this.debug("globstar swallow a segment, and continue"),
                    p++
                }
                return !(!n || (this.debug("\n>>> no match, partial?", e, p, t, d),
                p !== s))
            }
            let o;
            if ("string" == typeof l ? (o = u === l,
            this.debug("string match", l, u, o)) : (o = l.test(u),
            this.debug("pattern match", l, u, o)),
            !o)
                return !1
        }
        if (i === s && a === c)
            return !0;
        if (i === s)
            return n;
        if (a === c)
            return i === s - 1 && "" === e[i];
        throw new Error("wtf?")
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options)
    }
    parse(e) {
        assertValidPattern(e);
        const t = this.options;
        if ("**" === e)
            return GLOBSTAR;
        if ("" === e)
            return "";
        let n, r = null;
        (n = e.match(starRE)) ? r = t.dot ? starTestDot : starTest : (n = e.match(starDotExtRE)) ? r = (t.nocase ? t.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : t.dot ? starDotExtTestDot : starDotExtTest)(n[1]) : (n = e.match(qmarksRE)) ? r = (t.nocase ? t.dot ? qmarksTestNocaseDot : qmarksTestNocase : t.dot ? qmarksTestDot : qmarksTest)(n) : (n = e.match(starDotStarRE)) ? r = t.dot ? starDotStarTestDot : starDotStarTest : (n = e.match(dotStarRE)) && (r = dotStarTest);
        const o = AST.fromGlob(e, this.options).toMMPattern();
        return r && "object" == typeof o && Reflect.defineProperty(o, "test", {
            value: r
        }),
        o
    }
    makeRe() {
        if (this.regexp || !1 === this.regexp)
            return this.regexp;
        const e = this.set;
        if (!e.length)
            return this.regexp = !1,
            this.regexp;
        const t = this.options
          , n = t.noglobstar ? star : t.dot ? twoStarDot : twoStarNoDot
          , r = new Set(t.nocase ? ["i"] : []);
        let o = e.map((e => {
            const t = e.map((e => {
                if (e instanceof RegExp)
                    for (const t of e.flags.split(""))
                        r.add(t);
                return "string" == typeof e ? regExpEscape(e) : e === GLOBSTAR ? GLOBSTAR : e._src
            }
            ));
            return t.forEach(( (e, r) => {
                const o = t[r + 1]
                  , i = t[r - 1];
                e === GLOBSTAR && i !== GLOBSTAR && (void 0 === i ? void 0 !== o && o !== GLOBSTAR ? t[r + 1] = "(?:\\/|" + n + "\\/)?" + o : t[r] = n : void 0 === o ? t[r - 1] = i + "(?:\\/|" + n + ")?" : o !== GLOBSTAR && (t[r - 1] = i + "(?:\\/|\\/" + n + "\\/)" + o,
                t[r + 1] = GLOBSTAR))
            }
            )),
            t.filter((e => e !== GLOBSTAR)).join("/")
        }
        )).join("|");
        const [i,a] = e.length > 1 ? ["(?:", ")"] : ["", ""];
        o = "^" + i + o + a + "$",
        this.negate && (o = "^(?!" + o + ").+$");
        try {
            this.regexp = new RegExp(o,[...r].join(""))
        } catch (s) {
            this.regexp = !1
        }
        return this.regexp
    }
    slashSplit(e) {
        return this.preserveMultipleSlashes ? e.split("/") : this.isWindows && /^\/\/[^\/]+/.test(e) ? ["", ...e.split(/\/+/)] : e.split(/\/+/)
    }
    match(e, t=this.partial) {
        if (this.debug("match", e, this.pattern),
        this.comment)
            return !1;
        if (this.empty)
            return "" === e;
        if ("/" === e && t)
            return !0;
        const n = this.options;
        this.isWindows && (e = e.split("\\").join("/"));
        const r = this.slashSplit(e);
        this.debug(this.pattern, "split", r);
        const o = this.set;
        this.debug(this.pattern, "set", o);
        let i = r[r.length - 1];
        if (!i)
            for (let a = r.length - 2; !i && a >= 0; a--)
                i = r[a];
        for (let a = 0; a < o.length; a++) {
            const e = o[a];
            let s = r;
            n.matchBase && 1 === e.length && (s = [i]);
            if (this.matchOne(s, e, t))
                return !!n.flipNegate || !this.negate
        }
        return !n.flipNegate && this.negate
    }
    static defaults(e) {
        return minimatch.defaults(e).Minimatch
    }
}
minimatch.AST = AST,
minimatch.Minimatch = Minimatch,
minimatch.escape = escape$2,
minimatch.unescape = unescape$1;
const noopAdapter = e => (console.error("[Sig4] 没有执行正确的请求适配器, 请检查配置是否传入adapter: sig4Adapter(options: Sig4Options, adapter: AxiosAdapter)"),
console.error("[Sig4]", e),
Promise.reject(e))
  , SIGN_EVENT = {
    success: "sign_success",
    error: "sign_failed"
};
function isMatch(e, t) {
    return e.some((e => minimatch(t, e)))
}
function formatParams(e) {
    const {url: t, params: n={}, data: r, headers: o} = e
      , i = new URL(t,window.location.origin)
      , a = i.pathname
      , s = new URLSearchParams(i.search)
      , c = {
        ...n
    };
    s.forEach(( (e, t) => {
        c[t] = e
    }
    ));
    const l = o.getContentType() || o["Content-Type"] || "";
    return {
        path: a,
        query: c,
        data: r,
        contentType: String(l)
    }
}
const now = "undefined" != typeof performance && performance.now ? function() {
    return performance.now()
}
: function() {
    return (new Date).getTime()
}
;
async function getSig4(e, t) {
    return new Promise(( (n, r) => {
        e.call("$encode", [t, {
            suc(e, t) {
                n({
                    signResult: e,
                    signInput: t
                })
            },
            err(e) {
                r(e)
            }
        }])
    }
    ))
}
function getSig4Ver(e) {
    return e.call("$getCatVersion") || ""
}
function sig4Adapter(e, t, n=noopAdapter) {
    return async function(r, o=n) {
        var i, a, s;
        const c = getSig4Ver(e)
          , {useSign: l} = r
          , {path: u, query: p, data: d, contentType: f} = formatParams(r)
          , h = {
            path: u,
            query: p,
            data: d,
            contentType: f,
            signVersion: c
        };
        try {
            if (null != l ? l : isMatch(t.list, u)) {
                const n = now()
                  , o = {
                    url: u,
                    query: {
                        caver: c,
                        ...p
                    },
                    form: "application/x-www-form-urlencoded" === f && d ? d : {},
                    requestBody: "application/json" === f && d ? d : {}
                }
                  , {signResult: a} = await getSig4(e, o);
                r.params = Object.assign(r.params || {}, {
                    __NS_hxfalcon: a,
                    caver: c
                }),
                h.signResult = a,
                h.duration = now() - n,
                null == (i = t.hook) || i.call(t, SIGN_EVENT.success, h)
            } else
                null == (a = t.hook) || a.call(t)
        } catch (m) {
            h.error = m,
            null == (s = t.hook) || s.call(t, SIGN_EVENT.error, h)
        }
        return o(r)
    }
}
var Jose = function(e) {
    var t = {};
    function n(r) {
        var o;
        return (t[r] || (o = t[r] = {
            i: r,
            l: !1,
            exports: {}
        },
        e[r].call(o.exports, o, o.exports, n),
        o.l = !0,
        o)).exports
    }
    return n.m = e,
    n.c = t,
    n.d = function(e, t, r) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: r
        })
    }
    ,
    n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    n.t = function(e, t) {
        if (1 & t && (e = n(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var r = Object.create(null);
        if (n.r(r),
        Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var o in e)
                n.d(r, o, function(t) {
                    return e[t]
                }
                .bind(null, o));
        return r
    }
    ,
    n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return n.d(t, "a", t),
        t
    }
    ,
    n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    n.p = "",
    n(n.s = 4)
}([function(e, t) {
    function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    (function() {
        var e = Object.create
          , r = [];
        t.prototypeOf = function(e) {
            return null == e ? null : e.__proto__
        }
        ,
        t.create = e,
        t.hasProp = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t) || "object" === n(e[t]) && void 0 !== e[t]
        }
        ,
        t.isArray = function() {
            if ("function" != typeof Array.isArray)
                return obj instanceof Array
        }
        ,
        t.defProp = function(e, t, n) {
            return Object.defineProperty(e, t, n)
        }
        ,
        t.checkIdentifier = function(e) {
            return r.includes(e)
        }
        ,
        t.isNaNP = function(e) {
            return e != e
        }
    }
    ).call(this)
}
, function(e, t) {
    function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    var r = function() {
        return this
    }();
    try {
        r = r || new Function("return this")()
    } catch (o) {
        "object" === ("undefined" == typeof window ? "undefined" : n(window)) && (r = window)
    }
    e.exports = r
}
, function(e, t, n) {
    (function() {
        var e = n(7).VmError
          , r = {}.hasOwnProperty
          , o = (function(e, t) {
            for (var n in t)
                r.call(t, n) && (e[n] = t[n]);
            function o() {
                this.constructor = e
            }
            o.prototype = t.prototype,
            e.prototype = new o,
            e.__super__ = t.prototype
        }(i, e),
        i.display = "StopIteration",
        i);
        function i(e, t) {
            this.value = e,
            this.message = null != t ? t : "iterator has stopped"
        }
        function a(e) {
            this.elements = e,
            this.index = 0
        }
        a.prototype.next = function() {
            if (this.index >= this.elements.length)
                throw new o("array over");
            return this.elements[this.index++]
        }
        ,
        e = a,
        t.StopIteration = o,
        t.ArrayIterator = e
    }
    ).call(this)
}
, function(e, t, n) {
    function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    (function() {
        var e = {}.hasOwnProperty
          , o = n(0).isArray
          , i = (a.prototype.run = function() {
            for (var e = this.callStack[this.depth], t = e.error; 0 <= this.depth && e && !this.paused; )
                if ((e = t ? this.unwind(t) : e).run(),
                (t = e.error)instanceof Error && this.injectStackTrace(t),
                e.done()) {
                    if (e.guards.length) {
                        var n = e.guards.pop();
                        if (n.finalizer) {
                            e.ip = n.finalizer,
                            e.exitIp = n.end,
                            e.paused = !1;
                            continue
                        }
                    }
                    e.construct && "object" !== (n = r(this.rv)) && "function" !== n && (this.rv = e.scope.get(0)),
                    (e = this.popFrame()) && !t && (e.evalStack.push(this.rv),
                    this.rv = void 0)
                } else
                    t = (e = this.callStack[this.depth]).error;
            if (this.timedOut() && (t = new Error(this),
            this.injectStackTrace(t)),
            t)
                throw t
        }
        ,
        a.prototype.unwind = function(e) {
            for (var t = this.callStack[this.depth]; t; ) {
                t.error = e;
                var n = t.ip - 1
                  , r = t.guards.length;
                if (r && (r = t.guards[r - 1]).start <= n && n <= r.end) {
                    if (null !== r.handler)
                        if (n <= r.handler)
                            t.evalStack.push(e),
                            t.error = null,
                            t.ip = r.handler;
                        else {
                            if (!(r.finalizer && t.ip <= r.finalizer)) {
                                t = this.popFrame();
                                continue
                            }
                            t.ip = r.finalizer
                        }
                    else
                        t.ip = r.finalizer;
                    return t.paused = !1,
                    t
                }
                t = this.popFrame()
            }
            throw e
        }
        ,
        a.prototype.injectStackTrace = function(e) {
            var t, n, r, i, a, s, c, l = [], u = 0;
            for (this.depth > this.maxTraceDepth && (u = this.depth - this.maxTraceDepth),
            n = r = a = this.depth,
            s = u; a <= s ? r <= s : s <= r; n = a <= s ? ++r : --r)
                "<anonymous>" === (i = (t = this.callStack[n]).script.name) && t.fname && (i = t.fname),
                l.push({
                    at: {
                        name: i,
                        filename: t.script.filename
                    },
                    line: t.line,
                    column: t.column
                });
            if (e.trace) {
                for (c = e.trace; o(c[c.length - 1]); )
                    c = c[c.length - 1];
                c.push(l)
            } else
                e.trace = l;
            return e.stack = e.toString()
        }
        ,
        a.prototype.pushFrame = function(e, t, n, r, o, i, a) {
            if (null == i && (i = "<anonymous>"),
            null == a && (a = !1),
            this.checkCallStack())
                return (n = new p(n,e.localNames,e.localLength)).set(0, t),
                t = new s(this,e,n,this.realm,i,a),
                o && t.evalStack.push(o),
                r && t.evalStack.push(r),
                this.callStack[++this.depth] = t
        }
        ,
        a.prototype.checkCallStack = function() {
            return this.depth !== this.maxDepth || (this.callStack[this.depth].error = new Error("maximum call stack size exceeded"),
            this.pause(),
            !1)
        }
        ,
        a.prototype.popFrame = function() {
            var e = this.callStack[--this.depth];
            return e && (e.paused = !1),
            e
        }
        ,
        a.prototype.pause = function() {
            return this.paused = this.callStack[this.depth].paused = !0
        }
        ,
        a.prototype.resume = function(e) {
            if (this.timeout = null != e ? e : -1,
            this.paused = !1,
            this.callStack[this.depth].paused = !1,
            this.run(),
            !this.paused)
                return this.rexp
        }
        ,
        a.prototype.timedOut = function() {
            return 0 === this.timeout
        }
        ,
        a.prototype.send = function(e) {
            return this.callStack[this.depth].evalStack.push(e)
        }
        ,
        a.prototype.done = function() {
            return -1 === this.depth
        }
        ,
        a);
        function a(e, t) {
            this.realm = e,
            this.timeout = null != t ? t : -1,
            this.maxDepth = 1e3,
            this.maxTraceDepth = 50,
            this.callStack = [],
            this.evalStack = null,
            this.depth = -1,
            this.yielded = this.rv = void 0,
            this.paused = !1,
            this.r1 = this.r2 = this.r3 = null,
            this.rexp = null
        }
        c.prototype.run = function() {
            for (var e = this.script.instructions; this.ip !== this.exitIp && !this.paused; )
                e[this.ip++].exec(this, this.evalStack, this.scope, this.realm);
            var t = this.evalStack.len();
            if (!this.paused && !this.error && 0 !== t)
                throw new Error("Evaluation stack has " + t + " items after execution")
        }
        ,
        c.prototype.done = function() {
            return this.ip === this.exitIp
        }
        ,
        c.prototype.setLine = function(e) {
            this.line = e
        }
        ,
        c.prototype.setColumn = function(e) {
            this.column = e
        }
        ;
        var s = c;
        function c(e, t, n, r, o, i) {
            this.fiber = e,
            this.script = t,
            this.scope = n,
            this.realm = r,
            this.fname = o,
            this.construct = null != i && i,
            this.evalStack = new l(this.script.stackSize,this.fiber),
            this.ip = 0,
            this.exitIp = this.script.instructions.length,
            this.paused = !1,
            this.finalizer = null,
            this.guards = [],
            this.rv = void 0,
            this.line = this.column = -1
        }
        u.prototype.push = function(e) {
            if (this.idx === this.array.length)
                throw new Error("maximum evaluation stack size exceeded");
            return this.array[this.idx++] = e
        }
        ,
        u.prototype.pop = function() {
            return this.array[--this.idx]
        }
        ,
        u.prototype.top = function() {
            return this.array[this.idx - 1]
        }
        ,
        u.prototype.len = function() {
            return this.idx
        }
        ,
        u.prototype.clear = function() {
            return this.idx = 0
        }
        ;
        var l = u;
        function u(e, t) {
            this.fiber = t,
            this.array = new Array(e),
            this.idx = 0
        }
        d.prototype.get = function(e) {
            return this.data[e]
        }
        ,
        d.prototype.set = function(e, t) {
            return this.data[e] = t
        }
        ,
        d.prototype.name = function(t) {
            var n, r = this.names;
            for (n in r)
                if (e.call(r, n) && r[n] === t)
                    return parseInt(n);
            return -1
        }
        ;
        var p = d;
        function d(e, t, n) {
            this.parent = e,
            this.names = t,
            this.data = new Array(n)
        }
        h.prototype.get = function(e) {
            return this.object[e]
        }
        ,
        h.prototype.set = function(e, t) {
            return this.object[e] = t
        }
        ,
        h.prototype.has = function(e) {
            return e in this.object
        }
        ;
        var f = h;
        function h(e, t) {
            this.parent = e,
            this.object = t
        }
        t.Fiber = i,
        t.Scope = p,
        t.WithScope = f
    }
    ).call(this)
}
, function(e, t, n) {
    (n = new (n(5))).eval('["<script>",0,[[22]8false,15,null17]anonymous[,4,3163152,14[30721[,"$encode"1[8getCatVersi76,2049753379577389,88791625994-6-439,56919,018-52916763404582,-3064843563"c2true[j,8"ObjectjmpOnw_ms"04D"w2KsGuard6otDeviceInfo,b2sa_h2subs_h2b_xcAi,M"rdom70"tfloor"[0bx628$Epro[turlkpnf2bug"tnsn51meso[l"vOu_"iIxky07"tupRtEoHUDR4Baun0$HEuhxf_nadniinpurvcavsdk"SIG4签名信息:ep"错误lg"t8Ar54"n8toS0["3"DG1wxNYwyaAEhW5J.0.2'),
    e.exports = n
}
, function(e, t, n) {
    (function(t) {
        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            }
            : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }
            )(e)
        }
        (function(o) {
            var i = n(6)
              , a = n(8)
              , s = n(3).Fiber
              , c = n(11)
              , l = n(13)
              , u = n(14);
            function p(e) {
                this.realm = new i(e),
                this.realm.global.startupRandom = (new Date).getTime(),
                this.realm.global.count = 100,
                (new l).register(),
                (new u).register(),
                "object" !== ("undefined" == typeof window ? "undefined" : r(window)) && "object" !== (void 0 === t ? "undefined" : r(t)) || (e = n(15),
                this.realm.global.KsGuard = new e.default)
            }
            p.prototype.eval = function(e, t) {
                e = (new c).unzip(e),
                this.run(p.fromJSON(JSON.parse(e)), t),
                this.realm.global.startupEnd = (new Date).getTime()
            }
            ,
            p.prototype.run = function(e, t) {
                if ((e = this.createFiber(e, t)).run(),
                !e.paused)
                    return e.rexp
            }
            ,
            p.prototype.call = function(e, n) {
                var r = window || t;
                if ("$encode" === e)
                    try {
                        throw new Error
                    } catch (i) {
                        var o = i.stack.length;
                        r && (r.SECS = {
                            s: 100 < o ? i.stack.substr(o - 100, 100) : i.stack,
                            c: this.realm.global.count
                        })
                    }
                return this.realm.global[e].apply(this, n)
            }
            ,
            p.prototype.createFiber = function(e, t) {
                return (t = new s(this.realm,t)).pushFrame(e, this.realm.global),
                t
            }
            ,
            p.fromJSON = a.fromJSON,
            e.exports = p
        }
        ).call(this)
    }
    ).call(this, n(1))
}
, function(e, t, n) {
    (function(t) {
        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            }
            : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }
            )(e)
        }
        (function() {
            var o, i = {}.hasOwnProperty, a = (o = n(0)).prototypeOf, s = o.hasProp, c = (o = n(2)).ArrayIterator, l = o.StopIteration;
            function u(e) {
                var n, o, u = {
                    isBrowser: "undefined" == typeof window,
                    window: "undefined" == typeof window ? t : window,
                    localStorage: "object" === ("undefined" == typeof localStorage ? "undefined" : r(localStorage)) ? localStorage : {},
                    sessionStorage: "object" === ("undefined" == typeof sessionStorage ? "undefined" : r(sessionStorage)) ? sessionStorage : {},
                    document: "object" === ("undefined" == typeof document ? "undefined" : r(document)) ? document : {},
                    undefined: void 0,
                    Object: Object,
                    Function: Function,
                    Number: Number,
                    Boolean: Boolean,
                    String: String,
                    Array: Array,
                    Int8Array: Int8Array,
                    Int32Array: Int32Array,
                    Uint8Array: Uint8Array,
                    Date: Date,
                    RegExp: RegExp,
                    Error: Error,
                    StopIteration: l,
                    Math: Math,
                    JSON: JSON,
                    encodeURIComponent: encodeURIComponent,
                    unescape: unescape,
                    escape: escape,
                    decodeURIComponent: decodeURIComponent,
                    isNaN: isNaN,
                    Infinity: 1 / 0,
                    NaN: NaN,
                    parseInt: parseInt,
                    parseFloat: parseFloat,
                    isFinite: isFinite,
                    encodeURI: encodeURI,
                    decodeURI: decodeURI,
                    TypeError: TypeError,
                    URIError: URIError,
                    SyntaxError: SyntaxError,
                    ReferenceError: ReferenceError,
                    RangeError: RangeError,
                    EvalError: EvalError,
                    eval: eval,
                    console: console
                };
                for (n in this.has = function(e, t) {
                    return null != e && (!!s(e, t) || this.has(a(e), t))
                }
                ,
                this.get = function(e, t) {
                    return null == e ? void 0 : e[t]
                }
                ,
                this.set = function(e, t, n) {
                    var o = r(e);
                    return ("object" === o || "function" === o) && (e[t] = n),
                    n
                }
                ,
                this.del = function(e, t) {
                    var n = r(e);
                    return "object" !== n && "function" !== n || delete e[t]
                }
                ,
                this.instanceOf = function(e, t) {
                    var n;
                    return null != t && ("object" === (n = r(t)) || "function" === n) && t instanceof e
                }
                ,
                this.enumerateKeys = function(e) {
                    var t, n = [];
                    for (t in e)
                        "__mdid__" !== t && n.push(t);
                    return new c(n)
                }
                ,
                e)
                    i.call(e, n) && (o = e[n],
                    u[n] = o);
                this.global = u
            }
            u.prototype.inv = function(e) {
                return -e
            }
            ,
            u.prototype.lnot = function(e) {
                return !e
            }
            ,
            u.prototype.ladd = function(e) {
                return +e
            }
            ,
            u.prototype.not = function(e) {
                return ~e
            }
            ,
            u.prototype.inc = function(e) {
                return ++e
            }
            ,
            u.prototype.dec = function(e) {
                return e - 1
            }
            ,
            u.prototype.add = function(e, t) {
                return t + e
            }
            ,
            u.prototype.sub = function(e, t) {
                return t - e
            }
            ,
            u.prototype.mul = function(e, t) {
                return t * e
            }
            ,
            u.prototype.div = function(e, t) {
                return t / e
            }
            ,
            u.prototype.mod = function(e, t) {
                return t % e
            }
            ,
            u.prototype.shl = function(e, t) {
                return t << e
            }
            ,
            u.prototype.sar = function(e, t) {
                return t >> e
            }
            ,
            u.prototype.shr = function(e, t) {
                return t >>> e
            }
            ,
            u.prototype.or = function(e, t) {
                return t | e
            }
            ,
            u.prototype.and = function(e, t) {
                return t & e
            }
            ,
            u.prototype.xor = function(e, t) {
                return t ^ e
            }
            ,
            u.prototype.ceq = function(e, t) {
                return t == e
            }
            ,
            u.prototype.cneq = function(e, t) {
                return t != e
            }
            ,
            u.prototype.cid = function(e, t) {
                return t === e
            }
            ,
            u.prototype.cnid = function(e, t) {
                return t !== e
            }
            ,
            u.prototype.lt = function(e, t) {
                return t < e
            }
            ,
            u.prototype.lte = function(e, t) {
                return t <= e
            }
            ,
            u.prototype.gt = function(e, t) {
                return e < t
            }
            ,
            u.prototype.gte = function(e, t) {
                return e <= t
            }
            ,
            e.exports = u
        }
        ).call(this)
    }
    ).call(this, n(1))
}
, function(e, t, n) {
    var r = n(0).isArray
      , o = function e(t, n) {
        null == n && (n = ""),
        n += "    ";
        for (var o = "", i = 0; i < t.length; i++) {
            var a, s, c, l = t[i];
            r(l) ? o = (o += "\n\n" + n + "Rethrown:") + e(l, n) : (a = l.line,
            s = l.column,
            c = l.at.name,
            l = l.at.filename,
            o += c ? "\n" + n + "at " + c + " (" + l + ":" + a + ":" + s + ")" : "\n" + n + "at " + l + ":" + a + ":" + s)
        }
        return o
    };
    function i(e) {
        this.trace = null,
        this.message = e
    }
    i.prototype.toString = function() {
        var e = this.constructor.display + ": " + this.message;
        return this.trace && (e += o(this.trace)),
        e
    }
    ,
    i.prototype.stackTrace = function() {
        return this.toString()
    }
    ,
    t.VmError = i
}
, function(e, t, n) {
    (function() {
        var t = n(9)
          , r = function(e) {
            for (var n = [], r = 0; r < e.length; r++) {
                for (var o = e[r], i = t[o[0]], a = [], s = 1, c = 1, l = o.length; 1 <= l ? c < l : l < c; s = 1 <= l ? ++c : --c)
                    a.push(o[s]);
                i = new i(a.length ? a : null),
                n.push(i)
            }
            return n
        }
          , o = function(e) {
            var t = e.lastIndexOf("/")
              , n = e.slice(0, t);
            t = e.slice(t + 1);
            return new RegExp(n,t)
        }
          , i = (a.fromJSON = function e(t) {
            for (var n = r(t[2]), a = [], s = t[3], c = 0; c < s.length; c++) {
                var l = s[c];
                a.push(e(l))
            }
            for (var u = t[4], p = u.length, d = [], f = t[5], h = 0; h < f.length; h++) {
                var m = f[h];
                d.push({
                    start: -1 !== m[0] ? m[0] : null,
                    handler: -1 !== m[1] ? m[1] : null,
                    finalizer: -1 !== m[2] ? m[2] : null,
                    end: -1 !== m[3] ? m[3] : null
                })
            }
            for (var g = t[6], v = t[7], y = [], _ = t[8], b = 0; b < _.length; b++) {
                var E = _[b];
                y.push(o(E))
            }
            return new i(null,null,n,a,u,p,d,g,v,y,null)
        }
        ,
        a);
        function a(e, t, n, r, o, i, a, s, c, l, u) {
            this.filename = e,
            this.name = t,
            this.instructions = n,
            this.scripts = r,
            this.localNames = o,
            this.localLength = i,
            this.guards = a,
            this.stackSize = s,
            this.strings = c,
            this.regexps = l,
            this.source = u
        }
        e.exports = i
    }
    ).call(this)
}
, function(module, exports, __webpack_require__) {
    function _typeof(e) {
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    (function() {
        var ref = __webpack_require__(2)
          , StopIteration = ref.StopIteration
          , ref1 = __webpack_require__(0);
        ref1.defProp;
        var hasProp = ref1.hasProp
          , ref3 = __webpack_require__(3)
          , Fiber = ref3.Fiber
          , Scope = ref3.Scope
          , WithScope = ref3.WithScope
          , OpcodeClassFactory = function() {
            var e = 0;
            return function(t, n, r) {
                var o;
                return (o = function(e) {
                    e && (this.args = e)
                }
                ).prototype.id = e++,
                o.prototype.exec = n,
                o.prototype.calculateFactor = r || function() {
                    return 2
                }
                ,
                o
            }
        }();
        __webpack_require__(10);
        var Op = function(e, t, n) {
            return OpcodeClassFactory(e, t, n)
        }
          , opcodes = [new Op("",(function(e, t, n) {
            return ret(e)
        }
        )), new Op("",(function(e, t, n) {
            return t.pop()
        }
        )), new Op("",(function(e, t, n) {
            return t.push(t.top())
        }
        )), new Op("",(function(e, t, n) {
            var r = t.pop()
              , o = t.pop();
            return t.push(r),
            t.push(o)
        }
        )), new Op("",(function(e, t, n) {
            return e.fiber.rv = t.pop(),
            ret(e)
        }
        )), new Op("",(function(e, t) {
            return e.paused = !0
        }
        )), new Op("",(function(e, t) {
            return e.fiber.yielded = t.pop(),
            e.fiber.pause()
        }
        )), new Op("",(function(e, t, n) {
            return throwErr(e, t.pop())
        }
        )), new Op("",(function(e) {
            return e.guards.push(e.script.guards[this.args[0]])
        }
        )), new Op("",(function(e) {
            var t = e.guards[e.guards.length - 1];
            if (e.script.guards[this.args[0]] === t)
                return e.guards.pop()
        }
        )), new Op("",(function(e, t, n) {
            return e.fiber.r1 = t.pop()
        }
        )), new Op("",(function(e, t, n) {
            return e.fiber.r2 = t.pop()
        }
        )), new Op("",(function(e, t, n) {
            return e.fiber.r3 = t.pop()
        }
        )), new Op("",(function(e, t, n) {
            return t.push(e.fiber.r1)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(e.fiber.r2)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(e.fiber.r3)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(+e.fiber.r3)
        }
        )), new Op("",(function(e, t, n) {
            return t.fiber.rexp = t.pop()
        }
        )), new Op("",(function(e, t, n) {
            return callm(e, 0, "iterator", t.pop())
        }
        )), new Op("",(function(e, t, n, r) {
            return t.push(r.enumerateKeys(t.pop()))
        }
        )), new Op("",(function(e, t, n) {
            if (callm(e, 0, "next", t.pop()),
            e.error instanceof StopIteration)
                return e.error = null,
                e.paused = !1,
                e.ip = this.args[0]
        }
        )), new Op("",(function(e, t, n) {
            if (n.set(1, t.pop()),
            t = t.pop(),
            this.args[0])
                return n.set(2, t)
        }
        )), new Op("",(function(e, t, n, r) {
            return t.push(r.global)
        }
        )), new Op("",(function(e, t, n, r) {
            var o = this.args[0]
              , i = this.args[1]
              , a = n.get(1);
            if (o < a.length)
                return n.set(i, Array.prototype.slice.call(a, o))
        }
        )), new Op("",(function(e, t, n) {
            return call(e, this.args[0], t.pop(), null, null, !0)
        }
        )), new Op("",(function(e, t, n) {
            return call(e, this.args[0], t.pop(), null, this.args[1])
        }
        )), new Op("",(function(e, t, n) {
            return callm(e, this.args[0], t.pop(), t.pop(), this.args[1])
        }
        )), new Op("",(function(e, t, n, r) {
            var o = t.pop()
              , i = t.pop();
            return null == o ? throwErr(e, new TypeError("Cannot read property '" + i + "' of " + o)) : "function" == typeof o && "length" === i && void 0 !== o.originFnLength ? t.push(r.get(o, "originFnLength")) : t.push(r.get(o, i))
        }
        )), new Op("",(function(e, t, n, r) {
            var o = t.pop()
              , i = t.pop()
              , a = t.pop();
            return null == o ? throwErr(e, new TypeError("Cannot set property '" + i + "' of " + o)) : Object.isExtensible(o) || "__proto__" !== i ? t.push(r.set(o, i, a)) : throwErr(e, new Error("#<Object> is not extensible at set __proto__[as __proto__]"))
        }
        )), new Op("",(function(e, t, n, r) {
            var o = t.pop()
              , i = t.pop();
            return null == o ? throwErr(e, new Error("Cannot convert null to object")) : t.push(r.del(o, i))
        }
        )), new Op("",(function(e, t, n) {
            try {
                for (var r = this.args[0], o = this.args[1], i = n; r--; )
                    i = i.parent;
                return t.push(i.get(o))
            } catch (a) {
                return throwErr(e, a)
            }
        }
        )), new Op("",(function(e, t, n) {
            for (var r = this.args[0], o = this.args[1], i = n; r--; )
                i = i.parent;
            return t.push(i.set(o, t.pop()))
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                for (var o, i = this.args[0]; n instanceof WithScope; ) {
                    if (n.has(i))
                        return t.push(n.get(i));
                    n = n.parent
                }
                for (; n instanceof Scope; ) {
                    if (0 <= (o = n.name(i)))
                        return t.push(n.get(o));
                    n = n.parent
                }
                return hasProp(r.global, i) || this.args[1] ? t.push(r.global[i]) : throwErr(e, new Error(i + " is not defined"))
            } catch (a) {
                return throwErr(e, a)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                for (var o, i = this.args[0], a = t.pop(); n instanceof WithScope; ) {
                    if (n.has(i))
                        return t.push(n.set(i, a));
                    n = n.parent
                }
                for (; n instanceof Scope; ) {
                    if (0 <= (o = n.name(i)))
                        return t.push(n.set(o, a));
                    n = n.parent
                }
                return t.push(r.global[i] = a)
            } catch (s) {
                return throwErr(e, s)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            return hasProp(r.global, this.args[0]) || this.args[1] ? t.push(r.global[this.args[0]]) : "this" === this.args[0] ? t.push(r.global) : throwErr(e, new Error(this.args[0] + " is not defined"))
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.global[this.args[0]] = t.pop())
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e) {
            return e.scope = new Scope(e.scope,e.script.localNames,e.script.localLength)
        }
        )), new Op("",(function(e) {
            return e.scope = e.scope.parent
        }
        )), new Op("",(function(e, t) {
            return e.scope = new WithScope(e.scope,t.pop())
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.inv(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.lnot(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.ladd(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.not(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.inc(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.dec(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.add(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.sub(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.mul(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.div(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.mod(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.shl(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.sar(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.shr(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.or(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.and(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.xor(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.ceq(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.cneq(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.cid(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.cnid(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.lt(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.lte(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.gt(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.gte(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.has(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(r.instanceOf(t.pop(), t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t, n, r) {
            try {
                return t.push(_typeof(t.pop()))
            } catch (o) {
                return throwErr(e, o)
            }
        }
        )), new Op("",(function(e, t) {
            return t.pop(),
            t.push(void 0)
        }
        )), new Op("",(function(e, t, n) {
            return e.ip = this.args[0]
        }
        )), new Op("",(function(e, t, n) {
            if (t.pop())
                return e.ip = this.args[0]
        }
        )), new Op("",(function(e, t, n) {
            if (!t.pop())
                return e.ip = this.args[0]
        }
        )), new Op("",(function(e, t) {
            return t.push(void 0)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(this.args[0])
        }
        )), new Op("",(function(e, t, n) {
            return t.push(this.args[0] ? 1 / 0 : -1 / 0)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(NaN)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(-0)
        }
        )), new Op("",(function(e, t, n) {
            return t.push(e.script.strings[this.args[0]])
        }
        )), new Op("",(function(e, t, n, r) {
            return t.push(e.script.regexps[this.args[0]], r)
        }
        )), new Op("",(function(e, t, n, r) {
            for (var o = this.args[0], i = {}; o--; ) {
                var a = t.pop()
                  , s = t.pop();
                i.hasOwnProperty(a) || r.set(i, a, s)
            }
            return t.push(i)
        }
        )), new Op("",(function(e, t, n, r) {
            for (var o = this.args[0], i = new Array(o); o--; )
                i[o] = t.pop();
            return t.push(i)
        }
        )), new Op("",(function(e, t, n, r) {
            var o = this.args[0];
            return t.push(createFunction(e.script.scripts[o], n, r, this.args[1]))
        }
        )), new Op("",(function(e) {
            return e.setLine(this.args[0])
        }
        )), new Op("",(function(e) {
            return e.setColumn(this.args[0])
        }
        )), new Op("",(function(e, t, n) {
            return debug()
        }
        ))]
          , callm = function(e, t, n, r, o) {
            var i, a = e.evalStack, s = e.realm;
            return null == r ? throwErr(e, new Error("Cannot call method '" + n + "' of " + (void 0 === r ? "undefined" : "null"))) : (i = r.constructor.name || "Object",
            (s = s.get(r, n))instanceof Function ? call(e, t, s, r) : null == s ? (a.pop(),
            throwErr(e, new Error("Object #<" + i + "> has no method '" + n + "'"))) : (a.pop(),
            throwErr(e, new Error("Property '" + n + "' of object #<" + i + "> is not a function"))))
        }
          , call = function(e, t, n, r, o, i) {
            if ("function" != typeof n)
                return throwErr(e, new Error("object is not a function"));
            for (var a = e.evalStack, s = e.fiber, c = e.realm, l = {
                length: t,
                callee: n
            }; t; )
                l[--t] = a.pop();
            r = void 0 === r ? c.global : r,
            l = Array.prototype.slice.call(l);
            try {
                var u = i ? createNativeInstance(n, l) : n.apply(r, l);
                if (!s.paused)
                    return a.push(u)
            } catch (p) {
                throwErr(e, p)
            }
        }
          , createFunction = function(e, t, n, r, o) {
            var i;
            return (i = function r() {
                var o, i, a, s = !1;
                if ((i = r.__fiber__) ? (i.callStack[i.depth].paused = !0,
                r.__fiber__ = null,
                o = r.__construct__,
                r.__construct__ = null) : (i = new Fiber(n),
                s = !0),
                a = r.__callname__ || e.name,
                r.__callname__ = null,
                i.pushFrame(e, this, t, arguments, r, a, o),
                s)
                    return i.run(),
                    i.rv
            }
            ).originFnLength = o,
            i
        }
          , callArrayConstructor = function(e) {
            return 1 === e.length && (0 | e[0]) === e[0] ? new Array(e[0]) : e.slice()
        }
          , callRegExpConstructor = function(e) {
            return 1 === e.length ? new RegExp(e[0]) : new RegExp(e[0],e[1])
        }
          , createNativeInstance = function(e, t) {
            var n;
            return e === Array ? callArrayConstructor(t) : e === Date ? 0 === t.length ? new Date : new Date(t[0]) : e === RegExp ? callRegExpConstructor(t) : e === Number ? 0 === t.length ? new Number : new Number(t[0]) : e === Boolean ? 0 === t.length ? new Boolean : new Boolean(t[0]) : e === Uint8Array ? new Uint8Array(t[0]) : e === Int8Array ? new Int8Array(t[0]) : e === Int32Array ? new Int32Array(t[0]) : e === String ? new String(t[0] || "") : ((n = function() {
                return e.apply(this, t)
            }
            ).prototype = e.prototype,
            new n)
        }
          , ret = function(e) {
            return e.evalStack.clear(),
            e.exitIp = e.ip
        }
          , throwErr = function(e, t) {
            return e.error = t,
            e.paused = !0
        }
          , debug = function debug() {
            eval("debugger;")
        };
        module.exports = opcodes
    }
    ).call(this)
}
, function(e, t) {
    e.exports = function(e, t) {
        this.__proto__ = RegExp.prototype,
        Object.defineProperties(this, {
            global: {
                value: e.global
            },
            ignoreCase: {
                value: e.ignoreCase
            },
            multiline: {
                value: e.multiline
            },
            source: {
                value: e.source
            },
            hasIndices: {
                value: e.hasIndices
            },
            dotAll: {
                value: e.dotAll
            },
            flags: {
                value: e.flags
            },
            sticky: {
                value: e.sticky
            },
            unicode: {
                value: e.unicode
            }
        })
    }
}
, function(e, t, n) {
    var r, o;
    o = n(12),
    (r = function() {}
    ).prototype.zip = function(e) {
        return o.encode(e)
    }
    ,
    r.prototype.unzip = function(e) {
        return o.decode(e)
    }
    ,
    e.exports = r
}
, function(e, t) {
    function n(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++)
            r[n] = e[n];
        return r
    }
    e.exports.encode = function(e) {
        try {
            var t, n = {}, r = [], o = e[0], i = 57344;
            e = (e + "").split("");
            for (var a = 1; a < e.length; a++)
                null != n[o + (t = e[a])] && o + t !== "toString" ? o += t : (r.push(1 < o.length ? n[o] : o.codePointAt(0)),
                n[o + t] = i,
                i++,
                o = t);
            return r.push(1 < o.length ? n[o] : o.codePointAt(0)),
            r.map((function(e) {
                return String.fromCodePoint(e)
            }
            )).join("")
        } catch (s) {
            throw new Error(s)
        }
    }
    ,
    e.exports.decode = function(e) {
        try {
            for (var t = function(e) {
                return function(e) {
                    if (Array.isArray(e))
                        return n(e)
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                        return Array.from(e)
                }(e) || function(e, t) {
                    var r;
                    if (e)
                        return "string" == typeof e ? n(e, t) : "Map" === (r = "Object" === (r = Object.prototype.toString.call(e).slice(8, -1)) && e.constructor ? e.constructor.name : r) || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(e, t) : void 0
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }(e).map((function(e) {
                return e.codePointAt(0)
            }
            )), r = {}, o = String.fromCodePoint(t[0]), i = o, a = [o], s = 57344, c = 1; c < t.length; c++) {
                var l, u = t[c];
                a += l = u < 57344 ? String.fromCodePoint(t[c]) : r[u] || i + o,
                o = l[0],
                r[s] = i + o,
                s++,
                i = l
            }
            return a
        } catch (p) {
            throw new Error(p)
        }
    }
}
, function(e, t) {
    function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    var r, o, i, a, s, c, l, u, p, d, f, h, m, g, v, y, _, b, E, w;
    function S(e, t) {
        return e >>> t & 4294967295 | e << 32 - t & 4294967295
    }
    function O(e, t, n, r, o, i, a) {
        e[t] = e[t] + e[n] & 4294967295,
        e[t] = e[t] + i & 4294967295,
        e[o] ^= e[t],
        e[o] = S(e[o], 16),
        e[r] = e[r] + e[o] & 4294967295,
        e[n] ^= e[r],
        e[n] = S(e[n], 12),
        e[t] = e[t] + e[n] & 4294967295,
        e[t] = e[t] + a,
        e[o] ^= e[t],
        e[o] = S(e[o], 8),
        e[r] = e[r] + e[o] & 4294967295,
        e[n] ^= e[r],
        e[n] = S(e[n], 7)
    }
    function T(e, t, n, r, i, s, c) {
        var l, u, p;
        for (l = new Array(16),
        u = new Array(16); ; ) {
            for (p = 0; p < 16; ++p)
                u[p] = 0;
            break
        }
        for (; ; ) {
            for (p = 0; p < 8; p++)
                l[p] = e[p];
            break
        }
        for (; ; ) {
            for (p = 0; p < 8; p++)
                l[p + 8] = 4294967295 & c[p];
            break
        }
        for (l[12] ^= r,
        s && (l[14] ^= 4294967295),
        p = 0; p < i; p++)
            u[p % 16] ^= t[n + p];
        for (; ; ) {
            for (p = 0; p < a; p++) {
                for (O(l, 0, 4, 8, 12, u[o[p][0]], u[o[p][1]]),
                O(l, 1, 5, 9, 13, u[o[p][2]], u[o[p][3]]),
                O(l, 2, 6, 10, 14, u[o[p][4]], u[o[p][5]]),
                O(l, 3, 7, 11, 15, u[o[p][6]], u[o[p][7]]),
                O(l, 0, 5, 10, 15, u[o[p][8]], u[o[p][9]]),
                O(l, 1, 6, 11, 12, u[o[p][10]], u[o[p][11]]); ; ) {
                    O(l, 2, 7, 8, 13, u[o[p][12]], u[o[p][13]]);
                    break
                }
                O(l, 3, 4, 9, 14, u[o[p][14]], u[o[p][15]])
            }
            break
        }
        for (; ; ) {
            for (p = 0; p < 8; p++)
                e[p] ^= l[p] ^ l[p + 8];
            break
        }
        for (; ; )
            return e
    }
    function A(e) {
        return e = unescape(encodeURIComponent(e)),
        new Int8Array(e.split("").map((function(e) {
            return e.charCodeAt(0) || 0
        }
        )))
    }
    function R(e, t) {
        for (var n = ""; ; ) {
            for (var r = 0; r < t; r++)
                n += e;
            break
        }
        for (; ; )
            return n
    }
    function k(e, t) {
        for (var n, r = 0; ; ) {
            n = new Int8Array(e.length);
            break
        }
        for (; r < e.length; )
            for (var o = 0; o < t.length; o++)
                n[r] = e[r] ^ 255 & t[o],
                r++;
        return n
    }
    function P(e) {
        var t;
        return t = parseInt(e, 16),
        (e = Math.pow(2, e.length / 2 * 8)) / 2 - 1 < t && (t -= e),
        t
    }
    function $(e) {
        for (var t = []; ; ) {
            for (var n = 0; n < e.length; n += 2)
                t.push(P(e.substr(n, 2)));
            break
        }
        return t
    }
    function C(e, t) {
        var n;
        for (t = t || 4,
        n = []; ; ) {
            if (4 < t && 4294967295 < e)
                for (var r = e.toString(2), o = parseInt(r.substr(0, r.length - 16), 2), i = 0; i <= t - 1; i++)
                    n[i] = 0 === i || 1 === i ? parseInt(r.substr(r.length - 8 * (i + 1), 8), 2) : o >>> 8 * (i - 2) & 255;
            else
                for (i = 0; i <= t - 1; i++)
                    n[i] = e >>> 8 * i & 255;
            break
        }
        return n
    }
    function I(e, t, n) {
        var r = ""
          , o = [];
        for (o = (t ? function(e, t) {
            var n;
            n = [];
            for (var r = (t = t || 4) - 1; 0 <= r; r--)
                n[t - 1 - r] = e >>> 8 * r & 255;
            return n
        }
        : C)(e, n); ; ) {
            for (var i = 0; i < o.length; i++)
                r += 0 === o[i] ? "00" : (o[i] < 16 ? "0" : "") + o[i].toString(16);
            break
        }
        return r
    }
    function N(e) {
        for (var t, n = "", r = 0; r < e.length; r++) {
            for (; ; ) {
                t = 255 & e[r] ? ((255 & e[r]) < 16 ? "0" : "") + (255 & e[r]).toString(16) : "00";
                break
            }
            for (; ; ) {
                n += t;
                break
            }
        }
        for (; ; )
            return n
    }
    function L() {
        return "e0000000000000"
    }
    function x(e) {
        return function(e) {
            var t;
            for (t = "",
            e.forEach((function(e) {
                var n, r;
                for (r = 8 - (n = (e >>> 0).toString(16)).length; ; ) {
                    t += 0 < r ? R("0", r) + n : n;
                    break
                }
            }
            )); ; )
                return t
        }(function(e) {
            var t, n, r, o;
            for (t = 0,
            n = e.length,
            r = 0,
            (o = i.slice())[0] ^= 16842784; 64 < n; )
                n -= 64,
                T(o, e, r, t += 64, 64, !1, i),
                r += 64;
            for (t += n; ; )
                return T(o, e, r, t, n, !0, i)
        }(function(e) {
            for (var t, n = A(e), r = (e = n.length % 4 == 0 ? 0 : 4 - n.length % 4,
            new Int8Array(n.length + e)), o = 0; o < n.length; ++o)
                r[o] = n[o];
            for (t = new Array(r.length / 4); ; ) {
                for (o = 0; o < r.length; o += 4)
                    t[o / 4] = new Int32Array(r.slice(o, o + 4).buffer)[0];
                break
            }
            return t
        }(e)))
    }
    function M(e) {
        return A(x(e))
    }
    function D(e) {
        for (; ; ) {
            c = new Int32Array(b.slice(12, 16).buffer)[0],
            l = new Int32Array(b.slice(8, 12).buffer)[0],
            u = new Int32Array(b.slice(4, 8).buffer)[0],
            p = new Int32Array(b.slice(0, 4).buffer)[0],
            d = new Int32Array(b.slice(16, 20).buffer)[0],
            f = new Int32Array(b.slice(20, 24).buffer)[0],
            h = new Int32Array(b.slice(24, 28).buffer)[0],
            m = new Int32Array(b.slice(28, 32).buffer)[0],
            g = new Int32Array(b.slice(44, 48).buffer)[0],
            v = new Int32Array(b.slice(40, 44).buffer)[0],
            y = new Int32Array(b.slice(36, 40).buffer)[0],
            _ = new Int32Array(b.slice(32, 36).buffer)[0];
            break
        }
        !function(e) {
            var t, n, r;
            for (s = e,
            n = e.length,
            e = (e = s).split("").map((function(e) {
                return e.codePointAt(0) || 0
            }
            )),
            r = new Int8Array(e).slice(0, n); ; ) {
                for (t = 0; t < 4; t++)
                    c = (c <<= 8) | r[t + 4],
                    l = (l <<= 8) | r[t + 4],
                    u = (u <<= 8) | r[t + 4];
                break
            }
            for (0 == c && (c = 324508639); ; ) {
                0 == l && (l = 610839776);
                break
            }
            0 == u && (u = 4256789809)
        }("Vuz4fCHxn1CO");
        for (var t = new Int8Array(e.length), n = 0; n < e.length; n++)
            t[n] = function(e) {
                var t, n, r, o;
                for (t = 0; ; ) {
                    n = 1 & l;
                    break
                }
                r = 1 & u;
                for (var i = 0; i < 8; i++) {
                    if (1 & c)
                        c = c ^ p >> 1 & 4294967295 | v,
                        1 & l ? (l = l ^ d >> 1 & 4294967295 | y,
                        n = 1) : (l = l >> 1 & 4294967295 & m,
                        n = 0);
                    else
                        for (c = c >> 1 & 4294967295 & h; ; ) {
                            if (1 & u)
                                u = u ^ f >> 1 & 4294967295 | _,
                                r = 1;
                            else {
                                for (; ; ) {
                                    u = u >> 1 & 4294967295 & g;
                                    break
                                }
                                r = 0
                            }
                            break
                        }
                    for (o = t << 1 & 4294967295 | n ^ r; ; ) {
                        t = 127 < o ? o - 256 : o < -128 ? o + 256 : o;
                        break
                    }
                }
                return e ^= t += 3
            }(e[n]);
        return t
    }
    function U(e) {
        var t, r, o, i;
        for ((!e || "object" !== n(e)) && console.error("Type Error: data must be a object"),
        e.url && e.query && e.form && e.requestBody || console.error("data must have url、query、form、requestBody"); ; ) {
            e.query.caver || console.error("query.caver must exist!");
            break
        }
        for (o = r = e.url,
        (i = new RegExp(/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/)).test(r) && (r = (i = r.split("//"))[1].indexOf("/"),
        o = i[1].substring(r)),
        t = o = -1 != o.indexOf("?") ? o.split("?")[0] : o,
        r = function(e) {
            return Object.keys(e).reduce((function(t, r) {
                var o;
                return ~r.indexOf(E) || ("object" !== n(e[r]) || e[r]instanceof Array ? (o = r + "=" + e[r],
                t.push(o)) : t.push(o = r + "=[object Object]")),
                t
            }
            ), [])
        }(Object.assign({}, e.query, e.form)),
        i = (document && document.cookie.split(";") || []).map((function(e) {
            return [(e = e.split("="))[0].trim(), e.slice(1).join("=").trim()]
        }
        )).filter((function(e) {
            return ~w.indexOf(e[0]) && !!e[1]
        }
        )).map((function(e) {
            return e[0] + "=" + e[1]
        }
        ), []),
        t += r.concat(i).sort((function(e, t) {
            for (; ; ) {
                if (e === t)
                    return 0;
                break
            }
            for (; ; )
                return e < t ? -1 : 1
        }
        )).join(""); ; ) {
            Object.keys(e.requestBody).length && (t += JSON.stringify(e.requestBody));
            break
        }
        return t
    }
    function F(e, t) {
        var n, r;
        return n = e.toString(2),
        e = t.toString(2),
        n = (R("0", (t = Math.max(n.length, e.length)) - n.length) + n).split(""),
        r = (R("0", t - e.length) + e).split(""),
        t = n.map((function(e, t) {
            return "0" === e && "0" === r[t] || !("0" === e && "1" === r[t] || "1" === e && "0" === r[t]) ? "0" : "1"
        }
        )).join(""),
        parseInt(t, 2)
    }
    for (r = function() {}
    ,
    o = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3], [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4], [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8], [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13], [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9], [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11], [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10], [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5], [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]],
    i = [2837534710, 2845986804, 2436420605, 706843635, 719254516, 2557931286, 2596197199, 2432949778]; ; ) {
        for (var j = 0; j < 8; ++j)
            i[j] &= 4294967295;
        break
    }
    for (a = 10,
    d = 0,
    m = h = f = p = u = l = c = 0; ; ) {
        g = 0;
        break
    }
    for (v = 0,
    _ = y = 0,
    b = new Int8Array([98, 0, 0, 128, 49, 117, 185, 253, 224, 172, 104, 36, 223, 155, 87, 19, 32, 0, 0, 64, 2, 0, 0, 16, 255, 255, 255, 127, 255, 255, 255, 63, 0, 0, 0, 240, 0, 0, 0, 192, 0, 0, 0, 128, 255, 255, 255, 15]),
    E = "__NS",
    w = [],
    r.prototype.register = function() {
        Object.defineProperties(Object, {
            jmpOnw_b2sa: {
                writable: !0,
                configurable: !0,
                value: M
            },
            jmpOnw_b2has: {
                writable: !0,
                configurable: !0,
                value: x
            },
            jmpOnw_cts: {
                writable: !0,
                configurable: !0,
                value: D
            },
            jmpOnw_xcb: {
                writable: !0,
                configurable: !0,
                value: k
            },
            jmpOnw_h2b: {
                writable: !0,
                configurable: !0,
                value: $
            },
            jmpOnw_b2h: {
                writable: !0,
                configurable: !0,
                value: N
            },
            jmpOnw_i2h: {
                writable: !0,
                configurable: !0,
                value: I
            },
            jmpOnw_bxor: {
                writable: !0,
                configurable: !0,
                value: F
            },
            jmpOnw_i2b1: {
                writable: !0,
                configurable: !0,
                value: C
            },
            jmpOnw_s2ua: {
                writable: !0,
                configurable: !0,
                value: A
            },
            jmpOnw_geh: {
                writable: !0,
                configurable: !0,
                value: L
            },
            jmpOnw_ms: {
                writable: !0,
                configurable: !0,
                value: U
            }
        })
    }
    ; ; ) {
        e.exports = r;
        break
    }
}
, function(e, t) {
    function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    var r, o = {
        prod: "log-sdk.ksapisrv.com",
        oversea: "logsdk.kwai-pro.com"
    }, i = {
        prod: "914e7528de",
        oversea: "602a26d3bn"
    };
    function a(e) {
        try {
            var t = {
                data: [{
                    key: "event",
                    value: e.duration ? {
                        duration: e.duration
                    } : {},
                    dimension: {
                        event_client_timestamp: Date.now(),
                        collect_version: "1.2.9",
                        collect_name: "RadarSeedCollect",
                        name: e.name || "",
                        message: "object" === n(e.value) ? JSON.stringify(e.value) : e.value,
                        category: e.projectInfo.appKey || e.projectInfo.appkey || "",
                        sample_rate: 1,
                        other_session_increase_id: 2
                    },
                    h5_extra_attr: e.log ? JSON.stringify(e.log) : "",
                    refer_url_package: {
                        page: location && location.href || ""
                    },
                    url_package: {
                        page: ""
                    },
                    project_id: e.projectInfo.radarId || i[e.projectInfo.oversea ? "oversea" : "prod"],
                    radar_session_id: ""
                }]
            }
              , r = {
                common: {
                    identity_package: {
                        device_id: e.projectInfo.did || "",
                        global_id: "",
                        user_id: e.projectInfo.uid || ""
                    },
                    app_package: {
                        language: "zh-CN",
                        version_name: ""
                    },
                    device_package: {
                        ua: ""
                    },
                    service_name: "radarSDK",
                    network_package: {
                        type: 3
                    },
                    h5_extra_attr: e.log ? JSON.stringify(e.log) : ""
                },
                logs: [{
                    client_timestamp: Date.now(),
                    stat_package: {
                        custom_stat_event: {
                            key: "radar_log",
                            value: JSON.stringify(t)
                        }
                    }
                }]
            }
              , a = "https://" + o[e.projectInfo.oversea ? "oversea" : "prod"] + "/rest/wd/common/log/collect/radar";
            (null == e.projectInfo.sampling || Math.random() < +e.projectInfo.sampling) && navigator.sendBeacon(a, JSON.stringify(r))
        } catch (s) {
            console.log("log error", s)
        }
    }
    (r = function() {}
    ).prototype.register = function() {
        Object.defineProperties(Object, {
            jmpOnw_send: {
                writable: !0,
                configurable: !0,
                value: a
            }
        })
    }
    ,
    e.exports = r
}
, function(e, t, n) {
    n.r(t),
    function(e) {
        function n(e) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            }
            : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }
            )(e)
        }
        function r(e, t) {
            for (var r = 0; r < t.length; r++) {
                var o = t[r];
                o.enumerable = o.enumerable || !1,
                o.configurable = !0,
                "value"in o && (o.writable = !0),
                Object.defineProperty(e, (i = function(e) {
                    if ("object" != n(e) || null === e)
                        return e;
                    var t = e[Symbol.toPrimitive];
                    if (void 0 === t)
                        return String(e);
                    if ("object" != n(e = t.call(e, "string")))
                        return e;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }(i = o.key),
                "symbol" == n(i) ? i : String(i)), o)
            }
            var i
        }
        function o(e, t) {
            if (e !== t)
                throw new TypeError("Cannot instantiate an arrow function")
        }
        function i(e) {
            return function(e) {
                if (Array.isArray(e))
                    return a(e)
            }(e) || function(e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                    return Array.from(e)
            }(e) || function(e, t) {
                var n;
                if (e)
                    return "string" == typeof e ? a(e, t) : "Map" === (n = "Object" === (n = Object.prototype.toString.call(e).slice(8, -1)) && e.constructor ? e.constructor.name : n) || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0
            }(e) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }
        function a(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, r = new Array(t); n < t; n++)
                r[n] = e[n];
            return r
        }
        var s = function(e) {
            var t = this;
            return Array.from(e).map(function(e) {
                return o(this, t),
                e.codePointAt(0) || 0
            }
            .bind(this))
        }
          , c = function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 4;
            if (4 <= t && e >= Math.pow(2, 32))
                return [255, 255, 255, 255];
            for (var n = [], r = 0; r <= t - 1; r++)
                n[r] = e >>> 8 * r & 255;
            return n
        }
          , l = "SECS";
        function u(e, t) {
            var n = 0
              , r = new Array(16)
              , o = new Array(16)
              , i = e
              , a = t;
            function s(e, t) {
                return e << t & 4294967295 | e >>> 32 - t
            }
            function c(e, t, n, r, o) {
                e[t] = e[t] + e[n] & 4294967295,
                e[o] ^= e[t],
                e[o] = s(e[o], 16),
                e[r] = e[r] + e[o] & 4294967295,
                e[n] ^= e[r],
                e[n] = s(e[n], 12),
                e[t] = e[t] + e[n] & 4294967295,
                e[o] ^= e[t],
                e[o] = s(e[o], 8),
                e[r] = e[r] + e[o] & 4294967295,
                e[n] ^= e[r],
                e[n] = s(e[n], 7)
            }
            function l() {
                for (var e = new Array(r.length), t = 0; t < r.length; ++t)
                    e[t] = r[t];
                for (t = 0; t < 20; t += 2)
                    c(e, 0, 4, 8, 12),
                    c(e, 1, 5, 9, 13),
                    c(e, 2, 6, 10, 14),
                    c(e, 3, 7, 11, 15),
                    c(e, 0, 5, 10, 15),
                    c(e, 1, 6, 11, 12),
                    c(e, 2, 7, 8, 13),
                    c(e, 3, 4, 9, 14);
                for (t = 0; t < 16; ++t)
                    o[t] = e[t] + r[t] & 4294967295
            }
            u.prototype.chachaEncrypt = function(e) {
                r[n = 0] = 394484062,
                r[1] = 2378328696,
                r[2] = 630790222,
                r[3] = 1922531795;
                for (var t = 0; t < 8; t++)
                    r[t + 4] = i[t];
                r[12] = 1,
                r[13] = a[0],
                r[14] = a[1],
                r[15] = a[2],
                l();
                for (var s = new Uint8Array(e.length), c = 0; c < e.length; c++) {
                    var u = e[c] ^ (u = void 0,
                    64 === n && (++r[12],
                    l(),
                    n = 0),
                    u = o[n >> 2] >> ((3 & n) << 3) & 255,
                    ++n,
                    127 < u ? u - 256 : u < -128 ? 256 + u : u);
                    s[c] = u
                }
                return s
            }
            ,
            u.prototype.chachaDecrypt = u.prototype.chachaEncrypt
        }
        for (var p = [], d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", f = 0; f < 64; ++f)
            p[f] = d[f],
            d.charCodeAt(f);
        function h(e, t, n) {
            for (var r, o = [], i = t; i < n; i += 3)
                r = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (255 & e[i + 2]),
                o.push(p[r >> 18 & 63] + p[r >> 12 & 63] + p[r >> 6 & 63] + p[63 & r]);
            return o.join("")
        }
        m = y,
        g = [{
            key: "getInstance",
            value: function() {
                return y.instance || (y.instance = new y),
                this.instance
            }
        }],
        (v = [{
            key: "init",
            value: function() {
                try {
                    var e, t, n;
                    (e = this.infoCache).push.apply(e, [68, 0].concat(i(c(null == (t = document) || null == (n = t.scripts) ? void 0 : n.length, 4))))
                } catch (r) {}
            }
        }, {
            key: "collectDeviceInfo",
            value: function() {
                var t = this
                  , n = window || e;
                try {
                    var r, a, d, f = this.count;
                    this.count += 1,
                    m = [45, 61, 0, 2].concat(i(this.infoCache), [112, 0].concat(i(c(f || 0, 4))), [114, 1].concat(i(c((null == (y = n[l]) || null == (r = y.s) ? void 0 : r.length) || 0, 2)), i(s((null == (a = n[l]) ? void 0 : a.s) || ""))), [115, 0].concat(i(c((null == (d = n[l]) ? void 0 : d.c) || 0, 4))))
                } catch (_) {
                    var m = [45, 61, 0, 2].concat([117, 1].concat(i(c(100, 2)), i(s((null == _ || null == (f = _.stack) ? void 0 : f.substr(0, 100)) || ""))))
                }
                n[l] = {
                    s: "",
                    c: 0
                };
                for (var g = [], v = 0; v < m.length; v++)
                    g.push(35 ^ m[v]);
                var y = function(e) {
                    for (var t, n = e.length, r = n % 3, o = [], i = 0, a = n - r; i < a; i += 16383)
                        o.push(h(e, i, a < i + 16383 ? a : i + 16383));
                    return 1 == r ? (t = e[n - 1],
                    o.push(p[t >> 2] + p[t << 4 & 63] + "==")) : 2 == r && (t = (e[n - 2] << 8) + e[n - 1],
                    o.push(p[t >> 10] + p[t >> 4 & 63] + p[t << 2 & 63] + "=")),
                    o.join("")
                }(new u([4183807412, 394484062, 1106561997, 2378328696, 630790222, 2546784104, 2891127470, 1922531795],[2215853858, 1643070585, 1849059804]).chachaEncrypt(g));
                return function(e) {
                    var n = this
                      , r = (o(this, t),
                    {
                        "+": "-",
                        "/": "_",
                        "=": "."
                    });
                    return e.replace(/[+/=]/g, function(e) {
                        return o(this, n),
                        r[e]
                    }
                    .bind(this))
                }
                .bind(this)(y)
            }
        }]) && r(m.prototype, v),
        g && r(m, g),
        Object.defineProperty(m, "prototype", {
            writable: !1
        });
        var m, g, v = y;
        function y() {
            if (this instanceof y)
                return this.count = 100,
                this.infoCache = [],
                y.instance || (y.instance = this).init(),
                y.instance;
            throw new TypeError("Cannot call a class as a function")
        }
        v.instance = null,
        t.default = v
    }
    .call(this, n(1))
}
]);
const sig4Report = function() {
    const e = [];
    return function(t, n) {
        for (t && e.push({
            name: t,
            extra_info: n
        }); radar && e.length; )
            radar.event(e.shift())
    }
}();
addAdapter(sig4Adapter(Jose, {
    list: ["/rest/v/profile/get", "/rest/v/profile/user/v2"],
    hook: sig4Report
})),
addResponseInterceptors((e => {
    let t;
    return t = "response"in e ? e.response : e,
    50 === t.data.result && sig4Report("sig4-verification-fail", {
        path: t.config.url,
        method: t.config.method,
        params: t.config.params,
        data: t.config.data
    }),
    e
}
));
const PREFETCH$1 = "__PREFETCH__";
function formatPrefetchResult() {
    try {
        const e = window[PREFETCH$1]
          , t = Object.values(e).map(( ({params: e, value: t}) => {
            let n = e.url;
            try {
                n = new URL(e.url,location.href).toString()
            } catch (e2) {
                console.warn("format prefetch api error", String(e2))
            }
            return {
                path: n,
                method: e.method,
                value: t
            }
        }
        ));
        return t
    } catch (e) {
        return []
    }
}
async function checkPerf(e, t, n) {
    const r = t.findIndex((e => e.path === n.name));
    if (r >= 0) {
        const [o] = t.splice(r, 1)
          , i = await o.value.catch((e => e))
          , a = performance.timing.navigationStart
          , s = {
            api: n.name,
            custom_failed: i.status < 200 || i.status >= 300,
            status: i.status,
            sample_rate: 1,
            res_type: n.initiatorType,
            method: o.method,
            response_msg: "prefetch",
            content_type: "application/json"
        }
          , c = {
            duration: n.responseEnd - n.fetchStart,
            total: n.responseEnd - n.fetchStart,
            dns: n.domainLookupEnd - n.domainLookupStart,
            tcp: n.connectEnd - n.connectStart,
            ssl: n.connectEnd - n.secureConnectionStart,
            ttfb: n.responseStart - n.requestStart,
            trans: n.responseEnd - n.responseStart,
            fb: n.responseStart - n.fetchStart,
            size: n.decodedBodySize,
            encoded_body_size: n.encodedBodySize,
            decoded_body_size: n.decodedBodySize,
            start_time: n.startTime,
            fetch_start: n.fetchStart,
            navigation_start: n.startTime + a,
            redirect_start: n.redirectStart + a,
            redirect_end: n.redirectEnd + a,
            dns_start: n.domainLookupStart + a,
            dns_end: n.domainLookupEnd + a,
            connect_start: n.connectStart + a,
            connect_end: n.connectEnd + a,
            ssl_start: n.secureConnectionStart + a,
            request_start: n.requestStart + a,
            response_start: n.responseStart + a,
            response_end: n.responseEnd + a
        };
        e.collect("api", s, c)
    }
}
function filterPerf(e) {
    return ["xmlhttprequest", "fetch"].includes(e.initiatorType)
}
function watchPerformance(e, t) {
    const n = checkPerf.bind(null, t, e);
    if (performance.getEntriesByType("resource").filter(filterPerf).map(n),
    e.length)
        try {
            const t = new PerformanceObserver((r => {
                r.getEntries().filter(filterPerf).forEach(n),
                e.length || t.disconnect()
            }
            ));
            t.observe({
                entryTypes: ["resource"]
            })
        } catch (r) {
            console.warn("The current browser does not support PerformanceObserver"),
            console.warn(r)
        }
}
function collectPerf(e) {
    if (!e || !e.collect)
        return void console.error("[prefetch] 错误的radar core, 请检查参数是否正确");
    watchPerformance(formatPrefetchResult(), e)
}
const PREFETCH = "__PREFETCH__";
function generateHash(e) {
    return Object.keys(e).sort().reduce((function(t, n) {
        const r = e[n];
        if (void 0 === r)
            return t;
        const o = "".concat(n, ":").concat("object" == typeof r ? generateHash(r) : r);
        for (let e = 0; e < o.length; e++)
            t = (t << 5) - t + o.charCodeAt(e);
        return t
    }
    ), 0).toString(36)
}
function formatQuery(e, t={}) {
    const n = new URL(e,location.href)
      , r = {
        ...n.search.slice(1).split("&").filter(Boolean).reduce((function(e, t) {
            const n = t.split("=");
            return e[decodeURIComponent(n[0])] = decodeURIComponent(n[1] || ""),
            e
        }
        ), {}),
        ...t
    }
      , o = Object.keys(r).sort().map((function(e) {
        return "".concat(encodeURIComponent(e), "=").concat(encodeURIComponent(r[e]))
    }
    )).join("&");
    return n.search = o ? "?".concat(o) : "",
    n.toString().split("".concat(location.protocol, "//").concat(location.host)).pop()
}
const MustCheckProp = ["url", "method", "body"];
function getGlobalCache() {
    const e = window[PREFETCH];
    return e && Object.values(e).reduce(( (e, t) => e + t.count), 0) ? e : null
}
function getCache(e, t=[], n) {
    var r, o, i, a;
    try {
        const s = getGlobalCache();
        if (!s)
            return null;
        const {url: c, query: l, ...u} = e
          , p = {
            url: formatQuery(c, l),
            ...u
        }
          , d = [...MustCheckProp, ...t].reduce(( (e, t) => (e[t] = p[t],
        e)), {});
        null == (r = null == n ? void 0 : n.log) || r.call(n, "[prefetch]hash生成参数", d);
        const f = generateHash(d);
        null == (o = null == n ? void 0 : n.log) || o.call(n, "[prefetch]hash值", f);
        const h = s[f];
        return null == (i = null == n ? void 0 : n.log) || i.call(n, "[prefetch]检查缓存, cache:", h),
        h && h.count > 0 ? (h.count -= 1,
        null == (a = null == n ? void 0 : n.log) || a.call(n, "[prefetch]命中缓存, 剩余使用次数:", h.count),
        h.value) : null
    } catch (s) {
        return null
    }
}
function removeAxiosDefaultHeader(e) {
    const t = {
        ...e
    };
    if (t && (delete t.Accept,
    (void 0 === t["Content-Type"] || t["Content-Type"] && t["Content-Type"].includes("application/json")) && delete t["Content-Type"]),
    t && Object.keys(t).length)
        return t
}
function restoreBody(e) {
    const {headers: t, data: n} = e;
    try {
        const e = t.getContentType() || t["Content-Type"] || "";
        return e.indexOf("application/json") > -1 && n && "string" == typeof n ? JSON.parse(n) : n
    } catch (r) {
        return n
    }
}
function RequestAdapter(e={}, t) {
    const n = Array.isArray(e) ? e : e.checkProps;
    let r = [];
    return "callback"in e && e.callback && (r = (Array.isArray(e.callback) ? e.callback : [e.callback]).filter((e => "function" == typeof e))),
    function(e, o) {
        if (getGlobalCache()) {
            const {url: o="", headers: i, method: a} = e
              , s = restoreBody(e)
              , c = getCache({
                url: o,
                header: removeAxiosDefaultHeader(i),
                method: (null == a ? void 0 : a.toLocaleLowerCase()) || "get",
                body: s,
                query: e.params || {}
            }, n || [], t);
            if (r.forEach((t => {
                try {
                    t(!!c, e)
                } catch (n) {}
            }
            )),
            c)
                return c
        }
        return o(e)
    }
}
function PrefetchAdapter(e={}, t) {
    let {checkProps: n} = e;
    Array.isArray(e) && (n = e);
    const r = {
        checkProps: n,
        callback: (Array.isArray(e.callback) ? e.callback : [e.callback]).filter((e => "function" == typeof e))
    }
      , o = [];
    return r.callback.push((function(e, t) {
        for (e && o.push({
            name: "HIT_PREFETCH",
            extra_info: {
                url: t.url
            }
        }); radar && o.length; )
            radar.event(o.shift())
    }
    )),
    RequestAdapter(r, t)
}
var extendStatics = function(e, t) {
    return (extendStatics = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    )(e, t)
};
function __extends(e, t) {
    if ("function" != typeof t && null !== t)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    function n() {
        this.constructor = e
    }
    extendStatics(e, t),
    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
    new n)
}
function __awaiter(e, t, n, r) {
    return new (n || (n = Promise))((function(o, i) {
        function a(e) {
            try {
                c(r.next(e))
            } catch (e2) {
                i(e2)
            }
        }
        function s(e) {
            try {
                c(r.throw(e))
            } catch (e2) {
                i(e2)
            }
        }
        function c(e) {
            var t;
            e.done ? o(e.value) : (t = e.value,
            t instanceof n ? t : new n((function(e) {
                e(t)
            }
            ))).then(a, s)
        }
        c((r = r.apply(e, t || [])).next())
    }
    ))
}
function __generator(e, t) {
    var n, r, o, i = {
        label: 0,
        sent: function() {
            if (1 & o[0])
                throw o[1];
            return o[1]
        },
        trys: [],
        ops: []
    }, a = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
    return a.next = s(0),
    a.throw = s(1),
    a.return = s(2),
    "function" == typeof Symbol && (a[Symbol.iterator] = function() {
        return this
    }
    ),
    a;
    function s(s) {
        return function(c) {
            return function(s) {
                if (n)
                    throw new TypeError("Generator is already executing.");
                for (; a && (a = 0,
                s[0] && (i = 0)),
                i; )
                    try {
                        if (n = 1,
                        r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r),
                        0) : r.next) && !(o = o.call(r, s[1])).done)
                            return o;
                        switch (r = 0,
                        o && (s = [2 & s[0], o.value]),
                        s[0]) {
                        case 0:
                        case 1:
                            o = s;
                            break;
                        case 4:
                            return i.label++,
                            {
                                value: s[1],
                                done: !1
                            };
                        case 5:
                            i.label++,
                            r = s[1],
                            s = [0];
                            continue;
                        case 7:
                            s = i.ops.pop(),
                            i.trys.pop();
                            continue;
                        default:
                            if (!(o = i.trys,
                            (o = o.length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                i = 0;
                                continue
                            }
                            if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {
                                i.label = s[1];
                                break
                            }
                            if (6 === s[0] && i.label < o[1]) {
                                i.label = o[1],
                                o = s;
                                break
                            }
                            if (o && i.label < o[2]) {
                                i.label = o[2],
                                i.ops.push(s);
                                break
                            }
                            o[2] && i.ops.pop(),
                            i.trys.pop();
                            continue
                        }
                        s = t.call(e, i)
                    } catch (e2) {
                        s = [6, e2],
                        r = 0
                    } finally {
                        n = o = 0
                    }
                if (5 & s[0])
                    throw s[1];
                return {
                    value: s[0] ? s[1] : void 0,
                    done: !0
                }
            }([s, c])
        }
    }
}
function __values(e) {
    var t = "function" == typeof Symbol && Symbol.iterator
      , n = t && e[t]
      , r = 0;
    if (n)
        return n.call(e);
    if (e && "number" == typeof e.length)
        return {
            next: function() {
                return e && r >= e.length && (e = void 0),
                {
                    value: e && e[r++],
                    done: !e
                }
            }
        };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function __read(e, t) {
    var n = "function" == typeof Symbol && e[Symbol.iterator];
    if (!n)
        return e;
    var r, o, i = n.call(e), a = [];
    try {
        for (; (void 0 === t || t-- > 0) && !(r = i.next()).done; )
            a.push(r.value)
    } catch (s) {
        o = {
            error: s
        }
    } finally {
        try {
            r && !r.done && (n = i.return) && n.call(i)
        } finally {
            if (o)
                throw o.error
        }
    }
    return a
}
function __spreadArray(e, t, n) {
    if (n || 2 === arguments.length)
        for (var r, o = 0, i = t.length; o < i; o++)
            !r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)),
            r[o] = t[o]);
    return e.concat(r || Array.prototype.slice.call(t))
}
function __await(e) {
    return this instanceof __await ? (this.v = e,
    this) : new __await(e)
}
function __asyncGenerator(e, t, n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var r, o = n.apply(e, t || []), i = [];
    return r = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype),
    a("next"),
    a("throw"),
    a("return", (function(e) {
        return function(t) {
            return Promise.resolve(t).then(e, l)
        }
    }
    )),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r;
    function a(e, t) {
        o[e] && (r[e] = function(t) {
            return new Promise((function(n, r) {
                i.push([e, t, n, r]) > 1 || s(e, t)
            }
            ))
        }
        ,
        t && (r[e] = t(r[e])))
    }
    function s(e, t) {
        try {
            (n = o[e](t)).value instanceof __await ? Promise.resolve(n.value.v).then(c, l) : u(i[0][2], n)
        } catch (e2) {
            u(i[0][3], e2)
        }
        var n
    }
    function c(e) {
        s("next", e)
    }
    function l(e) {
        s("throw", e)
    }
    function u(e, t) {
        e(t),
        i.shift(),
        i.length && s(i[0][0], i[0][1])
    }
}
function __asyncValues(e) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var t, n = e[Symbol.asyncIterator];
    return n ? n.call(e) : (e = "function" == typeof __values ? __values(e) : e[Symbol.iterator](),
    t = {},
    r("next"),
    r("throw"),
    r("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function r(n) {
        t[n] = e[n] && function(t) {
            return new Promise((function(r, o) {
                (function(e, t, n, r) {
                    Promise.resolve(r).then((function(t) {
                        e({
                            value: t,
                            done: n
                        })
                    }
                    ), t)
                }
                )(r, o, (t = e[n](t)).done, t.value)
            }
            ))
        }
    }
}
function isFunction(e) {
    return "function" == typeof e
}
function createErrorClass(e) {
    var t = e((function(e) {
        Error.call(e),
        e.stack = (new Error).stack
    }
    ));
    return t.prototype = Object.create(Error.prototype),
    t.prototype.constructor = t,
    t
}
"function" == typeof SuppressedError && SuppressedError;
var UnsubscriptionError = createErrorClass((function(e) {
    return function(t) {
        e(this),
        this.message = t ? t.length + " errors occurred during unsubscription:\n" + t.map((function(e, t) {
            return t + 1 + ") " + e.toString()
        }
        )).join("\n  ") : "",
        this.name = "UnsubscriptionError",
        this.errors = t
    }
}
));
function arrRemove(e, t) {
    if (e) {
        var n = e.indexOf(t);
        0 <= n && e.splice(n, 1)
    }
}
var Subscription = function() {
    function e(e) {
        this.initialTeardown = e,
        this.closed = !1,
        this._parentage = null,
        this._finalizers = null
    }
    var t;
    return e.prototype.unsubscribe = function() {
        var e, t, n, r, o;
        if (!this.closed) {
            this.closed = !0;
            var i = this._parentage;
            if (i)
                if (this._parentage = null,
                Array.isArray(i))
                    try {
                        for (var a = __values(i), s = a.next(); !s.done; s = a.next()) {
                            s.value.remove(this)
                        }
                    } catch (f) {
                        e = {
                            error: f
                        }
                    } finally {
                        try {
                            s && !s.done && (t = a.return) && t.call(a)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
                else
                    i.remove(this);
            var c = this.initialTeardown;
            if (isFunction(c))
                try {
                    c()
                } catch (e2) {
                    o = e2 instanceof UnsubscriptionError ? e2.errors : [e2]
                }
            var l = this._finalizers;
            if (l) {
                this._finalizers = null;
                try {
                    for (var u = __values(l), p = u.next(); !p.done; p = u.next()) {
                        var d = p.value;
                        try {
                            execFinalizer(d)
                        } catch (h) {
                            o = null != o ? o : [],
                            h instanceof UnsubscriptionError ? o = __spreadArray(__spreadArray([], __read(o)), __read(h.errors)) : o.push(h)
                        }
                    }
                } catch (m) {
                    n = {
                        error: m
                    }
                } finally {
                    try {
                        p && !p.done && (r = u.return) && r.call(u)
                    } finally {
                        if (n)
                            throw n.error
                    }
                }
            }
            if (o)
                throw new UnsubscriptionError(o)
        }
    }
    ,
    e.prototype.add = function(t) {
        var n;
        if (t && t !== this)
            if (this.closed)
                execFinalizer(t);
            else {
                if (t instanceof e) {
                    if (t.closed || t._hasParent(this))
                        return;
                    t._addParent(this)
                }
                (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t)
            }
    }
    ,
    e.prototype._hasParent = function(e) {
        var t = this._parentage;
        return t === e || Array.isArray(t) && t.includes(e)
    }
    ,
    e.prototype._addParent = function(e) {
        var t = this._parentage;
        this._parentage = Array.isArray(t) ? (t.push(e),
        t) : t ? [t, e] : e
    }
    ,
    e.prototype._removeParent = function(e) {
        var t = this._parentage;
        t === e ? this._parentage = null : Array.isArray(t) && arrRemove(t, e)
    }
    ,
    e.prototype.remove = function(t) {
        var n = this._finalizers;
        n && arrRemove(n, t),
        t instanceof e && t._removeParent(this)
    }
    ,
    e.EMPTY = ((t = new e).closed = !0,
    t),
    e
}()
  , EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(e) {
    return e instanceof Subscription || e && "closed"in e && isFunction(e.remove) && isFunction(e.add) && isFunction(e.unsubscribe)
}
function execFinalizer(e) {
    isFunction(e) ? e() : e.unsubscribe()
}
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1
}
  , timeoutProvider = {
    setTimeout: function(e, t) {
        for (var n = [], r = 2; r < arguments.length; r++)
            n[r - 2] = arguments[r];
        return setTimeout.apply(void 0, __spreadArray([e, t], __read(n)))
    },
    clearTimeout: function(e) {
        var t = timeoutProvider.delegate;
        return ((null == t ? void 0 : t.clearTimeout) || clearTimeout)(e)
    },
    delegate: void 0
};
function reportUnhandledError(e) {
    timeoutProvider.setTimeout((function() {
        throw e
    }
    ))
}
function noop() {}
function errorContext(e) {
    e()
}
var Subscriber = function(e) {
    function t(t) {
        var n = e.call(this) || this;
        return n.isStopped = !1,
        t ? (n.destination = t,
        isSubscription(t) && t.add(n)) : n.destination = EMPTY_OBSERVER,
        n
    }
    return __extends(t, e),
    t.create = function(e, t, n) {
        return new SafeSubscriber(e,t,n)
    }
    ,
    t.prototype.next = function(e) {
        this.isStopped || this._next(e)
    }
    ,
    t.prototype.error = function(e) {
        this.isStopped || (this.isStopped = !0,
        this._error(e))
    }
    ,
    t.prototype.complete = function() {
        this.isStopped || (this.isStopped = !0,
        this._complete())
    }
    ,
    t.prototype.unsubscribe = function() {
        this.closed || (this.isStopped = !0,
        e.prototype.unsubscribe.call(this),
        this.destination = null)
    }
    ,
    t.prototype._next = function(e) {
        this.destination.next(e)
    }
    ,
    t.prototype._error = function(e) {
        try {
            this.destination.error(e)
        } finally {
            this.unsubscribe()
        }
    }
    ,
    t.prototype._complete = function() {
        try {
            this.destination.complete()
        } finally {
            this.unsubscribe()
        }
    }
    ,
    t
}(Subscription)
  , _bind = Function.prototype.bind;
function bind(e, t) {
    return _bind.call(e, t)
}
var ConsumerObserver = function() {
    function e(e) {
        this.partialObserver = e
    }
    return e.prototype.next = function(e) {
        var t = this.partialObserver;
        if (t.next)
            try {
                t.next(e)
            } catch (n) {
                handleUnhandledError(n)
            }
    }
    ,
    e.prototype.error = function(e) {
        var t = this.partialObserver;
        if (t.error)
            try {
                t.error(e)
            } catch (n) {
                handleUnhandledError(n)
            }
        else
            handleUnhandledError(e)
    }
    ,
    e.prototype.complete = function() {
        var e = this.partialObserver;
        if (e.complete)
            try {
                e.complete()
            } catch (t) {
                handleUnhandledError(t)
            }
    }
    ,
    e
}()
  , SafeSubscriber = function(e) {
    function t(t, n, r) {
        var o, i, a = e.call(this) || this;
        isFunction(t) || !t ? o = {
            next: null != t ? t : void 0,
            error: null != n ? n : void 0,
            complete: null != r ? r : void 0
        } : a && config.useDeprecatedNextContext ? ((i = Object.create(t)).unsubscribe = function() {
            return a.unsubscribe()
        }
        ,
        o = {
            next: t.next && bind(t.next, i),
            error: t.error && bind(t.error, i),
            complete: t.complete && bind(t.complete, i)
        }) : o = t;
        return a.destination = new ConsumerObserver(o),
        a
    }
    return __extends(t, e),
    t
}(Subscriber);
function handleUnhandledError(e) {
    reportUnhandledError(e)
}
function defaultErrorHandler(e) {
    throw e
}
var EMPTY_OBSERVER = {
    closed: !0,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
}
  , observable = "function" == typeof Symbol && Symbol.observable || "@@observable";
function identity(e) {
    return e
}
function pipeFromArray(e) {
    return 0 === e.length ? identity : 1 === e.length ? e[0] : function(t) {
        return e.reduce((function(e, t) {
            return t(e)
        }
        ), t)
    }
}
var Observable = function() {
    function e(e) {
        e && (this._subscribe = e)
    }
    return e.prototype.lift = function(t) {
        var n = new e;
        return n.source = this,
        n.operator = t,
        n
    }
    ,
    e.prototype.subscribe = function(e, t, n) {
        var r = this
          , o = isSubscriber(e) ? e : new SafeSubscriber(e,t,n);
        return errorContext((function() {
            var e = r
              , t = e.operator
              , n = e.source;
            o.add(t ? t.call(o, n) : n ? r._subscribe(o) : r._trySubscribe(o))
        }
        )),
        o
    }
    ,
    e.prototype._trySubscribe = function(e) {
        try {
            return this._subscribe(e)
        } catch (t) {
            e.error(t)
        }
    }
    ,
    e.prototype.forEach = function(e, t) {
        var n = this;
        return new (t = getPromiseCtor(t))((function(t, r) {
            var o = new SafeSubscriber({
                next: function(t) {
                    try {
                        e(t)
                    } catch (n) {
                        r(n),
                        o.unsubscribe()
                    }
                },
                error: r,
                complete: t
            });
            n.subscribe(o)
        }
        ))
    }
    ,
    e.prototype._subscribe = function(e) {
        var t;
        return null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(e)
    }
    ,
    e.prototype[observable] = function() {
        return this
    }
    ,
    e.prototype.pipe = function() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        return pipeFromArray(e)(this)
    }
    ,
    e.prototype.toPromise = function(e) {
        var t = this;
        return new (e = getPromiseCtor(e))((function(e, n) {
            var r;
            t.subscribe((function(e) {
                return r = e
            }
            ), (function(e) {
                return n(e)
            }
            ), (function() {
                return e(r)
            }
            ))
        }
        ))
    }
    ,
    e.create = function(t) {
        return new e(t)
    }
    ,
    e
}();
function getPromiseCtor(e) {
    var t;
    return null !== (t = null != e ? e : config.Promise) && void 0 !== t ? t : Promise
}
function isObserver(e) {
    return e && isFunction(e.next) && isFunction(e.error) && isFunction(e.complete)
}
function isSubscriber(e) {
    return e && e instanceof Subscriber || isObserver(e) && isSubscription(e)
}
function hasLift(e) {
    return isFunction(null == e ? void 0 : e.lift)
}
function operate(e) {
    return function(t) {
        if (hasLift(t))
            return t.lift((function(t) {
                try {
                    return e(t, this)
                } catch (n) {
                    this.error(n)
                }
            }
            ));
        throw new TypeError("Unable to lift unknown Observable type")
    }
}
function createOperatorSubscriber(e, t, n, r, o) {
    return new OperatorSubscriber(e,t,n,r,o)
}
var OperatorSubscriber = function(e) {
    function t(t, n, r, o, i, a) {
        var s = e.call(this, t) || this;
        return s.onFinalize = i,
        s.shouldUnsubscribe = a,
        s._next = n ? function(e) {
            try {
                n(e)
            } catch (r) {
                t.error(r)
            }
        }
        : e.prototype._next,
        s._error = o ? function(e) {
            try {
                o(e)
            } catch (n) {
                t.error(n)
            } finally {
                this.unsubscribe()
            }
        }
        : e.prototype._error,
        s._complete = r ? function() {
            try {
                r()
            } catch (e) {
                t.error(e)
            } finally {
                this.unsubscribe()
            }
        }
        : e.prototype._complete,
        s
    }
    return __extends(t, e),
    t.prototype.unsubscribe = function() {
        var t;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var n = this.closed;
            e.prototype.unsubscribe.call(this),
            !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this))
        }
    }
    ,
    t
}(Subscriber)
  , ObjectUnsubscribedError = createErrorClass((function(e) {
    return function() {
        e(this),
        this.name = "ObjectUnsubscribedError",
        this.message = "object unsubscribed"
    }
}
))
  , Subject = function(e) {
    function t() {
        var t = e.call(this) || this;
        return t.closed = !1,
        t.currentObservers = null,
        t.observers = [],
        t.isStopped = !1,
        t.hasError = !1,
        t.thrownError = null,
        t
    }
    return __extends(t, e),
    t.prototype.lift = function(e) {
        var t = new AnonymousSubject(this,this);
        return t.operator = e,
        t
    }
    ,
    t.prototype._throwIfClosed = function() {
        if (this.closed)
            throw new ObjectUnsubscribedError
    }
    ,
    t.prototype.next = function(e) {
        var t = this;
        errorContext((function() {
            var n, r;
            if (t._throwIfClosed(),
            !t.isStopped) {
                t.currentObservers || (t.currentObservers = Array.from(t.observers));
                try {
                    for (var o = __values(t.currentObservers), i = o.next(); !i.done; i = o.next()) {
                        i.value.next(e)
                    }
                } catch (a) {
                    n = {
                        error: a
                    }
                } finally {
                    try {
                        i && !i.done && (r = o.return) && r.call(o)
                    } finally {
                        if (n)
                            throw n.error
                    }
                }
            }
        }
        ))
    }
    ,
    t.prototype.error = function(e) {
        var t = this;
        errorContext((function() {
            if (t._throwIfClosed(),
            !t.isStopped) {
                t.hasError = t.isStopped = !0,
                t.thrownError = e;
                for (var n = t.observers; n.length; )
                    n.shift().error(e)
            }
        }
        ))
    }
    ,
    t.prototype.complete = function() {
        var e = this;
        errorContext((function() {
            if (e._throwIfClosed(),
            !e.isStopped) {
                e.isStopped = !0;
                for (var t = e.observers; t.length; )
                    t.shift().complete()
            }
        }
        ))
    }
    ,
    t.prototype.unsubscribe = function() {
        this.isStopped = this.closed = !0,
        this.observers = this.currentObservers = null
    }
    ,
    Object.defineProperty(t.prototype, "observed", {
        get: function() {
            var e;
            return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0
        },
        enumerable: !1,
        configurable: !0
    }),
    t.prototype._trySubscribe = function(t) {
        return this._throwIfClosed(),
        e.prototype._trySubscribe.call(this, t)
    }
    ,
    t.prototype._subscribe = function(e) {
        return this._throwIfClosed(),
        this._checkFinalizedStatuses(e),
        this._innerSubscribe(e)
    }
    ,
    t.prototype._innerSubscribe = function(e) {
        var t = this
          , n = this
          , r = n.hasError
          , o = n.isStopped
          , i = n.observers;
        return r || o ? EMPTY_SUBSCRIPTION : (this.currentObservers = null,
        i.push(e),
        new Subscription((function() {
            t.currentObservers = null,
            arrRemove(i, e)
        }
        )))
    }
    ,
    t.prototype._checkFinalizedStatuses = function(e) {
        var t = this
          , n = t.hasError
          , r = t.thrownError
          , o = t.isStopped;
        n ? e.error(r) : o && e.complete()
    }
    ,
    t.prototype.asObservable = function() {
        var e = new Observable;
        return e.source = this,
        e
    }
    ,
    t.create = function(e, t) {
        return new AnonymousSubject(e,t)
    }
    ,
    t
}(Observable)
  , AnonymousSubject = function(e) {
    function t(t, n) {
        var r = e.call(this) || this;
        return r.destination = t,
        r.source = n,
        r
    }
    return __extends(t, e),
    t.prototype.next = function(e) {
        var t, n;
        null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.next) || void 0 === n || n.call(t, e)
    }
    ,
    t.prototype.error = function(e) {
        var t, n;
        null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.error) || void 0 === n || n.call(t, e)
    }
    ,
    t.prototype.complete = function() {
        var e, t;
        null === (t = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === t || t.call(e)
    }
    ,
    t.prototype._subscribe = function(e) {
        var t, n;
        return null !== (n = null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(e)) && void 0 !== n ? n : EMPTY_SUBSCRIPTION
    }
    ,
    t
}(Subject)
  , dateTimestampProvider = {
    now: function() {
        return (dateTimestampProvider.delegate || Date).now()
    },
    delegate: void 0
}
  , ReplaySubject = function(e) {
    function t(t, n, r) {
        void 0 === t && (t = 1 / 0),
        void 0 === n && (n = 1 / 0),
        void 0 === r && (r = dateTimestampProvider);
        var o = e.call(this) || this;
        return o._bufferSize = t,
        o._windowTime = n,
        o._timestampProvider = r,
        o._buffer = [],
        o._infiniteTimeWindow = !0,
        o._infiniteTimeWindow = n === 1 / 0,
        o._bufferSize = Math.max(1, t),
        o._windowTime = Math.max(1, n),
        o
    }
    return __extends(t, e),
    t.prototype.next = function(t) {
        var n = this
          , r = n.isStopped
          , o = n._buffer
          , i = n._infiniteTimeWindow
          , a = n._timestampProvider
          , s = n._windowTime;
        r || (o.push(t),
        !i && o.push(a.now() + s)),
        this._trimBuffer(),
        e.prototype.next.call(this, t)
    }
    ,
    t.prototype._subscribe = function(e) {
        this._throwIfClosed(),
        this._trimBuffer();
        for (var t = this._innerSubscribe(e), n = this._infiniteTimeWindow, r = this._buffer.slice(), o = 0; o < r.length && !e.closed; o += n ? 1 : 2)
            e.next(r[o]);
        return this._checkFinalizedStatuses(e),
        t
    }
    ,
    t.prototype._trimBuffer = function() {
        var e = this
          , t = e._bufferSize
          , n = e._timestampProvider
          , r = e._buffer
          , o = e._infiniteTimeWindow
          , i = (o ? 1 : 2) * t;
        if (t < 1 / 0 && i < r.length && r.splice(0, r.length - i),
        !o) {
            for (var a = n.now(), s = 0, c = 1; c < r.length && r[c] <= a; c += 2)
                s = c;
            s && r.splice(0, s + 1)
        }
    }
    ,
    t
}(Subject)
  , EMPTY$1 = new Observable((function(e) {
    return e.complete()
}
));
function isScheduler(e) {
    return e && isFunction(e.schedule)
}
function last(e) {
    return e[e.length - 1]
}
function popScheduler(e) {
    return isScheduler(last(e)) ? e.pop() : void 0
}
function popNumber(e, t) {
    return "number" == typeof last(e) ? e.pop() : t
}
var isArrayLike = function(e) {
    return e && "number" == typeof e.length && "function" != typeof e
};
function isPromise(e) {
    return isFunction(null == e ? void 0 : e.then)
}
function isInteropObservable(e) {
    return isFunction(e[observable])
}
function isAsyncIterable(e) {
    return Symbol.asyncIterator && isFunction(null == e ? void 0 : e[Symbol.asyncIterator])
}
function createInvalidObservableTypeError(e) {
    return new TypeError("You provided " + (null !== e && "object" == typeof e ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")
}
function getSymbolIterator() {
    return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
}
var iterator = getSymbolIterator();
function isIterable(e) {
    return isFunction(null == e ? void 0 : e[iterator])
}
function readableStreamLikeToAsyncGenerator(e) {
    return __asyncGenerator(this, arguments, (function() {
        var t, n, r;
        return __generator(this, (function(o) {
            switch (o.label) {
            case 0:
                t = e.getReader(),
                o.label = 1;
            case 1:
                o.trys.push([1, , 9, 10]),
                o.label = 2;
            case 2:
                return [4, __await(t.read())];
            case 3:
                return n = o.sent(),
                r = n.value,
                n.done ? [4, __await(void 0)] : [3, 5];
            case 4:
                return [2, o.sent()];
            case 5:
                return [4, __await(r)];
            case 6:
                return [4, o.sent()];
            case 7:
                return o.sent(),
                [3, 2];
            case 8:
                return [3, 10];
            case 9:
                return t.releaseLock(),
                [7];
            case 10:
                return [2]
            }
        }
        ))
    }
    ))
}
function isReadableStreamLike(e) {
    return isFunction(null == e ? void 0 : e.getReader)
}
function innerFrom(e) {
    if (e instanceof Observable)
        return e;
    if (null != e) {
        if (isInteropObservable(e))
            return fromInteropObservable(e);
        if (isArrayLike(e))
            return fromArrayLike(e);
        if (isPromise(e))
            return fromPromise(e);
        if (isAsyncIterable(e))
            return fromAsyncIterable(e);
        if (isIterable(e))
            return fromIterable(e);
        if (isReadableStreamLike(e))
            return fromReadableStreamLike(e)
    }
    throw createInvalidObservableTypeError(e)
}
function fromInteropObservable(e) {
    return new Observable((function(t) {
        var n = e[observable]();
        if (isFunction(n.subscribe))
            return n.subscribe(t);
        throw new TypeError("Provided object does not correctly implement Symbol.observable")
    }
    ))
}
function fromArrayLike(e) {
    return new Observable((function(t) {
        for (var n = 0; n < e.length && !t.closed; n++)
            t.next(e[n]);
        t.complete()
    }
    ))
}
function fromPromise(e) {
    return new Observable((function(t) {
        e.then((function(e) {
            t.closed || (t.next(e),
            t.complete())
        }
        ), (function(e) {
            return t.error(e)
        }
        )).then(null, reportUnhandledError)
    }
    ))
}
function fromIterable(e) {
    return new Observable((function(t) {
        var n, r;
        try {
            for (var o = __values(e), i = o.next(); !i.done; i = o.next()) {
                var a = i.value;
                if (t.next(a),
                t.closed)
                    return
            }
        } catch (s) {
            n = {
                error: s
            }
        } finally {
            try {
                i && !i.done && (r = o.return) && r.call(o)
            } finally {
                if (n)
                    throw n.error
            }
        }
        t.complete()
    }
    ))
}
function fromAsyncIterable(e) {
    return new Observable((function(t) {
        process$1(e, t).catch((function(e) {
            return t.error(e)
        }
        ))
    }
    ))
}
function fromReadableStreamLike(e) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(e))
}
function process$1(e, t) {
    var n, r, o, i;
    return __awaiter(this, void 0, void 0, (function() {
        var a, s;
        return __generator(this, (function(c) {
            switch (c.label) {
            case 0:
                c.trys.push([0, 5, 6, 11]),
                n = __asyncValues(e),
                c.label = 1;
            case 1:
                return [4, n.next()];
            case 2:
                if ((r = c.sent()).done)
                    return [3, 4];
                if (a = r.value,
                t.next(a),
                t.closed)
                    return [2];
                c.label = 3;
            case 3:
                return [3, 1];
            case 4:
                return [3, 11];
            case 5:
                return s = c.sent(),
                o = {
                    error: s
                },
                [3, 11];
            case 6:
                return c.trys.push([6, , 9, 10]),
                r && !r.done && (i = n.return) ? [4, i.call(n)] : [3, 8];
            case 7:
                c.sent(),
                c.label = 8;
            case 8:
                return [3, 10];
            case 9:
                if (o)
                    throw o.error;
                return [7];
            case 10:
                return [7];
            case 11:
                return t.complete(),
                [2]
            }
        }
        ))
    }
    ))
}
function executeSchedule(e, t, n, r, o) {
    void 0 === r && (r = 0),
    void 0 === o && (o = !1);
    var i = t.schedule((function() {
        n(),
        o ? e.add(this.schedule(null, r)) : this.unsubscribe()
    }
    ), r);
    if (e.add(i),
    !o)
        return i
}
function observeOn(e, t) {
    return void 0 === t && (t = 0),
    operate((function(n, r) {
        n.subscribe(createOperatorSubscriber(r, (function(n) {
            return executeSchedule(r, e, (function() {
                return r.next(n)
            }
            ), t)
        }
        ), (function() {
            return executeSchedule(r, e, (function() {
                return r.complete()
            }
            ), t)
        }
        ), (function(n) {
            return executeSchedule(r, e, (function() {
                return r.error(n)
            }
            ), t)
        }
        )))
    }
    ))
}
function subscribeOn(e, t) {
    return void 0 === t && (t = 0),
    operate((function(n, r) {
        r.add(e.schedule((function() {
            return n.subscribe(r)
        }
        ), t))
    }
    ))
}
function scheduleObservable(e, t) {
    return innerFrom(e).pipe(subscribeOn(t), observeOn(t))
}
function schedulePromise(e, t) {
    return innerFrom(e).pipe(subscribeOn(t), observeOn(t))
}
function scheduleArray(e, t) {
    return new Observable((function(n) {
        var r = 0;
        return t.schedule((function() {
            r === e.length ? n.complete() : (n.next(e[r++]),
            n.closed || this.schedule())
        }
        ))
    }
    ))
}
function scheduleIterable(e, t) {
    return new Observable((function(n) {
        var r;
        return executeSchedule(n, t, (function() {
            r = e[iterator](),
            executeSchedule(n, t, (function() {
                var e, t, o;
                try {
                    t = (e = r.next()).value,
                    o = e.done
                } catch (i) {
                    return void n.error(i)
                }
                o ? n.complete() : n.next(t)
            }
            ), 0, !0)
        }
        )),
        function() {
            return isFunction(null == r ? void 0 : r.return) && r.return()
        }
    }
    ))
}
function scheduleAsyncIterable(e, t) {
    if (!e)
        throw new Error("Iterable cannot be null");
    return new Observable((function(n) {
        executeSchedule(n, t, (function() {
            var r = e[Symbol.asyncIterator]();
            executeSchedule(n, t, (function() {
                r.next().then((function(e) {
                    e.done ? n.complete() : n.next(e.value)
                }
                ))
            }
            ), 0, !0)
        }
        ))
    }
    ))
}
function scheduleReadableStreamLike(e, t) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(e), t)
}
function scheduled(e, t) {
    if (null != e) {
        if (isInteropObservable(e))
            return scheduleObservable(e, t);
        if (isArrayLike(e))
            return scheduleArray(e, t);
        if (isPromise(e))
            return schedulePromise(e, t);
        if (isAsyncIterable(e))
            return scheduleAsyncIterable(e, t);
        if (isIterable(e))
            return scheduleIterable(e, t);
        if (isReadableStreamLike(e))
            return scheduleReadableStreamLike(e, t)
    }
    throw createInvalidObservableTypeError(e)
}
function from(e, t) {
    return t ? scheduled(e, t) : innerFrom(e)
}
function map(e, t) {
    return operate((function(n, r) {
        var o = 0;
        n.subscribe(createOperatorSubscriber(r, (function(n) {
            r.next(e.call(t, n, o++))
        }
        )))
    }
    ))
}
function mergeInternals(e, t, n, r, o, i, a, s) {
    var c = []
      , l = 0
      , u = 0
      , p = !1
      , d = function() {
        !p || c.length || l || t.complete()
    }
      , f = function(e) {
        l++;
        var o = !1;
        innerFrom(n(e, u++)).subscribe(createOperatorSubscriber(t, (function(e) {
            t.next(e)
        }
        ), (function() {
            o = !0
        }
        ), void 0, (function() {
            if (o)
                try {
                    l--;
                    for (; c.length && l < r; )
                        e = void 0,
                        e = c.shift(),
                        a || f(e);
                    d()
                } catch (n) {
                    t.error(n)
                }
            var e
        }
        )))
    };
    return e.subscribe(createOperatorSubscriber(t, (function(e) {
        return l < r ? f(e) : c.push(e)
    }
    ), (function() {
        p = !0,
        d()
    }
    ))),
    function() {}
}
function mergeMap(e, t, n) {
    return void 0 === n && (n = 1 / 0),
    isFunction(t) ? mergeMap((function(n, r) {
        return map((function(e, o) {
            return t(n, e, r, o)
        }
        ))(innerFrom(e(n, r)))
    }
    ), n) : ("number" == typeof t && (n = t),
    operate((function(t, r) {
        return mergeInternals(t, r, e, n)
    }
    )))
}
function mergeAll(e) {
    return void 0 === e && (e = 1 / 0),
    mergeMap(identity, e)
}
function merge() {
    for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
    var n = popScheduler(e)
      , r = popNumber(e, 1 / 0)
      , o = e;
    return o.length ? 1 === o.length ? innerFrom(o[0]) : mergeAll(r)(from(o, n)) : EMPTY$1
}
function switchMap(e, t) {
    return operate((function(n, r) {
        var o = null
          , i = 0
          , a = !1
          , s = function() {
            return a && !o && r.complete()
        };
        n.subscribe(createOperatorSubscriber(r, (function(n) {
            null == o || o.unsubscribe();
            var a = 0
              , c = i++;
            innerFrom(e(n, c)).subscribe(o = createOperatorSubscriber(r, (function(e) {
                return r.next(t ? t(n, e, c, a++) : e)
            }
            ), (function() {
                o = null,
                s()
            }
            )))
        }
        ), (function() {
            a = !0,
            s()
        }
        )))
    }
    ))
}
function switchAll() {
    return switchMap(identity)
}
const INJECT_KEY = "REBORN_STORE_KEY"
  , ROOT_STORE_MAP = new WeakMap;
let MODE = "SPA";
function setMode(e) {
    MODE = e
}
function getRootStore() {
    var e;
    const t = null == (e = getCurrentInstance()) ? void 0 : e.proxy
      , n = t && ROOT_STORE_MAP.get(t);
    return null != n ? n : inject(INJECT_KEY)
}
function storeFactory() {
    const e = new Map;
    const t = ref(0);
    let n = null;
    return {
        getModelInstance: function(t) {
            var n, r;
            return null == (r = null == (n = e.get(t)) ? void 0 : n.instance) ? void 0 : r.model
        },
        addModel: function(t) {
            if (e.has(t))
                return e.get(t);
            const n = {
                constructor: t,
                instance: null,
                count: 0,
                queryList: [],
                scope: null,
                subModels: new Set
            };
            return e.set(t, n),
            n
        },
        removeModel: function(t) {
            e.has(t) && e.delete(t)
        },
        hydrationStatus: t,
        setCurrentModelInstance: function(e) {
            n = e
        },
        getCurrentModelInstance: function() {
            return n
        }
    }
}
function createStore() {
    const e = storeFactory()
      , t = {};
    return {
        install: function(n, r=!1) {
            n.config && "object" == typeof n.config.globalProperties ? (n.config.globalProperties.rebornStore = e,
            n.config.globalProperties.rebornClient = t,
            n.provide(INJECT_KEY, {
                store: e,
                rebornClient: t
            })) : n.mixin({
                provide() {
                    if (this === this.$root)
                        return {
                            [INJECT_KEY]: {
                                store: e,
                                rebornClient: t
                            }
                        }
                },
                beforeCreate() {
                    this === this.$root && ROOT_STORE_MAP.set(this, {
                        store: e,
                        rebornClient: t
                    })
                }
            }),
            setMode(r ? "SSR" : "SPA")
        },
        registerClient: function(e) {
            if ("REST" === e.type)
                return t.rest ? void console.warn("You have already registered a restClient yet") : void (t.rest = e);
            t.gql ? console.warn("You have already registered a gqlClient yet") : t.gql = e
        }
    }
}
const ESCAPED_CHARS = {
    "<": "\\u003C",
    ">": "\\u003E",
    "/": "\\u002F",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
};
function encode$1(e) {
    var t;
    let n = "";
    for (let r = 0; r < e.length; r++) {
        const o = String.fromCharCode(e.charCodeAt(r) + 1);
        n += null != (t = ESCAPED_CHARS[o]) ? t : o
    }
    return n
}
function hash(e) {
    if (null === e)
        return encode$1("null-null");
    if (Array.isArray(e))
        return encode$1("array-".concat(e.map(hash).join("-")));
    if ("function" == typeof e)
        throw new Error("Function hash is not support");
    return encode$1("object" == typeof e ? "object-".concat(Object.keys(e).sort().map((t => "".concat(t, "-").concat(hash(e[t])))).join("-")) : "".concat(typeof e, "-").concat(e))
}
function stringifyPrimitive(e) {
    switch (typeof e) {
    case "string":
        return e;
    case "boolean":
        return e ? "true" : "false";
    case "number":
        return isFinite(e) ? e : "";
    default:
        return ""
    }
}
function encode(e) {
    return encodeURIComponent(stringifyPrimitive(e))
}
function shimStringify(e) {
    if (null === e && (e = void 0),
    "object" != typeof e)
        throw new Error("Params stringify Error, only support object");
    return Object.keys(e).map((t => {
        const n = encode(t) + "=";
        return Array.isArray(e[t]) ? e[t].map((e => n + encode(e))).join("&") : n + encode(e[t])
    }
    )).join("&")
}
function appendQueryStringToUrl(e, t) {
    return e = -1 !== e.indexOf("?") ? "".concat(e, "&").concat(t) : "".concat(e, "?").concat(t)
}
function deepMerge(e, ...t) {
    for (const n of t)
        for (const t in n) {
            const r = e[t]
              , o = n[t];
            if (null == o)
                continue;
            let i;
            i = Array.isArray(o) ? o.map((e => Array.isArray(e) ? [...deepMerge([], e)] : "object" == typeof e && null !== e ? deepMerge({}, e) : e)) : "object" == typeof o && null !== o ? deepMerge({}, o) : o,
            typeof r == typeof o && null !== r ? Array.isArray(r) ? r.push(...i) : e[t] = "object" == typeof i ? deepMerge(r, o) : o : e[t] = i
        }
    return e
}
function fromWatch(e, t) {
    return new Observable((n => {
        watch(e, ( (e, t) => {
            (!e && void 0 === t || hash(e) !== hash(t)) && n.next(e)
        }
        ), t)
    }
    ))
}
function isDef(e) {
    return null != e
}
function createCache() {
    let e = {};
    return {
        restore: function(t) {
            e = t || e
        },
        put: function(t, n) {
            e[t] = n
        },
        get: function(t) {
            return e[t]
        },
        update: function(t, n) {
            e[t] = deepMerge(e[t], n)
        },
        remove: function(t) {
            e[t] = void 0
        },
        extract: function() {
            return JSON.stringify(e)
        }
    }
}
function createInterceptor(e) {
    const t = [];
    return {
        list: t,
        use: function e(n, r) {
            return t.push({
                onResolve: n,
                onReject: r
            }),
            {
                use: e
            }
        }
    }
}
class _TimeoutError extends Error {
    constructor(e) {
        super(e),
        this.name = "ModelTimeoutError",
        this.message = e
    }
}
class FetchError extends Error {
    constructor(e) {
        super(e),
        this.name = "ModelFetchError",
        this.message = e
    }
}
const TimeoutError = "undefined" != typeof DOMException ? DOMException : _TimeoutError
  , DEFAULT_OPTIONS = {
    method: "GET",
    headers: {},
    timeout: 6e4,
    credentials: "include"
};
function mergeClientOptionsAndParams(e, t) {
    var n;
    const {timeout: r, headers: o, method: i, credentials: a, baseUrl: s} = e
      , c = s ? new URL(t.url || "/",s).href : t.url || ""
      , l = {
        timeout: t.timeout || r,
        headers: deepMerge({}, o, t.headers),
        credentials: a,
        url: c || "",
        variables: t.variables
    };
    return "credentials"in t && (l.credentials = null != (n = t.credentials) ? n : a),
    "method"in t ? {
        ...l,
        method: t.method || i,
        fetchPolicy: t.fetchPolicy
    } : "query"in t ? {
        ...l,
        query: t.query,
        fetchPolicy: t.fetchPolicy
    } : "mutation"in t ? {
        ...l,
        mutation: t.mutation
    } : l
}
function clientFactory(e, t, n) {
    const r = n ? deepMerge({}, DEFAULT_OPTIONS, n) : deepMerge({}, DEFAULT_OPTIONS)
      , o = createInterceptor()
      , i = createInterceptor()
      , a = {
        request: {
            use: o.use
        },
        response: {
            use: i.use
        }
    };
    function s(n) {
        const a = [...o.list]
          , s = mergeClientOptionsAndParams(r, n);
        let c, l = Promise.resolve(s);
        for (; a.length; ) {
            const e = a.shift();
            l = l.then(null == e ? void 0 : e.onResolve, null == e ? void 0 : e.onReject)
        }
        return l.then((n => {
            if (c = t(e, n),
            !r.fetch)
                if ("SPA" === MODE) {
                    if ("undefined" == typeof window || !window.fetch)
                        throw new Error('There is no useful "fetch" function');
                    r.fetch = (e, t) => window.fetch(e, t)
                } else if ("SSR" === MODE) {
                    if (!globalThis.fetch)
                        throw new Error('There is no useful "fetch" function');
                    r.fetch = (e, t) => globalThis.fetch(e, t)
                }
            const {url: o, requestInit: i} = c;
            let a;
            const l = r.fetch(o, i).catch((e => new FetchError(e.message)))
              , u = new Promise((e => {
                a = setTimeout(( () => {
                    e(new TimeoutError("The request has been timeout"))
                }
                ), s.timeout)
            }
            ));
            return Promise.race([u, l]).finally(( () => {
                clearTimeout(a)
            }
            ))
        }
        )).then((e => {
            var t, n;
            null === e && (e = new TimeoutError("The request has been timeout"));
            const r = [...i.list];
            if (!("status"in e)) {
                let t = Promise.reject({
                    res: e,
                    request: c
                });
                for (; r.length; ) {
                    const e = r.shift();
                    t = t.then(null == e ? void 0 : e.onResolve, null == e ? void 0 : e.onReject)
                }
                return t
            }
            const o = e.headers.get("Content-Type") || (null == (t = c.requestInit.headers) ? void 0 : t["Content-Type"]) || (null == (n = c.requestInit.headers) ? void 0 : n["content-type"]) || "application/json"
              , a = {
                status: e.status,
                statusText: e.statusText,
                headers: e.headers,
                config: c,
                data: void 0
            };
            let s;
            for (-1 !== o.indexOf("application/json") ? s = e.ok ? e.json().then((e => (a.data = e,
            a))) : Promise.reject({
                res: e,
                request: c
            }) : (a.data = e.body,
            s = e.ok ? Promise.resolve(a) : Promise.reject({
                res: e,
                request: c
            })); r.length; ) {
                const e = r.shift();
                s = s.then(null == e ? void 0 : e.onResolve, null == e ? void 0 : e.onReject)
            }
            return s
        }
        ))
    }
    const c = (null == n ? void 0 : n.cache) || createCache();
    function l(e) {
        return c.get("".concat(hash(e.url), "-").concat(hash(e.variables || {})))
    }
    function u(e, t) {
        const n = "".concat(hash(e.url), "-").concat(hash(e.variables || {}));
        c.put(n, t)
    }
    return {
        interceptors: a,
        query: function(e, t="network-first", n) {
            const r = new ReplaySubject;
            if (2 !== n.value) {
                const t = l(e);
                if (t)
                    return r.next(t),
                    r.complete(),
                    r
            }
            const o = l(e);
            switch (t) {
            case "cache-and-network":
                o && r.next(o),
                s(e).then((t => {
                    u(e, t),
                    r.next(t),
                    r.complete()
                }
                )).catch((e => {
                    r.error(e),
                    r.complete()
                }
                ));
                break;
            case "cache-first":
                o ? r.next(o) : s(e).then((t => {
                    u(e, t),
                    r.next(t),
                    r.complete()
                }
                )).catch((e => r.error(e)));
                break;
            case "network-first":
                s(e).then((t => {
                    u(e, t),
                    r.next(t),
                    r.complete()
                }
                )).catch((e => {
                    r.error(e),
                    r.complete()
                }
                ));
                break;
            case "cache-only":
                o ? (r.next(o),
                r.complete()) : (r.error("No data in cache"),
                r.complete());
                break;
            case "network-only":
                s(e).then((e => {
                    r.next(e),
                    r.complete()
                }
                )).catch((e => {
                    r.complete(),
                    r.error(e)
                }
                ));
            default:
                throw new Error("There is a wrong fetchPolicy: ".concat(t))
            }
            return r
        },
        mutate: s,
        type: e
    }
}
function transformRequestBody(e, t) {
    if (t && "application/json" === t["content-type"])
        return JSON.stringify(e);
    if (t && "application/x-www-form-urlencoded" === t["content-type"])
        return shimStringify(e);
    if (t && "multipart/form-data" === t["content-type"]) {
        const t = new FormData;
        for (const n in e)
            t.append(n, e[n]);
        return t
    }
    return "function" == typeof FormData && FormData && e instanceof FormData ? e : "function" == typeof URLSearchParams && e instanceof URLSearchParams && t ? (t["content-type"] = "application/x-www-form-urlencoded",
    e.toString()) : "[object ArrayBuffer]" === Object.prototype.toString.call(e) || "[object File]" === Object.prototype.toString.call(e) || "[object Blob]" === Object.prototype.toString.call(e) ? e : JSON.stringify(e)
}
function generateCommonRequestInfo(e) {
    return {
        method: e.method,
        credentials: e.credentials,
        headers: e.headers,
        cache: "no-store"
    }
}
function generateRestRequestInfo(e) {
    var t, n, r, o;
    let i = generateCommonRequestInfo(e);
    const a = i.headers || {};
    let {variables: s, url: c} = e;
    "get" === (null == (t = i.method) ? void 0 : t.toLowerCase()) && s && (a["content-type"] && "application/x-www-form-urlencoded" !== a["content-type"] && console.error("get 请求请指定 content-type 为 `application/x-www-form-urlencoded` 传参，当前为：", a["content-type"]),
    a["content-type"] = "application/x-www-form-urlencoded"),
    "post" !== (null == (n = i.method) ? void 0 : n.toLowerCase()) || a["content-type"] || (a["content-type"] = "application/json");
    let l = s ? transformRequestBody(s, a) : void 0;
    return "get" !== (null == (r = i.method) ? void 0 : r.toLowerCase()) && "head" !== (null == (o = i.method) ? void 0 : o.toLowerCase()) || ("application/x-www-form-urlencoded" === a["content-type"] && l && (c = appendQueryStringToUrl(c, l)),
    l = void 0),
    "function" == typeof FormData && l instanceof FormData ? delete a["content-type"] : "application/x-www-form-urlencoded" === a["content-type"] && (a["content-type"] = "application/x-www-form-urlencoded;charset=UTF-8"),
    l && (i.body = l),
    {
        url: c,
        requestInit: i
    }
}
function generateGQLRequestInfo(e) {
    let {url: t, timeout: n, ...r} = e;
    return {
        url: t || "",
        requestInit: r
    }
}
function generateRequestInfo(e, t) {
    return "GQL" === e ? generateGQLRequestInfo(t) : generateRestRequestInfo(t)
}
function createClient(e, t) {
    return clientFactory(e, generateRequestInfo, t)
}
var RequestReason, RequestReason2, StateStatus, StateStatus2;
function getStatus(e, t) {
    return e.loading ? isDef(e.data) ? t === RequestReason.fetchMore ? StateStatus.FetchMore : t === RequestReason.poll ? StateStatus.Pool : StateStatus.Refresh : StateStatus.Loading : isDef(e.error) ? isDef(e.data) ? t === RequestReason.fetchMore ? StateStatus.FetchMoreError : t === RequestReason.poll ? StateStatus.PoolError : StateStatus.RefreshError : StateStatus.Error : isDef(e.data) ? StateStatus.Done : StateStatus.Empty
}
function useStatus(e, t) {
    return computed(( () => getStatus(e, t.value)))
}
function initDataType() {
    return reactive({
        data: void 0,
        loading: !1,
        error: void 0
    })
}
function generateQueryOptions(e, t, n) {
    const r = initDataType()
      , o = computed(( () => "function" == typeof e.skip ? e.skip.call(n, t) : !!e.skip))
      , i = computed(( () => "function" == typeof e.pollInterval ? e.pollInterval.call(n, t) : e.pollInterval || 0))
      , a = computed(( () => "function" == typeof e.variables ? e.variables.call(n, t) : e.variables))
      , s = computed(( () => "function" == typeof e.url ? e.url.call(n, t, a.value) : e.url))
      , c = merge(fromWatch(( () => ({
        variables: a.value,
        url: s.value,
        skip: o.value
    })), {
        immediate: !0
    }).pipe(map((e => RequestReason.setVariables))), new Observable((e => {
        let t;
        const n = () => {
            "SSR" !== MODE && (clearTimeout(t),
            i.value > 0 && (t = setTimeout(r, i.value)))
        }
          , r = () => {
            e.next(RequestReason.poll),
            n()
        }
        ;
        watch(( () => i.value), ( (e, t) => {
            e !== t && n()
        }
        ), {
            immediate: !0
        })
    }
    )));
    return {
        info: r,
        skip: o,
        pollInterval: i,
        variables: a,
        url: s,
        fetchQuery$: c,
        prefetch: e.prefetch || !0
    }
}
function createGQLMutation(e, t, n, r) {
    if (!r)
        throw new Error("No GQL Client has been set");
    const o = initDataType();
    function i(r) {
        return e.variables && "function" == typeof e.variables ? e.variables.call(t, r, n) : r
    }
    return {
        info: o,
        mutate: e => (o.loading = !0,
        o.error = void 0,
        r.mutate({
            mutation: "",
            variables: i(e)
        }).then((e => {
            o.error = void 0,
            e && (o.data = e),
            o.loading = !1
        }
        )).catch((e => {
            o.error = e,
            o.loading = !1
        }
        )))
    }
}
function createGQLQuery(e, t, n, r, o) {
    if (!o)
        throw new Error("No GQL Client has been set");
    const {info: i, skip: a, pollInterval: s, variables: c} = generateQueryOptions(e, n, t)
      , l = ref(0);
    function u() {}
    return computed(( () => ({
        ...e,
        variables: c.value,
        skip: a.value,
        pollInterval: s.value
    }))),
    computed(( () => [c.value, a.value, s.value])),
    {
        info: i,
        init: function() {},
        destroy: function() {},
        fetchMore: function(e) {},
        refetch: u,
        prefetch: u,
        onNext: function() {},
        requestReason: l
    }
}
function createRestMutation(e, t, n, r) {
    if (!r)
        throw new Error("No Rest Client has been set");
    const o = initDataType();
    function i(r) {
        return e.variables && "function" == typeof e.variables ? e.variables.call(t, r, n) : r
    }
    function a(r, o) {
        return e.url && "function" == typeof e.url ? e.url.call(t, n, r, o) : e.url
    }
    const s = new Subject
      , c = s.pipe(mergeAll());
    s.pipe(switchAll()).subscribe((e => {
        o.loading = e.loading,
        o.loading || (o.error = e.error,
        e.data && (o.data = e.data))
    }
    ));
    let l = 0;
    return {
        info: o,
        mutate: function(t, n) {
            const o = ++l
              , c = {
                url: a(i(t), t),
                headers: e.headers,
                credentials: e.credentials,
                method: e.method,
                variables: i(t),
                timeout: e.timeout
            }
              , u = new Subject;
            return s.next(u),
            u.next({
                id: o,
                url: c.url,
                variables: c.variables,
                loading: !0,
                data: void 0,
                error: void 0,
                context: n
            }),
            r.mutate(c).then((e => {
                u.next({
                    id: o,
                    url: c.url,
                    variables: c.variables,
                    loading: !1,
                    data: e,
                    error: void 0,
                    context: n
                })
            }
            )).catch((e => {
                u.next({
                    id: o,
                    url: c.url,
                    variables: c.variables,
                    loading: !1,
                    data: void 0,
                    error: e,
                    context: n
                })
            }
            )).finally(( () => {
                u.complete()
            }
            ))
        },
        stream$: c,
        destroy: function() {
            s.complete()
        }
    }
}
function createRestQuery(e, t, n, r, o) {
    if (!o)
        throw new Error("No Rest Client has been set");
    const {info: i, skip: a, variables: s, fetchQuery$: c, url: l, prefetch: u} = generateQueryOptions(e, n, t)
      , p = new Subject
      , d = p.pipe(mergeAll())
      , f = ref(RequestReason.setVariables);
    p.pipe(switchAll()).subscribe((e => {
        i.loading = e.loading,
        e.loading || (i.error = e.error,
        e.data && (i.data = e.data))
    }
    ));
    let h = 0;
    function m(t, n) {
        var a, s;
        const c = {
            ...i
        };
        f.value = t;
        const u = ++h
          , d = {
            url: l.value,
            variables: n
        }
          , m = {
            headers: e.headers,
            method: e.method,
            fetchPolicy: e.fetchPolicy,
            credentials: e.credentials,
            timeout: e.timeout,
            ...d,
            ...null != (s = null == (a = e.beforeQuery) ? void 0 : a.call(e, d)) ? s : {}
        }
          , g = new Subject;
        return p.next(g),
        new Promise((n => {
            g.next({
                id: u,
                url: m.url,
                variables: m.variables,
                requestReason: t,
                status: getStatus({
                    ...c,
                    loading: !0
                }, t),
                data: void 0,
                loading: !0,
                error: void 0
            });
            const i = o.query(m, e.fetchPolicy, r);
            i.subscribe({
                next: r => {
                    const o = r && e.updateQuery && t === RequestReason.fetchMore ? e.updateQuery(c.data, r) : r;
                    g.next({
                        id: u,
                        url: m.url,
                        variables: m.variables,
                        requestReason: t,
                        status: getStatus({
                            error: void 0,
                            data: o,
                            loading: !1
                        }, t),
                        data: o,
                        loading: !1,
                        error: void 0
                    }),
                    n(void 0)
                }
                ,
                error: e => {
                    g.next({
                        id: u,
                        url: m.url,
                        variables: m.variables,
                        requestReason: t,
                        status: getStatus({
                            ...c,
                            error: e,
                            loading: !1
                        }, t),
                        data: void 0,
                        loading: !1,
                        error: e
                    }),
                    g.complete(),
                    n(void 0)
                }
                ,
                complete: () => {
                    g.complete(),
                    i.unsubscribe()
                }
            })
        }
        ))
    }
    let g = null;
    return {
        info: i,
        init: function() {
            g = c.subscribe((e => {
                a.value || m(e, s.value)
            }
            ))
        },
        refetch: () => m(RequestReason.refetch, s.value),
        prefetch: () => {
            if (!a.value)
                return m(RequestReason.setVariables, s.value)
        }
        ,
        fetchMore: function(e) {
            return m(RequestReason.fetchMore, e)
        },
        destroy: function() {
            g && (g.unsubscribe(),
            g = null),
            p.complete()
        },
        onNext: function(e) {},
        requestReason: f,
        stream$: d
    }
}
RequestReason2 = RequestReason || (RequestReason = {}),
RequestReason2[RequestReason2.setVariables = 0] = "setVariables",
RequestReason2[RequestReason2.fetchMore = 1] = "fetchMore",
RequestReason2[RequestReason2.refetch = 2] = "refetch",
RequestReason2[RequestReason2.poll = 3] = "poll",
StateStatus2 = StateStatus || (StateStatus = {}),
StateStatus2.Empty = "Empty",
StateStatus2.Loading = "Loading",
StateStatus2.Done = "Done",
StateStatus2.Error = "Error",
StateStatus2.Refresh = "Refresh",
StateStatus2.RefreshError = "RefreshError",
StateStatus2.FetchMore = "FetchMore",
StateStatus2.FetchMoreError = "FetchMoreError",
StateStatus2.Pool = "Pool",
StateStatus2.PoolError = "PoolError";
let creatingModelCount = 0;
const tempQueryList = []
  , useRoute = e => {
    const t = shallowReactive(Object.assign({}, e.proxy.$route));
    return watch(( () => e.proxy.$route), (e => {
        Object.assign(t, e)
    }
    )),
    t
}
  , useRestQuery = e => {
    const t = getCurrentInstance();
    if (creatingModelCount <= 0 || !t)
        throw new Error("You should use useRestQuery with createModel context ");
    const n = useRoute(t)
      , {rebornClient: r, store: o} = getRootStore()
      , i = createRestQuery(e, null, n, o.hydrationStatus, r.rest);
    tempQueryList.push(i);
    const a = useStatus(i.info, i.requestReason)
      , {loading: s, error: c, data: l} = toRefs(i.info);
    return {
        info: i.info,
        status: a,
        loading: s,
        error: c,
        data: l,
        refetch: i.refetch,
        fetchMore: i.fetchMore,
        onNext: i.onNext,
        requestReason: i.requestReason,
        stream$: i.stream$
    }
}
  , useRestMutation = e => {
    const t = getCurrentInstance();
    if (creatingModelCount <= 0 || !t)
        throw new Error("You should use useRestMutation with createModel context ");
    const n = useRoute(t)
      , {rebornClient: r} = getRootStore()
      , o = createRestMutation(e, null, n, r.rest);
    return tempQueryList.push(o),
    {
        info: o.info,
        mutate: o.mutate,
        stream$: o.stream$
    }
}
;
function createModelFromCA(e) {
    return {
        type: "FunctionalModel",
        ctor: () => {
            const {model: t, queryList: n} = ( () => {
                creatingModelCount++;
                const {store: t} = getRootStore()
                  , n = e.fn({
                    getModelInstance: t.getModelInstance
                })
                  , r = [...tempQueryList];
                return creatingModelCount--,
                tempQueryList.length = 0,
                {
                    queryList: r,
                    model: n
                }
            }
            )();
            let r;
            return n.length && "SSR" !== MODE && n.forEach((e => {
                var t;
                return null == (t = e.init) ? void 0 : t.call(e)
            }
            )),
            {
                model: t,
                prefetch: function() {
                    return r || (r = Promise.all(n.map((e => {
                        var t;
                        return null == (t = e.prefetch) ? void 0 : t.call(e)
                    }
                    )))),
                    r
                },
                destroy: function() {
                    n && (n.forEach((e => {
                        var t;
                        return null == (t = e.destroy) ? void 0 : t.call(e)
                    }
                    )),
                    n.length = 0)
                }
            }
        }
    }
}
function createModel(e) {
    return {
        type: "FN",
        fn: e
    }
}
function registerProperty(e, t, n) {
    Object.defineProperty(e, t, {
        value: n,
        writable: !1,
        configurable: !1,
        enumerable: !0
    })
}
function getDecoratorList(e) {
    const t = [];
    let n = e.constructor;
    for (; n !== Object; ) {
        const e = n.rebornDecorators;
        e && t.push(...e),
        n = Object.getPrototypeOf(n.prototype).constructor
    }
    return t
}
function initRebornDesc(e, t, n, r, o) {
    const i = []
      , a = getCurrentInstance();
    for (const s of n) {
        const {key: n, meta: c} = s;
        if (c.type.startsWith("gql") && !o.gql)
            throw new Error('Before use an gqlQuery / gqlMutation, you must register "GQL" client first');
        if (c.type.startsWith("rest") && !o.rest)
            throw new Error('Before use an restQuery / restMutation, you must register "REST" client first');
        if (c.type.endsWith("Mutation")) {
            let r;
            "gqlMutation" === c.type ? r = createGQLMutation(c.detail, e, a.proxy.$route, o.gql) : "restMutation" === c.type && (r = createRestMutation(c.detail, e, a.proxy.$route, o.rest));
            registerProperty(t, n, {
                get data() {
                    return r.info.data
                },
                get loading() {
                    return r.info.loading
                },
                get mutate() {
                    return r.mutate.bind(r)
                },
                get error() {
                    return r.info.error
                }
            })
        } else {
            let s;
            "gqlQuery" === c.type ? s = createGQLQuery(c.detail, e, a.proxy.$route, r.hydrationStatus, o.gql) : "restQuery" === c.type && (s = createRestQuery(c.detail, e, a.proxy.$route, r.hydrationStatus, o.rest));
            const l = useStatus(s.info, s.requestReason)
              , u = {
                get data() {
                    return s.info.data
                },
                get loading() {
                    return s.info.loading
                },
                get refetch() {
                    return s.refetch.bind(s)
                },
                get fetchMore() {
                    return s.fetchMore.bind(s)
                },
                get error() {
                    return s.info.error
                },
                get status() {
                    return l.value
                }
            };
            i.push(s),
            registerProperty(t, n, u)
        }
    }
    return i
}
const SKIP_PROPERTIES = ["constructor"];
function collectProperty(e) {
    const t = [];
    return Object.getOwnPropertyNames(e).forEach((n => {
        if (SKIP_PROPERTIES.indexOf(n) >= 0)
            return;
        const r = Object.getOwnPropertyDescriptor(e, n);
        r.get ? t.push({
            key: n,
            type: "getter",
            get: r.get,
            set: r.set
        }) : "function" == typeof r.value ? t.push({
            key: n,
            type: "function",
            value: r.value
        }) : t.push({
            key: n,
            type: "other",
            value: r.value
        })
    }
    )),
    t
}
function getDataFactory(e) {
    return () => {
        const t = new e
          , n = reactive({
            ...t
        })
          , r = {};
        return Object.getOwnPropertyNames(n).forEach((e => {
            Object.defineProperty(r, e, {
                get: () => n[e],
                set: t => {
                    n[e] = t
                }
            }),
            Object.defineProperty(t, e, {
                get: () => r[e],
                set: t => {
                    r[e] = t
                }
            })
        }
        )),
        {
            reactiveData: n,
            original: t,
            modelAccessor: r
        }
    }
}
function getPropertyMetaList(e) {
    const t = [];
    let n = e.prototype;
    for (; n && n !== Object.prototype; )
        t.push(...collectProperty(n)),
        n = Object.getPrototypeOf(n);
    return t
}
function generateProtoData(e) {
    return t => {
        const n = getPropertyMetaList(e);
        for (const e of n)
            if ("function" === e.type)
                Object.defineProperty(t, e.key, {
                    get: () => e.value.bind(t)
                });
            else if ("getter" === e.type) {
                const {get: n= () => {}
                , set: r} = e
                  , o = computed({
                    get: () => n.call(t),
                    set: e => {
                        r && r.call(t, e)
                    }
                })
                  , i = {
                    enumerable: !0,
                    get: () => o.value
                };
                r && (i.set = e => {
                    o.value = e
                }
                ),
                Object.defineProperty(t, e.key, i)
            }
    }
}
function createModelFromClass(e) {
    const t = getDataFactory(e)
      , n = generateProtoData(e);
    return {
        type: "ClassModel",
        ctor: e => {
            if (!e)
                throw new Error("no client has been set before you use class mode model");
            const {original: r, reactiveData: o, modelAccessor: i} = t()
              , a = getRootStore().store
              , s = getDecoratorList(r)
              , c = s.length ? initRebornDesc(o, i, s, a, e) : [];
            return n(i),
            Object.defineProperty(i, "getModelInstance", {
                get: () => a.getModelInstance,
                configurable: !0,
                enumerable: !1
            }),
            c.length && "SSR" !== MODE && c.forEach((e => e.init())),
            {
                model: i,
                prefetch: function() {
                    return Promise.all(c.map((e => e.prefetch())))
                },
                destroy: function() {
                    c && (c.forEach((e => e.destroy())),
                    c.length = 0),
                    Object.defineProperty(i, "getModelInstance", {
                        get: () => null,
                        configurable: !0,
                        enumerable: !1
                    })
                }
            }
        }
    }
}
function useModel(e) {
    var t;
    if (!getCurrentInstance())
        throw new Error("useModel must use in a setup context!");
    const {store: n, rebornClient: r} = getRootStore();
    if (!n)
        throw new Error("There is no reborn-model store in your root vm!!");
    0 === n.hydrationStatus.value && (n.hydrationStatus.value = 1,
    onMounted(( () => {
        nextTick(( () => {
            n.hydrationStatus.value = 2
        }
        ))
    }
    )));
    const o = n.addModel(e);
    if (null == (t = n.getCurrentModelInstance()) || t.subModels.add(e),
    o.count)
        o.subModels.forEach((e => {
            useModel(e)
        }
        ));
    else {
        const t = "type"in e ? createModelFromCA(e) : createModelFromClass(e);
        o.scope = effectScope(!0);
        const i = o.scope;
        null == i || i.run(( () => {
            const e = n.getCurrentModelInstance();
            n.setCurrentModelInstance(o);
            const i = t.ctor(r);
            o.instance = i,
            n.setCurrentModelInstance(e)
        }
        ))
    }
    o.count++;
    const i = () => {
        var t;
        o.count--,
        0 === o.count && o.instance && (o.instance.destroy(),
        o.instance = null,
        null == (t = o.scope) || t.stop(),
        o.scope = null,
        n.removeModel(e))
    }
    ;
    return onBeforeUnmount(( () => {
        i()
    }
    )),
    onServerPrefetch((async () => {
        var e;
        await (null == (e = o.instance) ? void 0 : e.prefetch()),
        i()
    }
    )),
    o.instance.model
}
function createModelFamily(e) {
    const t = new Map;
    return n => {
        if (t.has(n))
            return t.get(n);
        const r = createModel((n => r => (onScopeDispose(( () => {
            t.delete(n)
        }
        )),
        e(n)(r)))(n));
        return t.set(n, r),
        r
    }
}
function createUseModel(e) {
    const t = createModel(e);
    return () => useModel(t)
}
/*! js-cookie v3.0.5 | MIT */
function assign(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n)
            e[r] = n[r]
    }
    return e
}
var defaultConverter = {
    read: function(e) {
        return '"' === e[0] && (e = e.slice(1, -1)),
        e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function(e) {
        return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
    }
};
function init(e, t) {
    function n(n, r, o) {
        if ("undefined" != typeof document) {
            "number" == typeof (o = assign({}, t, o)).expires && (o.expires = new Date(Date.now() + 864e5 * o.expires)),
            o.expires && (o.expires = o.expires.toUTCString()),
            n = encodeURIComponent(n).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var i = "";
            for (var a in o)
                o[a] && (i += "; " + a,
                !0 !== o[a] && (i += "=" + o[a].split(";")[0]));
            return document.cookie = n + "=" + e.write(r, n) + i
        }
    }
    return Object.create({
        set: n,
        get: function(t) {
            if ("undefined" != typeof document && (!arguments.length || t)) {
                for (var n = document.cookie ? document.cookie.split("; ") : [], r = {}, o = 0; o < n.length; o++) {
                    var i = n[o].split("=")
                      , a = i.slice(1).join("=");
                    try {
                        var s = decodeURIComponent(i[0]);
                        if (r[s] = e.read(a, s),
                        t === s)
                            break
                    } catch (e2) {}
                }
                return t ? r[t] : r
            }
        },
        remove: function(e, t) {
            n(e, "", assign({}, t, {
                expires: -1
            }))
        },
        withAttributes: function(e) {
            return init(this.converter, assign({}, this.attributes, e))
        },
        withConverter: function(e) {
            return init(assign({}, this.converter, e), this.attributes)
        }
    }, {
        attributes: {
            value: Object.freeze(t)
        },
        converter: {
            value: Object.freeze(e)
        }
    })
}
var api = init(defaultConverter, {
    path: "/"
});
function parseAbtestHeader(e) {
    return null == e ? void 0 : e.split(";").reduce(( (e, t) => {
        const [n,r] = t.split("=");
        return n && r && (e[n] = r.trim()),
        e
    }
    ), {})
}
const key = Symbol("multiAbtest")
  , getMultiAbtestFromContext = e => {
    var t, n;
    return parseAbtestHeader(null != (n = null == (t = e.headers) ? void 0 : t["kgateway-multi-abtest"]) ? n : "")
}
  , provideAbtest = (e, t) => {
    let n, r;
    t ? (n = t.kgatewayAbtest,
    r = getMultiAbtestFromContext(t)) : n = null == api ? void 0 : api.get("kGateway-abTest");
    const o = {
        singleResult: n,
        multiResult: r
    };
    return e.provide(key, o),
    o
}
  , useAbtest = e => {
    const t = inject(key);
    return null == t ? void 0 : t.singleResult
}
;
function createAppInjectionState(e) {
    const t = Symbol("InjectionState");
    return [ (n, ...r) => {
        const o = e(...r);
        return n.provide(t, o),
        o
    }
    , () => {
        var e, n;
        if ("true" === (null == (n = null == (e = null) ? void 0 : e.env) ? void 0 : n.VITE_SSG))
            throw new Error("不可在 SSG Setup 阶段时使用 @pex/ug-ssr-server hooks，请在 onMounted 中执行");
        return inject(t)
    }
    ]
}
const [provideCookies,useCookies] = createAppInjectionState((e => e ? e.cookies : api))
  , [provideEnv,useEnv] = createAppInjectionState((e => e ? e.env : window.__ENV__))
  , TagsWithInnerContent = new Set(["title", "titleTemplate", "script", "style", "noscript"])
  , HasElementTags = new Set(["base", "meta", "link", "style", "script", "noscript"])
  , ValidHeadTags = new Set(["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"])
  , UniqueTags = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"])
  , TagConfigKeys = new Set(["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"])
  , IsBrowser = "undefined" != typeof window;
function defineHeadPlugin(e) {
    return e
}
function hashCode(e) {
    let t = 9;
    for (let n = 0; n < e.length; )
        t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9);
    return (65536 + (t ^ t >>> 9)).toString(16).substring(1, 8).toLowerCase()
}
function hashTag(e) {
    if (e._h)
        return e._h;
    if (e._d)
        return hashCode(e._d);
    let t = "".concat(e.tag, ":").concat(e.textContent || e.innerHTML || "", ":");
    for (const n in e.props)
        t += "".concat(n, ":").concat(String(e.props[n]), ",");
    return hashCode(t)
}
function thenable(e, t) {
    return e instanceof Promise ? e.then(t) : t(e)
}
function normaliseTag(e, t, n, r) {
    const o = r || normaliseProps("object" != typeof t || "function" == typeof t || t instanceof Promise ? {
        ["script" === e || "noscript" === e || "style" === e ? "innerHTML" : "textContent"]: t
    } : {
        ...t
    }, "templateParams" === e || "titleTemplate" === e);
    if (o instanceof Promise)
        return o.then((r => normaliseTag(e, t, n, r)));
    const i = {
        tag: e,
        props: o
    };
    for (const a of TagConfigKeys) {
        const e = void 0 !== i.props[a] ? i.props[a] : n[a];
        void 0 !== e && (("innerHTML" !== a && "textContent" !== a && "children" !== a || TagsWithInnerContent.has(i.tag)) && (i["children" === a ? "innerHTML" : a] = e),
        delete i.props[a])
    }
    return i.props.body && (i.tagPosition = "bodyClose",
    delete i.props.body),
    "script" === i.tag && "object" == typeof i.innerHTML && (i.innerHTML = JSON.stringify(i.innerHTML),
    i.props.type = i.props.type || "application/json"),
    Array.isArray(i.props.content) ? i.props.content.map((e => ({
        ...i,
        props: {
            ...i.props,
            content: e
        }
    }))) : i
}
function normaliseStyleClassProps(e, t) {
    var n;
    const r = "class" === e ? " " : ";";
    return t && "object" == typeof t && !Array.isArray(t) && (t = Object.entries(t).filter(( ([,e]) => e)).map(( ([t,n]) => "style" === e ? "".concat(t, ":").concat(n) : t))),
    null == (n = String(Array.isArray(t) ? t.join(r) : t)) ? void 0 : n.split(r).filter((e => Boolean(e.trim()))).join(r)
}
function nestedNormaliseProps(e, t, n, r) {
    for (let o = r; o < n.length; o += 1) {
        const r = n[o];
        if ("class" !== r && "style" !== r) {
            if (e[r]instanceof Promise)
                return e[r].then((i => (e[r] = i,
                nestedNormaliseProps(e, t, n, o))));
            if (!t && !TagConfigKeys.has(r)) {
                const t = String(e[r])
                  , n = r.startsWith("data-");
                "true" === t || "" === t ? e[r] = !n || "true" : e[r] || (n && "false" === t ? e[r] = "false" : delete e[r])
            }
        } else
            e[r] = normaliseStyleClassProps(r, e[r])
    }
}
function normaliseProps(e, t=!1) {
    const n = nestedNormaliseProps(e, t, Object.keys(e), 0);
    return n instanceof Promise ? n.then(( () => e)) : e
}
const TagEntityBits = 10;
function nestedNormaliseEntryTags(e, t, n) {
    for (let r = n; r < t.length; r += 1) {
        const n = t[r];
        if (n instanceof Promise)
            return n.then((n => (t[r] = n,
            nestedNormaliseEntryTags(e, t, r))));
        Array.isArray(n) ? e.push(...n) : e.push(n)
    }
}
function normaliseEntryTags(e) {
    const t = []
      , n = e.resolvedInput;
    for (const o in n) {
        if (!Object.prototype.hasOwnProperty.call(n, o))
            continue;
        const r = n[o];
        if (void 0 !== r && ValidHeadTags.has(o))
            if (Array.isArray(r))
                for (const n of r)
                    t.push(normaliseTag(o, n, e));
            else
                t.push(normaliseTag(o, r, e))
    }
    if (0 === t.length)
        return [];
    const r = [];
    return thenable(nestedNormaliseEntryTags(r, t, 0), ( () => r.map(( (t, n) => (t._e = e._i,
    e.mode && (t._m = e.mode),
    t._p = (e._i << TagEntityBits) + n,
    t)))))
}
const NetworkEvents = new Set(["onload", "onerror", "onabort", "onprogress", "onloadstart"])
  , TAG_WEIGHTS = {
    base: -10,
    title: 10
}
  , TAG_ALIASES = {
    critical: -80,
    high: -10,
    low: 20
};
function tagWeight(e) {
    const t = e.tagPriority;
    if ("number" == typeof t)
        return t;
    let n = 100;
    return "meta" === e.tag ? "content-security-policy" === e.props["http-equiv"] ? n = -30 : e.props.charset ? n = -20 : "viewport" === e.props.name && (n = -15) : "link" === e.tag && "preconnect" === e.props.rel ? n = 20 : e.tag in TAG_WEIGHTS && (n = TAG_WEIGHTS[e.tag]),
    t && t in TAG_ALIASES ? n + TAG_ALIASES[t] : n
}
const SortModifiers = [{
    prefix: "before:",
    offset: -1
}, {
    prefix: "after:",
    offset: 1
}]
  , allowedMetaProperties = ["name", "property", "http-equiv"];
function tagDedupeKey(e) {
    const {props: t, tag: n} = e;
    if (UniqueTags.has(n))
        return n;
    if ("link" === n && "canonical" === t.rel)
        return "canonical";
    if (t.charset)
        return "charset";
    if (t.id)
        return "".concat(n, ":id:").concat(t.id);
    for (const r of allowedMetaProperties)
        if (void 0 !== t[r])
            return "".concat(n, ":").concat(r, ":").concat(t[r]);
    return !1
}
const sepSub = "%separator";
function sub(e, t) {
    var n;
    let r;
    if ("s" === t || "pageTitle" === t)
        r = e.pageTitle;
    else if (t.includes(".")) {
        const o = t.indexOf(".");
        r = null == (n = e[t.substring(0, o)]) ? void 0 : n[t.substring(o + 1)]
    } else
        r = e[t];
    return void 0 !== r ? (r || "").replace(/"/g, '\\"') : void 0
}
const sepSubRe = new RegExp("".concat(sepSub, "(?:\\s*").concat(sepSub, ")*"),"g");
function processTemplateParams(e, t, n) {
    if ("string" != typeof e || !e.includes("%"))
        return e;
    let r = e;
    try {
        r = decodeURI(e)
    } catch (e2) {}
    const o = r.match(/%\w+(?:\.\w+)?/g);
    if (!o)
        return e;
    const i = e.includes(sepSub);
    return e = e.replace(/%\w+(?:\.\w+)?/g, (e => {
        if (e === sepSub || !o.includes(e))
            return e;
        const n = sub(t, e.slice(1));
        return void 0 !== n ? n : e
    }
    )).trim(),
    i && (e.endsWith(sepSub) && (e = e.slice(0, -sepSub.length)),
    e.startsWith(sepSub) && (e = e.slice(sepSub.length)),
    e = e.replace(sepSubRe, n).trim()),
    e
}
function resolveTitleTemplate(e, t) {
    return null == e ? t || null : "function" == typeof e ? e(t) : e
}
async function renderDOMHead(e, t={}) {
    const n = t.document || e.resolvedOptions.document;
    if (!n || !e.dirty)
        return;
    const r = {
        shouldRender: !0,
        tags: []
    };
    return await e.hooks.callHook("dom:beforeRender", r),
    r.shouldRender ? (e._domUpdatePromise || (e._domUpdatePromise = new Promise((async t => {
        var r;
        const o = (await e.resolveTags()).map((e => ({
            tag: e,
            id: HasElementTags.has(e.tag) ? hashTag(e) : e.tag,
            shouldRender: !0
        })));
        let i = e._dom;
        if (!i) {
            i = {
                elMap: {
                    htmlAttrs: n.documentElement,
                    bodyAttrs: n.body
                }
            };
            const e = new Set;
            for (const t of ["body", "head"]) {
                const o = null == (r = n[t]) ? void 0 : r.children;
                for (const t of o) {
                    const n = t.tagName.toLowerCase();
                    if (!HasElementTags.has(n))
                        continue;
                    const r = {
                        tag: n,
                        props: await normaliseProps(t.getAttributeNames().reduce(( (e, n) => ({
                            ...e,
                            [n]: t.getAttribute(n)
                        })), {})),
                        innerHTML: t.innerHTML
                    }
                      , o = tagDedupeKey(r);
                    let a = o
                      , s = 1;
                    for (; a && e.has(a); )
                        a = "".concat(o, ":").concat(s++);
                    a && (r._d = a,
                    e.add(a)),
                    i.elMap[t.getAttribute("data-hid") || hashTag(r)] = t
                }
            }
        }
        function a(e, t, n) {
            const r = "".concat(e, ":").concat(t);
            i.sideEffects[r] = n,
            delete i.pendingSideEffects[r]
        }
        function s({id: e, $el: t, tag: r}) {
            const o = r.tag.endsWith("Attrs");
            if (i.elMap[e] = t,
            o || (r.textContent && r.textContent !== t.textContent && (t.textContent = r.textContent),
            r.innerHTML && r.innerHTML !== t.innerHTML && (t.innerHTML = r.innerHTML),
            a(e, "el", ( () => {
                var t;
                null == (t = i.elMap[e]) || t.remove(),
                delete i.elMap[e]
            }
            ))),
            r._eventHandlers)
                for (const i in r._eventHandlers)
                    Object.prototype.hasOwnProperty.call(r._eventHandlers, i) && "" !== t.getAttribute("data-".concat(i)) && (("bodyAttrs" === r.tag ? n.defaultView : t).addEventListener(i.substring(2), r._eventHandlers[i].bind(t)),
                    t.setAttribute("data-".concat(i), ""));
            for (const n in r.props) {
                if (!Object.prototype.hasOwnProperty.call(r.props, n))
                    continue;
                const i = r.props[n]
                  , s = "attr:".concat(n);
                if ("class" === n) {
                    if (!i)
                        continue;
                    for (const n of i.split(" "))
                        o && a(e, "".concat(s, ":").concat(n), ( () => t.classList.remove(n))),
                        !t.classList.contains(n) && t.classList.add(n)
                } else if ("style" === n) {
                    if (!i)
                        continue;
                    for (const n of i.split(";")) {
                        const r = n.indexOf(":")
                          , o = n.substring(0, r).trim()
                          , i = n.substring(r + 1).trim();
                        a(e, "".concat(s, ":").concat(o), ( () => {
                            t.style.removeProperty(o)
                        }
                        )),
                        t.style.setProperty(o, i)
                    }
                } else
                    t.getAttribute(n) !== i && t.setAttribute(n, !0 === i ? "" : String(i)),
                    o && a(e, s, ( () => t.removeAttribute(n)))
            }
        }
        i.pendingSideEffects = {
            ...i.sideEffects
        },
        i.sideEffects = {};
        const c = []
          , l = {
            bodyClose: void 0,
            bodyOpen: void 0,
            head: void 0
        };
        for (const e of o) {
            const {tag: t, shouldRender: r, id: o} = e;
            r && ("title" !== t.tag ? (e.$el = e.$el || i.elMap[o],
            e.$el ? s(e) : HasElementTags.has(t.tag) && c.push(e)) : n.title = t.textContent)
        }
        for (const e of c) {
            const t = e.tag.tagPosition || "head";
            e.$el = n.createElement(e.tag.tag),
            s(e),
            l[t] = l[t] || n.createDocumentFragment(),
            l[t].appendChild(e.$el)
        }
        for (const u of o)
            await e.hooks.callHook("dom:renderTag", u, n, a);
        l.head && n.head.appendChild(l.head),
        l.bodyOpen && n.body.insertBefore(l.bodyOpen, n.body.firstChild),
        l.bodyClose && n.body.appendChild(l.bodyClose);
        for (const e in i.pendingSideEffects)
            i.pendingSideEffects[e]();
        e._dom = i,
        await e.hooks.callHook("dom:rendered", {
            renders: o
        }),
        t()
    }
    )).finally(( () => {
        e._domUpdatePromise = void 0,
        e.dirty = !1
    }
    ))),
    e._domUpdatePromise) : void 0
}
function debouncedRenderDOMHead(e, t={}) {
    const n = t.delayFn || (e => setTimeout(e, 10));
    return e._domDebouncedUpdatePromise = e._domDebouncedUpdatePromise || new Promise((r => n(( () => renderDOMHead(e, t).then(( () => {
        delete e._domDebouncedUpdatePromise,
        r()
    }
    ))))))
}
function DomPlugin(e) {
    return defineHeadPlugin((t => {
        var n, r;
        const o = (null == (r = null == (n = t.resolvedOptions.document) ? void 0 : n.head.querySelector('script[id="unhead:payload"]')) ? void 0 : r.innerHTML) || !1;
        return o && t.push(JSON.parse(o)),
        {
            mode: "client",
            hooks: {
                "entries:updated": t => {
                    debouncedRenderDOMHead(t, e)
                }
            }
        }
    }
    ))
}
function flatHooks(e, t={}, n) {
    for (const r in e) {
        const o = e[r]
          , i = n ? "".concat(n, ":").concat(r) : r;
        "object" == typeof o && null !== o ? flatHooks(o, t, i) : "function" == typeof o && (t[i] = o)
    }
    return t
}
const defaultTask = {
    run: e => e()
}
  , _createTask = () => defaultTask
  , createTask = void 0 !== console.createTask ? console.createTask : _createTask;
function serialTaskCaller(e, t) {
    const n = t.shift()
      , r = createTask(n);
    return e.reduce(( (e, n) => e.then(( () => r.run(( () => n(...t)))))), Promise.resolve())
}
function parallelTaskCaller(e, t) {
    const n = t.shift()
      , r = createTask(n);
    return Promise.all(e.map((e => r.run(( () => e(...t))))))
}
function callEachWith(e, t) {
    for (const n of [...e])
        n(t)
}
class Hookable {
    constructor() {
        this._hooks = {},
        this._before = void 0,
        this._after = void 0,
        this._deprecatedMessages = void 0,
        this._deprecatedHooks = {},
        this.hook = this.hook.bind(this),
        this.callHook = this.callHook.bind(this),
        this.callHookWith = this.callHookWith.bind(this)
    }
    hook(e, t, n={}) {
        if (!e || "function" != typeof t)
            return () => {}
            ;
        const r = e;
        let o;
        for (; this._deprecatedHooks[e]; )
            o = this._deprecatedHooks[e],
            e = o.to;
        if (o && !n.allowDeprecated) {
            let e = o.message;
            e || (e = "".concat(r, " hook has been deprecated") + (o.to ? ", please use ".concat(o.to) : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(e) || (console.warn(e),
            this._deprecatedMessages.add(e))
        }
        if (!t.name)
            try {
                Object.defineProperty(t, "name", {
                    get: () => "_" + e.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch (e2) {}
        return this._hooks[e] = this._hooks[e] || [],
        this._hooks[e].push(t),
        () => {
            t && (this.removeHook(e, t),
            t = void 0)
        }
    }
    hookOnce(e, t) {
        let n, r = (...e) => ("function" == typeof n && n(),
        n = void 0,
        r = void 0,
        t(...e));
        return n = this.hook(e, r),
        n
    }
    removeHook(e, t) {
        if (this._hooks[e]) {
            const n = this._hooks[e].indexOf(t);
            -1 !== n && this._hooks[e].splice(n, 1),
            0 === this._hooks[e].length && delete this._hooks[e]
        }
    }
    deprecateHook(e, t) {
        this._deprecatedHooks[e] = "string" == typeof t ? {
            to: t
        } : t;
        const n = this._hooks[e] || [];
        delete this._hooks[e];
        for (const r of n)
            this.hook(e, r)
    }
    deprecateHooks(e) {
        Object.assign(this._deprecatedHooks, e);
        for (const t in e)
            this.deprecateHook(t, e[t])
    }
    addHooks(e) {
        const t = flatHooks(e)
          , n = Object.keys(t).map((e => this.hook(e, t[e])));
        return () => {
            for (const e of n.splice(0, n.length))
                e()
        }
    }
    removeHooks(e) {
        const t = flatHooks(e);
        for (const n in t)
            this.removeHook(n, t[n])
    }
    removeAllHooks() {
        for (const e in this._hooks)
            delete this._hooks[e]
    }
    callHook(e, ...t) {
        return t.unshift(e),
        this.callHookWith(serialTaskCaller, e, ...t)
    }
    callHookParallel(e, ...t) {
        return t.unshift(e),
        this.callHookWith(parallelTaskCaller, e, ...t)
    }
    callHookWith(e, t, ...n) {
        const r = this._before || this._after ? {
            name: t,
            args: n,
            context: {}
        } : void 0;
        this._before && callEachWith(this._before, r);
        const o = e(t in this._hooks ? [...this._hooks[t]] : [], n);
        return o instanceof Promise ? o.finally(( () => {
            this._after && r && callEachWith(this._after, r)
        }
        )) : (this._after && r && callEachWith(this._after, r),
        o)
    }
    beforeEach(e) {
        return this._before = this._before || [],
        this._before.push(e),
        () => {
            if (void 0 !== this._before) {
                const t = this._before.indexOf(e);
                -1 !== t && this._before.splice(t, 1)
            }
        }
    }
    afterEach(e) {
        return this._after = this._after || [],
        this._after.push(e),
        () => {
            if (void 0 !== this._after) {
                const t = this._after.indexOf(e);
                -1 !== t && this._after.splice(t, 1)
            }
        }
    }
}
function createHooks() {
    return new Hookable
}
const UsesMergeStrategy = new Set(["templateParams", "htmlAttrs", "bodyAttrs"])
  , DedupePlugin = defineHeadPlugin({
    hooks: {
        "tag:normalise": ({tag: e}) => {
            e.props.hid && (e.key = e.props.hid,
            delete e.props.hid),
            e.props.vmid && (e.key = e.props.vmid,
            delete e.props.vmid),
            e.props.key && (e.key = e.props.key,
            delete e.props.key);
            const t = tagDedupeKey(e);
            !t || t.startsWith("meta:og:") || t.startsWith("meta:twitter:") || delete e.key;
            const n = t || !!e.key && "".concat(e.tag, ":").concat(e.key);
            n && (e._d = n)
        }
        ,
        "tags:resolve": e => {
            const t = Object.create(null);
            for (const r of e.tags) {
                const e = (r.key ? "".concat(r.tag, ":").concat(r.key) : r._d) || hashTag(r)
                  , n = t[e];
                if (n) {
                    let o = null == r ? void 0 : r.tagDuplicateStrategy;
                    if (!o && UsesMergeStrategy.has(r.tag) && (o = "merge"),
                    "merge" === o) {
                        const o = n.props;
                        o.style && r.props.style && (";" !== o.style[o.style.length - 1] && (o.style += ";"),
                        r.props.style = "".concat(o.style, " ").concat(r.props.style)),
                        o.class && r.props.class ? r.props.class = "".concat(o.class, " ").concat(r.props.class) : o.class && (r.props.class = o.class),
                        t[e].props = {
                            ...o,
                            ...r.props
                        };
                        continue
                    }
                    if (r._e === n._e) {
                        n._duped = n._duped || [],
                        r._d = "".concat(n._d, ":").concat(n._duped.length + 1),
                        n._duped.push(r);
                        continue
                    }
                    if (tagWeight(r) > tagWeight(n))
                        continue
                }
                r.innerHTML || r.textContent || 0 !== Object.keys(r.props).length || !HasElementTags.has(r.tag) ? t[e] = r : delete t[e]
            }
            const n = [];
            for (const r in t) {
                const e = t[r]
                  , o = e._duped;
                n.push(e),
                o && (delete e._duped,
                n.push(...o))
            }
            e.tags = n,
            e.tags = e.tags.filter((e => !("meta" === e.tag && (e.props.name || e.props.property) && !e.props.content)))
        }
    }
})
  , ValidEventTags = new Set(["script", "link", "bodyAttrs"])
  , EventHandlersPlugin = defineHeadPlugin((e => ({
    hooks: {
        "tags:resolve": t => {
            for (const n of t.tags) {
                if (!ValidEventTags.has(n.tag))
                    continue;
                const t = n.props;
                for (const r in t) {
                    if ("o" !== r[0] || "n" !== r[1])
                        continue;
                    if (!Object.prototype.hasOwnProperty.call(t, r))
                        continue;
                    const o = t[r];
                    "function" == typeof o && (e.ssr && NetworkEvents.has(r) ? t[r] = "this.dataset.".concat(r, "fired = true") : delete t[r],
                    n._eventHandlers = n._eventHandlers || {},
                    n._eventHandlers[r] = o)
                }
                e.ssr && n._eventHandlers && (n.props.src || n.props.href) && (n.key = n.key || hashCode(n.props.src || n.props.href))
            }
        }
        ,
        "dom:renderTag": ({$el: e, tag: t}) => {
            var n, r;
            const o = null == e ? void 0 : e.dataset;
            if (o)
                for (const i in o) {
                    if (!i.endsWith("fired"))
                        continue;
                    const o = i.slice(0, -5);
                    NetworkEvents.has(o) && (null == (r = null == (n = t._eventHandlers) ? void 0 : n[o]) || r.call(e, new Event(o.substring(2))))
                }
        }
    }
})))
  , DupeableTags = new Set(["link", "style", "script", "noscript"])
  , HashKeyedPlugin = defineHeadPlugin({
    hooks: {
        "tag:normalise": ({tag: e}) => {
            e.key && DupeableTags.has(e.tag) && (e.props["data-hid"] = e._h = hashCode(e.key))
        }
    }
})
  , PayloadPlugin = defineHeadPlugin({
    mode: "server",
    hooks: {
        "tags:beforeResolve": e => {
            const t = {};
            let n = !1;
            for (const r of e.tags)
                "server" !== r._m || "titleTemplate" !== r.tag && "templateParams" !== r.tag && "title" !== r.tag || (t[r.tag] = "title" === r.tag || "titleTemplate" === r.tag ? r.textContent : r.props,
                n = !0);
            n && e.tags.push({
                tag: "script",
                innerHTML: JSON.stringify(t),
                props: {
                    id: "unhead:payload",
                    type: "application/json"
                }
            })
        }
    }
})
  , SortPlugin = defineHeadPlugin({
    hooks: {
        "tags:resolve": e => {
            var t;
            for (const n of e.tags)
                if ("string" == typeof n.tagPriority)
                    for (const {prefix: r, offset: o} of SortModifiers) {
                        if (!n.tagPriority.startsWith(r))
                            continue;
                        const i = n.tagPriority.substring(r.length)
                          , a = null == (t = e.tags.find((e => e._d === i))) ? void 0 : t._p;
                        if (void 0 !== a) {
                            n._p = a + o;
                            break
                        }
                    }
            e.tags.sort(( (e, t) => {
                const n = tagWeight(e)
                  , r = tagWeight(t);
                return n < r ? -1 : n > r ? 1 : e._p - t._p
            }
            ))
        }
    }
})
  , SupportedAttrs = {
    meta: "content",
    link: "href",
    htmlAttrs: "lang"
}
  , contentAttrs = ["innerHTML", "textContent"]
  , TemplateParamsPlugin = defineHeadPlugin((e => ({
    hooks: {
        "tags:resolve": t => {
            var n;
            const {tags: r} = t;
            let o;
            for (let e = 0; e < r.length; e += 1) {
                "templateParams" === r[e].tag && (o = t.tags.splice(e, 1)[0].props,
                e -= 1)
            }
            const i = o || {}
              , a = i.separator || "|";
            delete i.separator,
            i.pageTitle = processTemplateParams(i.pageTitle || (null == (n = r.find((e => "title" === e.tag))) ? void 0 : n.textContent) || "", i, a);
            for (const e of r) {
                if (!1 === e.processTemplateParams)
                    continue;
                const t = SupportedAttrs[e.tag];
                if (t && "string" == typeof e.props[t])
                    e.props[t] = processTemplateParams(e.props[t], i, a);
                else if (e.processTemplateParams || "titleTemplate" === e.tag || "title" === e.tag)
                    for (const n of contentAttrs)
                        "string" == typeof e[n] && (e[n] = processTemplateParams(e[n], i, a))
            }
            e._templateParams = i,
            e._separator = a
        }
        ,
        "tags:afterResolve": ({tags: t}) => {
            let n;
            for (let e = 0; e < t.length; e += 1) {
                const r = t[e];
                "title" === r.tag && !1 !== r.processTemplateParams && (n = r)
            }
            (null == n ? void 0 : n.textContent) && (n.textContent = processTemplateParams(n.textContent, e._templateParams, e._separator))
        }
    }
})))
  , TitleTemplatePlugin = defineHeadPlugin({
    hooks: {
        "tags:resolve": e => {
            const {tags: t} = e;
            let n, r;
            for (let o = 0; o < t.length; o += 1) {
                const e = t[o];
                "title" === e.tag ? n = e : "titleTemplate" === e.tag && (r = e)
            }
            if (r && n) {
                const t = resolveTitleTemplate(r.textContent, n.textContent);
                null !== t ? n.textContent = t || n.textContent : e.tags.splice(e.tags.indexOf(n), 1)
            } else if (r) {
                const e = resolveTitleTemplate(r.textContent);
                null !== e && (r.textContent = e,
                r.tag = "title",
                r = void 0)
            }
            r && e.tags.splice(e.tags.indexOf(r), 1)
        }
    }
})
  , XSSPlugin = defineHeadPlugin({
    hooks: {
        "tags:afterResolve": e => {
            for (const t of e.tags)
                "string" == typeof t.innerHTML && (!t.innerHTML || "application/ld+json" !== t.props.type && "application/json" !== t.props.type ? t.innerHTML = t.innerHTML.replace(new RegExp("</".concat(t.tag),"g"), "<\\/".concat(t.tag)) : t.innerHTML = t.innerHTML.replace(/</g, "\\u003C"))
        }
    }
});
let activeHead;
function createHead$1(e={}) {
    const t = createHeadCore(e);
    return t.use(DomPlugin()),
    activeHead = t
}
function filterMode(e, t) {
    return !e || "server" === e && t || "client" === e && !t
}
function createHeadCore(e={}) {
    const t = createHooks();
    t.addHooks(e.hooks || {}),
    e.document = e.document || (IsBrowser ? document : void 0);
    const n = !e.document
      , r = () => {
        s.dirty = !0,
        t.callHook("entries:updated", s)
    }
    ;
    let o = 0
      , i = [];
    const a = []
      , s = {
        plugins: a,
        dirty: !1,
        resolvedOptions: e,
        hooks: t,
        headEntries: () => i,
        use(e) {
            const r = "function" == typeof e ? e(s) : e;
            r.key && a.some((e => e.key === r.key)) || (a.push(r),
            filterMode(r.mode, n) && t.addHooks(r.hooks || {}))
        },
        push(e, t) {
            null == t || delete t.head;
            const a = {
                _i: o++,
                input: e,
                ...t
            };
            return filterMode(a.mode, n) && (i.push(a),
            r()),
            {
                dispose() {
                    i = i.filter((e => e._i !== a._i)),
                    r()
                },
                patch(e) {
                    for (const t of i)
                        t._i === a._i && (t.input = a.input = e);
                    r()
                }
            }
        },
        async resolveTags() {
            const e = {
                tags: [],
                entries: [...i]
            };
            await t.callHook("entries:resolve", e);
            for (const n of e.entries) {
                const r = n.resolvedInput || n.input;
                if (n.resolvedInput = await (n.transform ? n.transform(r) : r),
                n.resolvedInput)
                    for (const o of await normaliseEntryTags(n)) {
                        const r = {
                            tag: o,
                            entry: n,
                            resolvedOptions: s.resolvedOptions
                        };
                        await t.callHook("tag:normalise", r),
                        e.tags.push(r.tag)
                    }
            }
            return await t.callHook("tags:beforeResolve", e),
            await t.callHook("tags:resolve", e),
            await t.callHook("tags:afterResolve", e),
            e.tags
        },
        ssr: n
    };
    return [DedupePlugin, PayloadPlugin, EventHandlersPlugin, HashKeyedPlugin, SortPlugin, TemplateParamsPlugin, TitleTemplatePlugin, XSSPlugin, ...(null == e ? void 0 : e.plugins) || []].forEach((e => s.use(e))),
    s.hooks.callHook("init", s),
    s
}
function getActiveHead() {
    return activeHead
}
const Vue3 = "3" === version$1[0];
function resolveUnref(e) {
    return "function" == typeof e ? e() : unref(e)
}
function resolveUnrefHeadInput(e) {
    if (e instanceof Promise || e instanceof Date || e instanceof RegExp)
        return e;
    const t = resolveUnref(e);
    if (!e || !t)
        return t;
    if (Array.isArray(t))
        return t.map((e => resolveUnrefHeadInput(e)));
    if ("object" == typeof t) {
        const e = {};
        for (const n in t)
            Object.prototype.hasOwnProperty.call(t, n) && ("titleTemplate" === n || "o" === n[0] && "n" === n[1] ? e[n] = unref(t[n]) : e[n] = resolveUnrefHeadInput(t[n]));
        return e
    }
    return t
}
const VueReactivityPlugin = defineHeadPlugin({
    hooks: {
        "entries:resolve": e => {
            for (const t of e.entries)
                t.resolvedInput = resolveUnrefHeadInput(t.input)
        }
    }
})
  , headSymbol = "usehead";
function vueInstall(e) {
    return {
        install(t) {
            Vue3 && (t.config.globalProperties.$unhead = e,
            t.config.globalProperties.$head = e,
            t.provide(headSymbol, e))
        }
    }.install
}
function createHead(e={}) {
    e.domDelayFn = e.domDelayFn || (e => nextTick(( () => setTimeout(( () => e()), 0))));
    const t = createHead$1(e);
    return t.use(VueReactivityPlugin),
    t.install = vueInstall(t),
    t
}
const _global = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}
  , globalKey = "__unhead_injection_handler__";
function injectHead() {
    if (globalKey in _global)
        return _global[globalKey]();
    const e = inject(headSymbol);
    return e || getActiveHead()
}
function useHead(e, t={}) {
    const n = t.head || injectHead();
    if (n)
        return n.ssr ? n.push(e, t) : clientUseHead(n, e, t)
}
function clientUseHead(e, t, n={}) {
    const r = ref(!1)
      , o = ref({});
    watchEffect(( () => {
        o.value = r.value ? {} : resolveUnrefHeadInput(t)
    }
    ));
    const i = e.push(o.value, n);
    watch(o, (e => {
        i.patch(e)
    }
    ));
    return getCurrentInstance() && (onBeforeUnmount(( () => {
        i.dispose()
    }
    )),
    onDeactivated(( () => {
        r.value = !0
    }
    )),
    onActivated(( () => {
        r.value = !1
    }
    ))),
    i
}
function provideHead(e) {
    const t = createHead();
    e.use(t)
}
const [provideKconf,useKconf] = createAppInjectionState((e => e ? e.kconf : window.__KCONF__))
  , [provideRedirect,useRedirect] = createAppInjectionState(( (e, t, n) => e ? (t.afterEach((n => {
    if (n.redirectedFrom) {
        const r = t.resolve(n).href;
        e.redirectTo = r
    }
}
)),
n => {
    const r = t.resolve(n).href;
    e.redirectTo = r
}
) : n))
  , [provideUserAgent,useUserAgent] = createAppInjectionState((e => e ? e.userAgent : window.navigator.userAgent))
  , [provideUrl,useUrl] = createAppInjectionState((e => e ? e.url : new URL(location.href)));
var dayjs_min = {
    exports: {}
};
dayjs_min.exports = function() {
    var e = 1e3
      , t = 6e4
      , n = 36e5
      , r = "millisecond"
      , o = "second"
      , i = "minute"
      , a = "hour"
      , s = "day"
      , c = "week"
      , l = "month"
      , u = "quarter"
      , p = "year"
      , d = "date"
      , f = "Invalid Date"
      , h = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
      , m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
      , g = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function(e) {
            var t = ["th", "st", "nd", "rd"]
              , n = e % 100;
            return "[" + e + (t[(n - 20) % 10] || t[n] || t[0]) + "]"
        }
    }
      , v = function(e, t, n) {
        var r = String(e);
        return !r || r.length >= t ? e : "" + Array(t + 1 - r.length).join(n) + e
    }
      , y = {
        s: v,
        z: function(e) {
            var t = -e.utcOffset()
              , n = Math.abs(t)
              , r = Math.floor(n / 60)
              , o = n % 60;
            return (t <= 0 ? "+" : "-") + v(r, 2, "0") + ":" + v(o, 2, "0")
        },
        m: function e(t, n) {
            if (t.date() < n.date())
                return -e(n, t);
            var r = 12 * (n.year() - t.year()) + (n.month() - t.month())
              , o = t.clone().add(r, l)
              , i = n - o < 0
              , a = t.clone().add(r + (i ? -1 : 1), l);
            return +(-(r + (n - o) / (i ? o - a : a - o)) || 0)
        },
        a: function(e) {
            return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
        },
        p: function(e) {
            return {
                M: l,
                y: p,
                w: c,
                d: s,
                D: d,
                h: a,
                m: i,
                s: o,
                ms: r,
                Q: u
            }[e] || String(e || "").toLowerCase().replace(/s$/, "")
        },
        u: function(e) {
            return void 0 === e
        }
    }
      , _ = "en"
      , b = {};
    b[_] = g;
    var E = "$isDayjsObject"
      , w = function(e) {
        return e instanceof A || !(!e || !e[E])
    }
      , S = function e(t, n, r) {
        var o;
        if (!t)
            return _;
        if ("string" == typeof t) {
            var i = t.toLowerCase();
            b[i] && (o = i),
            n && (b[i] = n,
            o = i);
            var a = t.split("-");
            if (!o && a.length > 1)
                return e(a[0])
        } else {
            var s = t.name;
            b[s] = t,
            o = s
        }
        return !r && o && (_ = o),
        o || !r && _
    }
      , O = function(e, t) {
        if (w(e))
            return e.clone();
        var n = "object" == typeof t ? t : {};
        return n.date = e,
        n.args = arguments,
        new A(n)
    }
      , T = y;
    T.l = S,
    T.i = w,
    T.w = function(e, t) {
        return O(e, {
            locale: t.$L,
            utc: t.$u,
            x: t.$x,
            $offset: t.$offset
        })
    }
    ;
    var A = function() {
        function g(e) {
            this.$L = S(e.locale, null, !0),
            this.parse(e),
            this.$x = this.$x || e.x || {},
            this[E] = !0
        }
        var v = g.prototype;
        return v.parse = function(e) {
            this.$d = function(e) {
                var t = e.date
                  , n = e.utc;
                if (null === t)
                    return new Date(NaN);
                if (T.u(t))
                    return new Date;
                if (t instanceof Date)
                    return new Date(t);
                if ("string" == typeof t && !/Z$/i.test(t)) {
                    var r = t.match(h);
                    if (r) {
                        var o = r[2] - 1 || 0
                          , i = (r[7] || "0").substring(0, 3);
                        return n ? new Date(Date.UTC(r[1], o, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, i)) : new Date(r[1],o,r[3] || 1,r[4] || 0,r[5] || 0,r[6] || 0,i)
                    }
                }
                return new Date(t)
            }(e),
            this.init()
        }
        ,
        v.init = function() {
            var e = this.$d;
            this.$y = e.getFullYear(),
            this.$M = e.getMonth(),
            this.$D = e.getDate(),
            this.$W = e.getDay(),
            this.$H = e.getHours(),
            this.$m = e.getMinutes(),
            this.$s = e.getSeconds(),
            this.$ms = e.getMilliseconds()
        }
        ,
        v.$utils = function() {
            return T
        }
        ,
        v.isValid = function() {
            return !(this.$d.toString() === f)
        }
        ,
        v.isSame = function(e, t) {
            var n = O(e);
            return this.startOf(t) <= n && n <= this.endOf(t)
        }
        ,
        v.isAfter = function(e, t) {
            return O(e) < this.startOf(t)
        }
        ,
        v.isBefore = function(e, t) {
            return this.endOf(t) < O(e)
        }
        ,
        v.$g = function(e, t, n) {
            return T.u(e) ? this[t] : this.set(n, e)
        }
        ,
        v.unix = function() {
            return Math.floor(this.valueOf() / 1e3)
        }
        ,
        v.valueOf = function() {
            return this.$d.getTime()
        }
        ,
        v.startOf = function(e, t) {
            var n = this
              , r = !!T.u(t) || t
              , u = T.p(e)
              , f = function(e, t) {
                var o = T.w(n.$u ? Date.UTC(n.$y, t, e) : new Date(n.$y,t,e), n);
                return r ? o : o.endOf(s)
            }
              , h = function(e, t) {
                return T.w(n.toDate()[e].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), n)
            }
              , m = this.$W
              , g = this.$M
              , v = this.$D
              , y = "set" + (this.$u ? "UTC" : "");
            switch (u) {
            case p:
                return r ? f(1, 0) : f(31, 11);
            case l:
                return r ? f(1, g) : f(0, g + 1);
            case c:
                var _ = this.$locale().weekStart || 0
                  , b = (m < _ ? m + 7 : m) - _;
                return f(r ? v - b : v + (6 - b), g);
            case s:
            case d:
                return h(y + "Hours", 0);
            case a:
                return h(y + "Minutes", 1);
            case i:
                return h(y + "Seconds", 2);
            case o:
                return h(y + "Milliseconds", 3);
            default:
                return this.clone()
            }
        }
        ,
        v.endOf = function(e) {
            return this.startOf(e, !1)
        }
        ,
        v.$set = function(e, t) {
            var n, c = T.p(e), u = "set" + (this.$u ? "UTC" : ""), f = (n = {},
            n[s] = u + "Date",
            n[d] = u + "Date",
            n[l] = u + "Month",
            n[p] = u + "FullYear",
            n[a] = u + "Hours",
            n[i] = u + "Minutes",
            n[o] = u + "Seconds",
            n[r] = u + "Milliseconds",
            n)[c], h = c === s ? this.$D + (t - this.$W) : t;
            if (c === l || c === p) {
                var m = this.clone().set(d, 1);
                m.$d[f](h),
                m.init(),
                this.$d = m.set(d, Math.min(this.$D, m.daysInMonth())).$d
            } else
                f && this.$d[f](h);
            return this.init(),
            this
        }
        ,
        v.set = function(e, t) {
            return this.clone().$set(e, t)
        }
        ,
        v.get = function(e) {
            return this[T.p(e)]()
        }
        ,
        v.add = function(r, u) {
            var d, f = this;
            r = Number(r);
            var h = T.p(u)
              , m = function(e) {
                var t = O(f);
                return T.w(t.date(t.date() + Math.round(e * r)), f)
            };
            if (h === l)
                return this.set(l, this.$M + r);
            if (h === p)
                return this.set(p, this.$y + r);
            if (h === s)
                return m(1);
            if (h === c)
                return m(7);
            var g = (d = {},
            d[i] = t,
            d[a] = n,
            d[o] = e,
            d)[h] || 1
              , v = this.$d.getTime() + r * g;
            return T.w(v, this)
        }
        ,
        v.subtract = function(e, t) {
            return this.add(-1 * e, t)
        }
        ,
        v.format = function(e) {
            var t = this
              , n = this.$locale();
            if (!this.isValid())
                return n.invalidDate || f;
            var r = e || "YYYY-MM-DDTHH:mm:ssZ"
              , o = T.z(this)
              , i = this.$H
              , a = this.$m
              , s = this.$M
              , c = n.weekdays
              , l = n.months
              , u = n.meridiem
              , p = function(e, n, o, i) {
                return e && (e[n] || e(t, r)) || o[n].slice(0, i)
            }
              , d = function(e) {
                return T.s(i % 12 || 12, e, "0")
            }
              , h = u || function(e, t, n) {
                var r = e < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r
            }
            ;
            return r.replace(m, (function(e, r) {
                return r || function(e) {
                    switch (e) {
                    case "YY":
                        return String(t.$y).slice(-2);
                    case "YYYY":
                        return T.s(t.$y, 4, "0");
                    case "M":
                        return s + 1;
                    case "MM":
                        return T.s(s + 1, 2, "0");
                    case "MMM":
                        return p(n.monthsShort, s, l, 3);
                    case "MMMM":
                        return p(l, s);
                    case "D":
                        return t.$D;
                    case "DD":
                        return T.s(t.$D, 2, "0");
                    case "d":
                        return String(t.$W);
                    case "dd":
                        return p(n.weekdaysMin, t.$W, c, 2);
                    case "ddd":
                        return p(n.weekdaysShort, t.$W, c, 3);
                    case "dddd":
                        return c[t.$W];
                    case "H":
                        return String(i);
                    case "HH":
                        return T.s(i, 2, "0");
                    case "h":
                        return d(1);
                    case "hh":
                        return d(2);
                    case "a":
                        return h(i, a, !0);
                    case "A":
                        return h(i, a, !1);
                    case "m":
                        return String(a);
                    case "mm":
                        return T.s(a, 2, "0");
                    case "s":
                        return String(t.$s);
                    case "ss":
                        return T.s(t.$s, 2, "0");
                    case "SSS":
                        return T.s(t.$ms, 3, "0");
                    case "Z":
                        return o
                    }
                    return null
                }(e) || o.replace(":", "")
            }
            ))
        }
        ,
        v.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
        }
        ,
        v.diff = function(r, d, f) {
            var h, m = this, g = T.p(d), v = O(r), y = (v.utcOffset() - this.utcOffset()) * t, _ = this - v, b = function() {
                return T.m(m, v)
            };
            switch (g) {
            case p:
                h = b() / 12;
                break;
            case l:
                h = b();
                break;
            case u:
                h = b() / 3;
                break;
            case c:
                h = (_ - y) / 6048e5;
                break;
            case s:
                h = (_ - y) / 864e5;
                break;
            case a:
                h = _ / n;
                break;
            case i:
                h = _ / t;
                break;
            case o:
                h = _ / e;
                break;
            default:
                h = _
            }
            return f ? h : T.a(h)
        }
        ,
        v.daysInMonth = function() {
            return this.endOf(l).$D
        }
        ,
        v.$locale = function() {
            return b[this.$L]
        }
        ,
        v.locale = function(e, t) {
            if (!e)
                return this.$L;
            var n = this.clone()
              , r = S(e, t, !0);
            return r && (n.$L = r),
            n
        }
        ,
        v.clone = function() {
            return T.w(this.$d, this)
        }
        ,
        v.toDate = function() {
            return new Date(this.valueOf())
        }
        ,
        v.toJSON = function() {
            return this.isValid() ? this.toISOString() : null
        }
        ,
        v.toISOString = function() {
            return this.$d.toISOString()
        }
        ,
        v.toString = function() {
            return this.$d.toUTCString()
        }
        ,
        g
    }()
      , R = A.prototype;
    return O.prototype = R,
    [["$ms", r], ["$s", o], ["$m", i], ["$H", a], ["$W", s], ["$M", l], ["$y", p], ["$D", d]].forEach((function(e) {
        R[e[1]] = function(t) {
            return this.$g(t, e[0], e[1])
        }
    }
    )),
    O.extend = function(e, t) {
        return e.$i || (e(t, A, O),
        e.$i = !0),
        O
    }
    ,
    O.locale = S,
    O.isDayjs = w,
    O.unix = function(e) {
        return O(1e3 * e)
    }
    ,
    O.en = b[_],
    O.Ls = b,
    O.p = {},
    O
}();
var dayjs_minExports = dayjs_min.exports;
const dayjs = getDefaultExportFromCjs(dayjs_minExports);
var relativeTime$1 = {
    exports: {}
};
relativeTime$1.exports = function(e, t, n) {
    e = e || {};
    var r = t.prototype
      , o = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function i(e, t, n, o) {
        return r.fromToBase(e, t, n, o)
    }
    n.en.relativeTime = o,
    r.fromToBase = function(t, r, i, a, s) {
        for (var c, l, u, p = i.$locale().relativeTime || o, d = e.thresholds || [{
            l: "s",
            r: 44,
            d: "second"
        }, {
            l: "m",
            r: 89
        }, {
            l: "mm",
            r: 44,
            d: "minute"
        }, {
            l: "h",
            r: 89
        }, {
            l: "hh",
            r: 21,
            d: "hour"
        }, {
            l: "d",
            r: 35
        }, {
            l: "dd",
            r: 25,
            d: "day"
        }, {
            l: "M",
            r: 45
        }, {
            l: "MM",
            r: 10,
            d: "month"
        }, {
            l: "y",
            r: 17
        }, {
            l: "yy",
            d: "year"
        }], f = d.length, h = 0; h < f; h += 1) {
            var m = d[h];
            m.d && (c = a ? n(t).diff(i, m.d, !0) : i.diff(t, m.d, !0));
            var g = (e.rounding || Math.round)(Math.abs(c));
            if (u = c > 0,
            g <= m.r || !m.r) {
                g <= 1 && h > 0 && (m = d[h - 1]);
                var v = p[m.l];
                s && (g = s("" + g)),
                l = "string" == typeof v ? v.replace("%d", g) : v(g, r, m.l, u);
                break
            }
        }
        if (r)
            return l;
        var y = u ? p.future : p.past;
        return "function" == typeof y ? y(l) : y.replace("%s", l)
    }
    ,
    r.to = function(e, t) {
        return i(e, t, this, !0)
    }
    ,
    r.from = function(e, t) {
        return i(e, t, this)
    }
    ;
    var a = function(e) {
        return e.$u ? n.utc() : n()
    };
    r.toNow = function(e) {
        return this.to(a(this), e)
    }
    ,
    r.fromNow = function(e) {
        return this.from(a(this), e)
    }
}
;
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = getDefaultExportFromCjs(relativeTimeExports);
function _typeof(e) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    )(e)
}
function _arrayLikeToArray$1(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function _arrayWithoutHoles(e) {
    if (Array.isArray(e))
        return _arrayLikeToArray$1(e)
}
function _iterableToArray(e) {
    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
        return Array.from(e)
}
function _unsupportedIterableToArray$1(e, t) {
    if (e) {
        if ("string" == typeof e)
            return _arrayLikeToArray$1(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name),
        "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray$1(e, t) : void 0
    }
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}
function _toConsumableArray(e) {
    return _arrayWithoutHoles(e) || _iterableToArray(e) || _unsupportedIterableToArray$1(e) || _nonIterableSpread()
}
function asyncGeneratorStep(e, t, n, r, o, i, a) {
    try {
        var s = e[i](a)
          , c = s.value
    } catch (l) {
        return void n(l)
    }
    s.done ? t(c) : Promise.resolve(c).then(r, o)
}
function _asyncToGenerator(e) {
    return function() {
        var t = this
          , n = arguments;
        return new Promise((function(r, o) {
            var i = e.apply(t, n);
            function a(e) {
                asyncGeneratorStep(i, r, o, a, s, "next", e)
            }
            function s(e) {
                asyncGeneratorStep(i, r, o, a, s, "throw", e)
            }
            a(void 0)
        }
        ))
    }
}
function _classCallCheck(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function toPrimitive(e, t) {
    if ("object" != _typeof(e) || !e)
        return e;
    var n = e[Symbol.toPrimitive];
    if (void 0 !== n) {
        var r = n.call(e, t || "default");
        if ("object" != _typeof(r))
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return ("string" === t ? String : Number)(e)
}
function toPropertyKey(e) {
    var t = toPrimitive(e, "string");
    return "symbol" == _typeof(t) ? t : t + ""
}
function _defineProperties(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(e, toPropertyKey(r.key), r)
    }
}
function _createClass(e, t, n) {
    return t && _defineProperties(e.prototype, t),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
function _defineProperty(e, t, n) {
    return (t = toPropertyKey(t))in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function _arrayWithHoles(e) {
    if (Array.isArray(e))
        return e
}
function _iterableToArrayLimit(e, t) {
    var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (null != n) {
        var r, o, i, a, s = [], c = !0, l = !1;
        try {
            if (i = (n = n.call(e)).next,
            0 === t)
                ;
            else
                for (; !(c = (r = i.call(n)).done) && (s.push(r.value),
                s.length !== t); c = !0)
                    ;
        } catch (u) {
            l = !0,
            o = u
        } finally {
            try {
                if (!c && null != n.return && (a = n.return(),
                Object(a) !== a))
                    return
            } finally {
                if (l)
                    throw o
            }
        }
        return s
    }
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}
function _slicedToArray(e, t) {
    return _arrayWithHoles(e) || _iterableToArrayLimit(e, t) || _unsupportedIterableToArray$1(e, t) || _nonIterableRest()
}
var Op = Object.prototype, hasOwn = Op.hasOwnProperty, undefined$1, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
function wrap(e, t, n, r) {
    var o = t && t.prototype instanceof Generator ? t : Generator
      , i = Object.create(o.prototype)
      , a = new Context(r || []);
    return i._invoke = makeInvokeMethod(e, n, a),
    i
}
function tryCatch(e, t, n) {
    try {
        return {
            type: "normal",
            arg: e.call(t, n)
        }
    } catch (r) {
        return {
            type: "throw",
            arg: r
        }
    }
}
var GenStateSuspendedStart = "suspendedStart"
  , GenStateSuspendedYield = "suspendedYield"
  , GenStateExecuting = "executing"
  , GenStateCompleted = "completed"
  , ContinueSentinel = {};
function Generator() {}
function GeneratorFunction() {}
function GeneratorFunctionPrototype() {}
var IteratorPrototype = {};
IteratorPrototype[iteratorSymbol] = function() {
    return this
}
;
var getProto = Object.getPrototypeOf
  , NativeIteratorPrototype = getProto && getProto(getProto(values([])));
NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
function defineIteratorMethods(e) {
    ["next", "throw", "return"].forEach((function(t) {
        e[t] = function(e) {
            return this._invoke(t, e)
        }
    }
    ))
}
function isGeneratorFunction(e) {
    var t = "function" == typeof e && e.constructor;
    return !!t && (t === GeneratorFunction || "GeneratorFunction" === (t.displayName || t.name))
}
function mark(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype,
    toStringTagSymbol in e || (e[toStringTagSymbol] = "GeneratorFunction")),
    e.prototype = Object.create(Gp),
    e
}
function awrap(e) {
    return {
        __await: e
    }
}
function AsyncIterator$1(e, t) {
    function n(r, o, i, a) {
        var s = tryCatch(e[r], e, o);
        if ("throw" !== s.type) {
            var c = s.arg
              , l = c.value;
            return l && "object" === _typeof(l) && hasOwn.call(l, "__await") ? t.resolve(l.__await).then((function(e) {
                n("next", e, i, a)
            }
            ), (function(e) {
                n("throw", e, i, a)
            }
            )) : t.resolve(l).then((function(e) {
                c.value = e,
                i(c)
            }
            ), (function(e) {
                return n("throw", e, i, a)
            }
            ))
        }
        a(s.arg)
    }
    var r;
    this._invoke = function(e, o) {
        function i() {
            return new t((function(t, r) {
                n(e, o, t, r)
            }
            ))
        }
        return r = r ? r.then(i, i) : i()
    }
}
function async(e, t, n, r, o) {
    void 0 === o && (o = Promise);
    var i = new AsyncIterator$1(wrap(e, t, n, r),o);
    return isGeneratorFunction(t) ? i : i.next().then((function(e) {
        return e.done ? e.value : i.next()
    }
    ))
}
function makeInvokeMethod(e, t, n) {
    var r = GenStateSuspendedStart;
    return function(o, i) {
        if (r === GenStateExecuting)
            throw new Error("Generator is already running");
        if (r === GenStateCompleted) {
            if ("throw" === o)
                throw i;
            return doneResult()
        }
        for (n.method = o,
        n.arg = i; ; ) {
            var a = n.delegate;
            if (a) {
                var s = maybeInvokeDelegate(a, n);
                if (s) {
                    if (s === ContinueSentinel)
                        continue;
                    return s
                }
            }
            if ("next" === n.method)
                n.sent = n._sent = n.arg;
            else if ("throw" === n.method) {
                if (r === GenStateSuspendedStart)
                    throw r = GenStateCompleted,
                    n.arg;
                n.dispatchException(n.arg)
            } else
                "return" === n.method && n.abrupt("return", n.arg);
            r = GenStateExecuting;
            var c = tryCatch(e, t, n);
            if ("normal" === c.type) {
                if (r = n.done ? GenStateCompleted : GenStateSuspendedYield,
                c.arg === ContinueSentinel)
                    continue;
                return {
                    value: c.arg,
                    done: n.done
                }
            }
            "throw" === c.type && (r = GenStateCompleted,
            n.method = "throw",
            n.arg = c.arg)
        }
    }
}
function maybeInvokeDelegate(e, t) {
    var n = e.iterator[t.method];
    if (n === undefined$1) {
        if (t.delegate = null,
        "throw" === t.method) {
            if (e.iterator.return && (t.method = "return",
            t.arg = undefined$1,
            maybeInvokeDelegate(e, t),
            "throw" === t.method))
                return ContinueSentinel;
            t.method = "throw",
            t.arg = new TypeError("The iterator does not provide a 'throw' method")
        }
        return ContinueSentinel
    }
    var r = tryCatch(n, e.iterator, t.arg);
    if ("throw" === r.type)
        return t.method = "throw",
        t.arg = r.arg,
        t.delegate = null,
        ContinueSentinel;
    var o = r.arg;
    return o ? o.done ? (t[e.resultName] = o.value,
    t.next = e.nextLoc,
    "return" !== t.method && (t.method = "next",
    t.arg = undefined$1),
    t.delegate = null,
    ContinueSentinel) : o : (t.method = "throw",
    t.arg = new TypeError("iterator result is not an object"),
    t.delegate = null,
    ContinueSentinel)
}
function pushTryEntry(e) {
    var t = {
        tryLoc: e[0]
    };
    1 in e && (t.catchLoc = e[1]),
    2 in e && (t.finallyLoc = e[2],
    t.afterLoc = e[3]),
    this.tryEntries.push(t)
}
function resetTryEntry(e) {
    var t = e.completion || {};
    t.type = "normal",
    delete t.arg,
    e.completion = t
}
function Context(e) {
    this.tryEntries = [{
        tryLoc: "root"
    }],
    e.forEach(pushTryEntry, this),
    this.reset(!0)
}
function keys(e) {
    var t = [];
    for (var n in e)
        t.push(n);
    return t.reverse(),
    function n() {
        for (; t.length; ) {
            var r = t.pop();
            if (r in e)
                return n.value = r,
                n.done = !1,
                n
        }
        return n.done = !0,
        n
    }
}
function values(e) {
    if (e) {
        var t = e[iteratorSymbol];
        if (t)
            return t.call(e);
        if ("function" == typeof e.next)
            return e;
        if (!isNaN(e.length)) {
            var n = -1
              , r = function t() {
                for (; ++n < e.length; )
                    if (hasOwn.call(e, n))
                        return t.value = e[n],
                        t.done = !1,
                        t;
                return t.value = undefined$1,
                t.done = !0,
                t
            };
            return r.next = r
        }
    }
    return {
        next: doneResult
    }
}
function doneResult() {
    return {
        value: undefined$1,
        done: !0
    }
}
GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype,
GeneratorFunctionPrototype.constructor = GeneratorFunction,
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction",
defineIteratorMethods(AsyncIterator$1.prototype),
AsyncIterator$1.prototype[asyncIteratorSymbol] = function() {
    return this
}
,
defineIteratorMethods(Gp),
Gp[toStringTagSymbol] = "Generator",
Gp[iteratorSymbol] = function() {
    return this
}
,
Gp.toString = function() {
    return "[object Generator]"
}
,
Context.prototype = {
    constructor: Context,
    reset: function(e) {
        if (this.prev = 0,
        this.next = 0,
        this.sent = this._sent = undefined$1,
        this.done = !1,
        this.delegate = null,
        this.method = "next",
        this.arg = undefined$1,
        this.tryEntries.forEach(resetTryEntry),
        !e)
            for (var t in this)
                "t" === t.charAt(0) && hasOwn.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = undefined$1)
    },
    stop: function() {
        this.done = !0;
        var e = this.tryEntries[0].completion;
        if ("throw" === e.type)
            throw e.arg;
        return this.rval
    },
    dispatchException: function(e) {
        if (this.done)
            throw e;
        var t = this;
        function n(n, r) {
            return i.type = "throw",
            i.arg = e,
            t.next = n,
            r && (t.method = "next",
            t.arg = undefined$1),
            !!r
        }
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var o = this.tryEntries[r]
              , i = o.completion;
            if ("root" === o.tryLoc)
                return n("end");
            if (o.tryLoc <= this.prev) {
                var a = hasOwn.call(o, "catchLoc")
                  , s = hasOwn.call(o, "finallyLoc");
                if (a && s) {
                    if (this.prev < o.catchLoc)
                        return n(o.catchLoc, !0);
                    if (this.prev < o.finallyLoc)
                        return n(o.finallyLoc)
                } else if (a) {
                    if (this.prev < o.catchLoc)
                        return n(o.catchLoc, !0)
                } else {
                    if (!s)
                        throw new Error("try statement without catch or finally");
                    if (this.prev < o.finallyLoc)
                        return n(o.finallyLoc)
                }
            }
        }
    },
    abrupt: function(e, t) {
        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
            var r = this.tryEntries[n];
            if (r.tryLoc <= this.prev && hasOwn.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                var o = r;
                break
            }
        }
        o && ("break" === e || "continue" === e) && o.tryLoc <= t && t <= o.finallyLoc && (o = null);
        var i = o ? o.completion : {};
        return i.type = e,
        i.arg = t,
        o ? (this.method = "next",
        this.next = o.finallyLoc,
        ContinueSentinel) : this.complete(i)
    },
    complete: function(e, t) {
        if ("throw" === e.type)
            throw e.arg;
        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg,
        this.method = "return",
        this.next = "end") : "normal" === e.type && t && (this.next = t),
        ContinueSentinel
    },
    finish: function(e) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
            var n = this.tryEntries[t];
            if (n.finallyLoc === e)
                return this.complete(n.completion, n.afterLoc),
                resetTryEntry(n),
                ContinueSentinel
        }
    },
    catch: function(e) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
            var n = this.tryEntries[t];
            if (n.tryLoc === e) {
                var r = n.completion;
                if ("throw" === r.type) {
                    var o = r.arg;
                    resetTryEntry(n)
                }
                return o
            }
        }
        throw new Error("illegal catch attempt")
    },
    delegateYield: function(e, t, n) {
        return this.delegate = {
            iterator: values(e),
            resultName: t,
            nextLoc: n
        },
        "next" === this.method && (this.arg = undefined$1),
        ContinueSentinel
    }
};
var _regeneratorRuntime = {
    wrap: wrap,
    isGeneratorFunction: isGeneratorFunction,
    AsyncIterator: AsyncIterator$1,
    mark: mark,
    awrap: awrap,
    async: async,
    keys: keys,
    values: values
}
  , visualMessageStatus = function(e) {
    return e[e.START = 0] = "START",
    e[e.RECEIVED = 1] = "RECEIVED",
    e
}({})
  , IGNORE_PREFIX = "tw-";
function getUniqueClassList(e) {
    try {
        if (!e.classList.length)
            return [];
        var t = e.parentNode.children
          , n = Array.from(e.classList).filter((function(e) {
            return !e.startsWith(IGNORE_PREFIX)
        }
        ));
        return n.every((function(e) {
            return 1 === Array.from(t).filter((function(t) {
                return null == t ? void 0 : t.classList.contains(e)
            }
            )).length
        }
        )) ? n : []
    } catch (r) {
        return console.log("getUniqueClassName -> error", r),
        []
    }
}
function getXpathFromNodeMultiClass(e) {
    try {
        var t, n = e.id, r = e.parentNode, o = e.tagName;
        if (e === document.body)
            return "HTML/" + o;
        if (n && 1 === (null == r || null === (t = r.querySelectorAll("#".concat(n))) || void 0 === t ? void 0 : t.length))
            return "//".concat(o, '[@id="').concat(n, '"]');
        var i = getUniqueClassList(e);
        if (i.length)
            return "".concat(getXpathFromNodeMultiClass(r), "/").concat(o, "[").concat(i.map((function(e) {
                return "contains(concat(' ', normalize-space(@class), ' '), ' ".concat(e, " ')")
            }
            )).join(" or "), "]");
        var a = 0;
        if (e && r)
            for (var s = r.childNodes, c = 0; c < s.length; c++) {
                var l = s[c];
                if (l === e)
                    return getXpathFromNodeMultiClass(r) + "/" + o + "[" + (a + 1) + "]";
                1 === l.nodeType && l.tagName === o && a++
            }
        return ""
    } catch (u) {
        return ""
    }
}
function sendMessageToOpener(e) {
    window.opener && window.opener.postMessage(e, "*")
}
function sendMessageToParent(e) {
    window.parent && window.parent.postMessage(e, "*")
}
function insertVisualJs(e) {
    var t = document.getElementsByTagName("head")[0]
      , n = String(+Date.now())
      , r = document.createElement("script");
    r.crossOrigin = "anonymous",
    r.type = "text/javascript",
    r.src = insertUrlHandle(e, n),
    r.onload = function() {
        (new window.VisualTrack).init(),
        "hotChart" === e && sendMessageToParent({
            data: {},
            type: "weblogger_auto_track_hot_chart_finish"
        })
    }
    ,
    null == t || t.appendChild(r)
}
function insertUrlHandle(e, t) {
    var n = "";
    switch (e) {
    case "toolbar":
        n = "https://static.yximgs.com/udata/pkg/ks-track-platform-new/visual-track-plugin/index.js?".concat(t);
        break;
    case "hotChart":
        n = "https://static.yximgs.com/udata/pkg/ks-track-platform-new/visual-track-plugin/vice.js?".concat(t)
    }
    return n
}
var PC_ECHO_HREF = "https://static.yximgs.com/udata/pkg/ks-track-platform-new/pc-visual-echo/index.js";
function insertPcEchoJs(e) {
    try {
        var t = document.getElementsByTagName("head")[0];
        if (t) {
            for (var n = t.children, r = 0; r < n.length; r++) {
                var o = n[r];
                if ("SCRIPT" === (null == o ? void 0 : o.tagName) && o.src.includes(PC_ECHO_HREF))
                    return void window.postMessage({
                        type: "weblogger_auto_track_pc_visual_echo_query",
                        params: e
                    }, "*")
            }
            var i = String(+Date.now())
              , a = document.createElement("script");
            a.crossOrigin = "anonymous",
            a.type = "text/javascript",
            a.src = "".concat(PC_ECHO_HREF, "?").concat(i),
            a.onload = function() {
                (new window.PcVisualEcho).init(e),
                window.postMessage({
                    type: "weblogger_auto_track_pc_visual_echo_query",
                    params: e
                }, "*")
            }
            ,
            null == t || t.appendChild(a)
        }
    } catch (s) {
        console.log("insertPcEchoJs -> error" + s)
    }
}
function ownKeys(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter((function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        ))),
        n.push.apply(n, r)
    }
    return n
}
function _objectSpread(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? ownKeys(Object(n), !0).forEach((function(t) {
            _defineProperty(e, t, n[t])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys(Object(n)).forEach((function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        }
        ))
    }
    return e
}
function _createForOfIteratorHelper(e, t) {
    var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
        if (Array.isArray(e) || (n = _unsupportedIterableToArray(e)) || t) {
            n && (e = n);
            var r = 0
              , o = function() {};
            return {
                s: o,
                n: function() {
                    return r >= e.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e[r++]
                    }
                },
                e: function(e) {
                    throw e
                },
                f: o
            }
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
    var i, a = !0, s = !1;
    return {
        s: function() {
            n = n.call(e)
        },
        n: function() {
            var e = n.next();
            return a = e.done,
            e
        },
        e: function(e) {
            s = !0,
            i = e
        },
        f: function() {
            try {
                a || null == n.return || n.return()
            } finally {
                if (s)
                    throw i
            }
        }
    }
}
function _unsupportedIterableToArray(e, t) {
    if (e) {
        if ("string" == typeof e)
            return _arrayLikeToArray(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name),
        "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(e, t) : void 0
    }
}
function _arrayLikeToArray(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function parseQueryString(e) {
    var t, n = {}, r = _createForOfIteratorHelper(e.split("&"));
    try {
        for (r.s(); !(t = r.n()).done; ) {
            var o = _slicedToArray(t.value.split("="), 2)
              , i = o[0]
              , a = o[1];
            i in n ? n[i]instanceof Array ? n[i].push(a) : n[i] = [n[i], a] : n[i] = a
        }
    } catch (s) {
        r.e(s)
    } finally {
        r.f()
    }
    return n
}
function getUrlAndQueryFromUrl() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.location.href
      , t = e.lastIndexOf("?");
    return -1 === t ? {
        page: e
    } : {
        page: e.slice(0, t),
        params: parseQueryString(e.slice(t + 1))
    }
}
function getRealUrlPackage(e) {
    var t = getUrlAndQueryFromUrl(window.location.href)
      , n = t.page
      , r = t.params;
    return {
        page: n,
        params: _objectSpread({
            page_code: e.page,
            url: window.location.href,
            query: r
        }, r),
        page_type: e.page_type,
        identity: e.identity
    }
}
!function() {
    if ("object" === ("undefined" == typeof window ? "undefined" : _typeof(window)))
        if ("IntersectionObserver"in window && "IntersectionObserverEntry"in window && "intersectionRatio"in window.IntersectionObserverEntry.prototype)
            "isIntersecting"in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function() {
                    return this.intersectionRatio > 0
                }
            });
        else {
            var e = function() {
                for (var e = window.document, t = o(e); t; )
                    t = o(e = t.ownerDocument);
                return e
            }()
              , t = []
              , n = null
              , r = null;
            a.prototype.THROTTLE_TIMEOUT = 100,
            a.prototype.POLL_INTERVAL = null,
            a.prototype.USE_MUTATION_OBSERVER = !0,
            a._setupCrossOriginUpdater = function() {
                return n || (n = function(e, n) {
                    r = e && n ? p(e, n) : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    },
                    t.forEach((function(e) {
                        e._checkForIntersections()
                    }
                    ))
                }
                ),
                n
            }
            ,
            a._resetCrossOriginUpdater = function() {
                n = null,
                r = null
            }
            ,
            a.prototype.observe = function(e) {
                if (!this._observationTargets.some((function(t) {
                    return t.element == e
                }
                ))) {
                    if (!e || 1 != e.nodeType)
                        throw new Error("target must be an Element");
                    this._registerInstance(),
                    this._observationTargets.push({
                        element: e,
                        entry: null
                    }),
                    this._monitorIntersections(e.ownerDocument),
                    this._checkForIntersections()
                }
            }
            ,
            a.prototype.unobserve = function(e) {
                this._observationTargets = this._observationTargets.filter((function(t) {
                    return t.element != e
                }
                )),
                this._unmonitorIntersections(e.ownerDocument),
                0 == this._observationTargets.length && this._unregisterInstance()
            }
            ,
            a.prototype.disconnect = function() {
                this._observationTargets = [],
                this._unmonitorAllIntersections(),
                this._unregisterInstance()
            }
            ,
            a.prototype.takeRecords = function() {
                var e = this._queuedEntries.slice();
                return this._queuedEntries = [],
                e
            }
            ,
            a.prototype._initThresholds = function(e) {
                var t = e || [0];
                return Array.isArray(t) || (t = [t]),
                t.sort().filter((function(e, t, n) {
                    if ("number" != typeof e || isNaN(e) || e < 0 || e > 1)
                        throw new Error("threshold must be a number between 0 and 1 inclusively");
                    return e !== n[t - 1]
                }
                ))
            }
            ,
            a.prototype._parseRootMargin = function(e) {
                var t = (e || "0px").split(/\s+/).map((function(e) {
                    var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e);
                    if (!t)
                        throw new Error("rootMargin must be specified in pixels or percent");
                    return {
                        value: parseFloat(t[1]),
                        unit: t[2]
                    }
                }
                ));
                return t[1] = t[1] || t[0],
                t[2] = t[2] || t[0],
                t[3] = t[3] || t[1],
                t
            }
            ,
            a.prototype._monitorIntersections = function(t) {
                var n = t.defaultView;
                if (n && -1 == this._monitoringDocuments.indexOf(t)) {
                    var r = this._checkForIntersections
                      , i = null
                      , a = null;
                    this.POLL_INTERVAL ? i = n.setInterval(r, this.POLL_INTERVAL) : (s(n, "resize", r, !0),
                    s(t, "scroll", r, !0),
                    this.USE_MUTATION_OBSERVER && "MutationObserver"in n && (a = new n.MutationObserver(r)).observe(t, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    })),
                    this._monitoringDocuments.push(t),
                    this._monitoringUnsubscribes.push((function() {
                        var e = t.defaultView;
                        e && (i && e.clearInterval(i),
                        c(e, "resize", r, !0)),
                        c(t, "scroll", r, !0),
                        a && a.disconnect()
                    }
                    ));
                    var l = this.root && (this.root.ownerDocument || this.root) || e;
                    if (t != l) {
                        var u = o(t);
                        u && this._monitorIntersections(u.ownerDocument)
                    }
                }
            }
            ,
            a.prototype._unmonitorIntersections = function(t) {
                var n = this._monitoringDocuments.indexOf(t);
                if (-1 != n) {
                    var r = this.root && (this.root.ownerDocument || this.root) || e;
                    if (!this._observationTargets.some((function(e) {
                        var n = e.element.ownerDocument;
                        if (n == t)
                            return !0;
                        for (; n && n != r; ) {
                            var i = o(n);
                            if ((n = i && i.ownerDocument) == t)
                                return !0
                        }
                        return !1
                    }
                    ))) {
                        var i = this._monitoringUnsubscribes[n];
                        if (this._monitoringDocuments.splice(n, 1),
                        this._monitoringUnsubscribes.splice(n, 1),
                        i(),
                        t != r) {
                            var a = o(t);
                            a && this._unmonitorIntersections(a.ownerDocument)
                        }
                    }
                }
            }
            ,
            a.prototype._unmonitorAllIntersections = function() {
                var e = this._monitoringUnsubscribes.slice(0);
                this._monitoringDocuments.length = 0,
                this._monitoringUnsubscribes.length = 0;
                for (var t = 0; t < e.length; t++)
                    e[t]()
            }
            ,
            a.prototype._checkForIntersections = function() {
                if (this.root || !n || r) {
                    var e = this._rootIsInDom()
                      , t = e ? this._getRootRect() : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    };
                    this._observationTargets.forEach((function(r) {
                        var o = r.element
                          , a = l(o)
                          , s = this._rootContainsTarget(o)
                          , c = r.entry
                          , u = e && s && this._computeTargetAndRootIntersection(o, a, t)
                          , p = null;
                        this._rootContainsTarget(o) ? n && !this.root || (p = t) : p = {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        };
                        var d = r.entry = new i({
                            time: window.performance && performance.now && performance.now(),
                            target: o,
                            boundingClientRect: a,
                            rootBounds: p,
                            intersectionRect: u
                        });
                        c ? e && s ? this._hasCrossedThreshold(c, d) && this._queuedEntries.push(d) : c && c.isIntersecting && this._queuedEntries.push(d) : this._queuedEntries.push(d)
                    }
                    ), this),
                    this._queuedEntries.length && this._callback(this.takeRecords(), this)
                }
            }
            ,
            a.prototype._computeTargetAndRootIntersection = function(t, o, i) {
                if ("none" != window.getComputedStyle(t).display) {
                    for (var a, s, c, u, d, h, m, g, v = o, y = f(t), _ = !1; !_ && y; ) {
                        var b = null
                          , E = 1 == y.nodeType ? window.getComputedStyle(y) : {};
                        if ("none" == E.display)
                            return null;
                        if (y == this.root || 9 == y.nodeType)
                            if (_ = !0,
                            y == this.root || y == e)
                                n && !this.root ? !r || 0 == r.width && 0 == r.height ? (y = null,
                                b = null,
                                v = null) : b = r : b = i;
                            else {
                                var w = f(y)
                                  , S = w && l(w)
                                  , O = w && this._computeTargetAndRootIntersection(w, S, i);
                                S && O ? (y = w,
                                b = p(S, O)) : (y = null,
                                v = null)
                            }
                        else {
                            var T = y.ownerDocument;
                            y != T.body && y != T.documentElement && "visible" != E.overflow && (b = l(y))
                        }
                        if (b && (a = b,
                        s = v,
                        c = void 0,
                        u = void 0,
                        d = void 0,
                        h = void 0,
                        m = void 0,
                        g = void 0,
                        c = Math.max(a.top, s.top),
                        u = Math.min(a.bottom, s.bottom),
                        d = Math.max(a.left, s.left),
                        h = Math.min(a.right, s.right),
                        g = u - c,
                        v = (m = h - d) >= 0 && g >= 0 && {
                            top: c,
                            bottom: u,
                            left: d,
                            right: h,
                            width: m,
                            height: g
                        } || null),
                        !v)
                            break;
                        y = y && f(y)
                    }
                    return v
                }
            }
            ,
            a.prototype._getRootRect = function() {
                var t;
                if (this.root && !h(this.root))
                    t = l(this.root);
                else {
                    var n = h(this.root) ? this.root : e
                      , r = n.documentElement
                      , o = n.body;
                    t = {
                        top: 0,
                        left: 0,
                        right: r.clientWidth || o.clientWidth,
                        width: r.clientWidth || o.clientWidth,
                        bottom: r.clientHeight || o.clientHeight,
                        height: r.clientHeight || o.clientHeight
                    }
                }
                return this._expandRectByRootMargin(t)
            }
            ,
            a.prototype._expandRectByRootMargin = function(e) {
                var t = this._rootMarginValues.map((function(t, n) {
                    return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100
                }
                ))
                  , n = {
                    top: e.top - t[0],
                    right: e.right + t[1],
                    bottom: e.bottom + t[2],
                    left: e.left - t[3]
                };
                return n.width = n.right - n.left,
                n.height = n.bottom - n.top,
                n
            }
            ,
            a.prototype._hasCrossedThreshold = function(e, t) {
                var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1
                  , r = t.isIntersecting ? t.intersectionRatio || 0 : -1;
                if (n !== r)
                    for (var o = 0; o < this.thresholds.length; o++) {
                        var i = this.thresholds[o];
                        if (i == n || i == r || i < n != i < r)
                            return !0
                    }
            }
            ,
            a.prototype._rootIsInDom = function() {
                return !this.root || d(e, this.root)
            }
            ,
            a.prototype._rootContainsTarget = function(t) {
                var n = this.root && (this.root.ownerDocument || this.root) || e;
                return d(n, t) && (!this.root || n == t.ownerDocument)
            }
            ,
            a.prototype._registerInstance = function() {
                t.indexOf(this) < 0 && t.push(this)
            }
            ,
            a.prototype._unregisterInstance = function() {
                var e = t.indexOf(this);
                -1 != e && t.splice(e, 1)
            }
            ,
            window.IntersectionObserver = a,
            window.IntersectionObserverEntry = i
        }
    function o(e) {
        try {
            return e.defaultView && e.defaultView.frameElement || null
        } catch (e2) {
            return null
        }
    }
    function i(e) {
        this.time = e.time,
        this.target = e.target,
        this.rootBounds = u(e.rootBounds),
        this.boundingClientRect = u(e.boundingClientRect),
        this.intersectionRect = u(e.intersectionRect || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        }),
        this.isIntersecting = !!e.intersectionRect;
        var t = this.boundingClientRect
          , n = t.width * t.height
          , r = this.intersectionRect
          , o = r.width * r.height;
        this.intersectionRatio = n ? Number((o / n).toFixed(4)) : this.isIntersecting ? 1 : 0
    }
    function a(e, t) {
        var n, r, o, i = t || {};
        if ("function" != typeof e)
            throw new Error("callback must be a function");
        if (i.root && 1 != i.root.nodeType && 9 != i.root.nodeType)
            throw new Error("root must be a Document or Element");
        this._checkForIntersections = (n = this._checkForIntersections.bind(this),
        r = this.THROTTLE_TIMEOUT,
        o = null,
        function() {
            o || (o = setTimeout((function() {
                n(),
                o = null
            }
            ), r))
        }
        ),
        this._callback = e,
        this._observationTargets = [],
        this._queuedEntries = [],
        this._rootMarginValues = this._parseRootMargin(i.rootMargin),
        this.thresholds = this._initThresholds(i.threshold),
        this.root = i.root || null,
        this.rootMargin = this._rootMarginValues.map((function(e) {
            return e.value + e.unit
        }
        )).join(" "),
        this._monitoringDocuments = [],
        this._monitoringUnsubscribes = []
    }
    function s(e, t, n, r) {
        "function" == typeof e.addEventListener ? e.addEventListener(t, n, r) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n)
    }
    function c(e, t, n, r) {
        "function" == typeof e.removeEventListener ? e.removeEventListener(t, n, r) : "function" == typeof e.detachEvent && e.detachEvent("on" + t, n)
    }
    function l(e) {
        var t;
        try {
            t = e.getBoundingClientRect()
        } catch (n) {}
        return t ? (t.width && t.height || (t = {
            top: t.top,
            right: t.right,
            bottom: t.bottom,
            left: t.left,
            width: t.right - t.left,
            height: t.bottom - t.top
        }),
        t) : {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        }
    }
    function u(e) {
        return !e || "x"in e ? e : {
            top: e.top,
            y: e.top,
            bottom: e.bottom,
            left: e.left,
            x: e.left,
            right: e.right,
            width: e.width,
            height: e.height
        }
    }
    function p(e, t) {
        var n = t.top - e.top
          , r = t.left - e.left;
        return {
            top: n,
            left: r,
            height: t.height,
            width: t.width,
            bottom: n + t.height,
            right: r + t.width
        }
    }
    function d(e, t) {
        for (var n = t; n; ) {
            if (n == e)
                return !0;
            n = f(n)
        }
        return !1
    }
    function f(t) {
        var n = t.parentNode;
        return 9 == t.nodeType && t != e ? o(t) : (n && n.assignedSlot && (n = n.assignedSlot.parentNode),
        n && 11 == n.nodeType && n.host ? n.host : n)
    }
    function h(e) {
        return e && 9 === e.nodeType
    }
}();
var IGNORE_ATTRIBUTE_NAME = "ignore-auto-track"
  , IGNORE_ECHO_ATTRIBUTE_NAME = "pc-visual-echo-element-tag"
  , defaultCollectAttribute = ["class", "alt", "src", "href"]
  , defaultCollectTags = [];
function getTextContentFiltered(e, t) {
    try {
        var n = "";
        return e.childNodes.forEach((function(e) {
            if (e.nodeType === Node.TEXT_NODE)
                n += e.textContent;
            else if (e.nodeType === Node.ELEMENT_NODE) {
                var r = e;
                r.getAttribute(t) || (n += getTextContentFiltered(r, t))
            }
        }
        )),
        n
    } catch (r) {
        return console.log("getTextContentFiltered -> error", r),
        ""
    }
}
var getTextContent = function(e) {
    try {
        var t = getTextContentFiltered(e, IGNORE_ECHO_ATTRIBUTE_NAME);
        if (!t)
            return "";
        var n = (t = t.trim()).substring(0, 20).trim();
        return t.length > n.length && (n += "..."),
        n
    } catch (r) {
        return console.log("getTextContent -> error", r),
        ""
    }
};
function cloneEvent(e, t) {
    try {
        var n = new Event(e.type,e);
        return Object.defineProperty(n, "target", {
            value: t
        }),
        Object.defineProperty(n, "clientX", {
            value: e.clientX
        }),
        Object.defineProperty(n, "clientY", {
            value: e.clientY
        }),
        n
    } catch (r) {
        return console.log("cloneEvent -> error", r),
        e
    }
}
var AutoTrack = function() {
    return _createClass((function e() {
        var t = this
          , n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        _classCallCheck(this, e),
        _defineProperty(this, "oldUrl", ""),
        _defineProperty(this, "oldHash", ""),
        _defineProperty(this, "oldTitle", ""),
        _defineProperty(this, "oldFmp", 0),
        _defineProperty(this, "mode", "all"),
        _defineProperty(this, "maxScrollX", 0),
        _defineProperty(this, "maxScrollY", 0),
        _defineProperty(this, "scrollStayTime", 4e3),
        _defineProperty(this, "symbol", "weblog-"),
        _defineProperty(this, "tags", defaultCollectTags),
        _defineProperty(this, "attributes", defaultCollectAttribute),
        _defineProperty(this, "commonIgnoreHierarchy", 5),
        _defineProperty(this, "hiddenContent", !1),
        _defineProperty(this, "isInsertToolbar", !1),
        _defineProperty(this, "timeId", null),
        _defineProperty(this, "touchStartObject", {}),
        _defineProperty(this, "touchMoveObject", {}),
        _defineProperty(this, "pcEchoParam", {}),
        _defineProperty(this, "pcEchoOpen", !1),
        _defineProperty(this, "resetObserver", (function(e) {
            var n = e.type
              , r = e.action;
            "PV" === n && "enter" === r && (t.initIntersecionObserver(!0),
            t.initMutationObserver())
        }
        )),
        _defineProperty(this, "touchStartEvent", (function(e) {
            for (var n = e.touches, r = 0; r < n.length; r++) {
                var o = n[r]
                  , i = o.clientX
                  , a = o.clientY
                  , s = o.identifier;
                if (t.touchStartObject[s])
                    return;
                t.touchStartObject[s] = {
                    clientX: Number(i.toFixed(2)),
                    clientY: Number(a.toFixed(2)),
                    timestamp: Date.now()
                }
            }
        }
        )),
        _defineProperty(this, "touchMoveEvent", (function(e) {
            for (var n = e.changedTouches, r = 0; r < n.length; r++) {
                var o = n[r]
                  , i = o.clientX
                  , a = o.clientY
                  , s = o.identifier
                  , c = {
                    clientX: Number(i.toFixed(2)),
                    clientY: Number(a.toFixed(2)),
                    timestamp: Date.now()
                };
                if (t.touchMoveObject[s])
                    return void t.touchMoveObject[s].push(c);
                t.touchMoveObject[s] = [c]
            }
        }
        )),
        _defineProperty(this, "touchEndEvent", function() {
            var e = _asyncToGenerator(_regeneratorRuntime.mark((function e(n) {
                var r, o, i, a, s, c, l, u, p, d, f, h;
                return _regeneratorRuntime.wrap((function(e) {
                    for (; ; )
                        switch (e.prev = e.next) {
                        case 0:
                            if (!(r = n.target) || !t.isIgnoreElemnt(r)) {
                                e.next = 3;
                                break
                            }
                            return e.abrupt("return");
                        case 3:
                            for (o = n.changedTouches,
                            i = [],
                            a = 0; a < o.length; a++)
                                s = o[a],
                                c = s.clientX,
                                l = s.clientY,
                                u = s.identifier,
                                p = {
                                    touchStart: {},
                                    touchMove: [],
                                    touchEnd: {}
                                },
                                d = t.touchStartObject[u],
                                f = t.touchMoveObject[u],
                                d && (p.touchStart = d,
                                delete t.touchStartObject[u]),
                                f && (p.touchMove = f,
                                delete t.touchMoveObject[u]),
                                p.touchEnd = {
                                    clientX: Number(c.toFixed(2)),
                                    clientY: Number(l.toFixed(2)),
                                    timestamp: Date.now()
                                },
                                i.push(p);
                            (h = t.dataFormat(n)) && t.collect("CLICK", h, "WEBLOGGER_AUTO_TRACK_TOUCH");
                        case 8:
                        case "end":
                            return e.stop()
                        }
                }
                ), e)
            }
            )));
            return function(t) {
                return e.apply(this, arguments)
            }
        }()),
        _defineProperty(this, "commonIgnoreFunction", (function(e) {
            var n = function(e) {
                try {
                    if (!e || e.getAttribute("pc-visual-echo-element-tag") && 1 === Array.from(e.parentNode.children).length)
                        return 0;
                    for (var t = 0, r = Array.from(e.children), o = 0, i = r; o < i.length; o++) {
                        var a = i[o];
                        t = Math.max(t, n(a))
                    }
                    return t + 1
                } catch (s) {
                    return console.log("getMaxDepth -> error" + s),
                    0
                }
            };
            return n(e) > t.commonIgnoreHierarchy
        }
        )),
        _defineProperty(this, "clickEvent", function() {
            var e = _asyncToGenerator(_regeneratorRuntime.mark((function e(n) {
                var r, o, i, a, s, c, l, u, p, d, f;
                return _regeneratorRuntime.wrap((function(e) {
                    for (; ; )
                        switch (e.prev = e.next) {
                        case 0:
                            if (!(i = n.target) || !t.isIgnoreElemnt(i)) {
                                e.next = 3;
                                break
                            }
                            return e.abrupt("return");
                        case 3:
                            a = [],
                            t.commonIgnoreHierarchy && a.push(t.commonIgnoreFunction),
                            null !== (r = t.customIgnoreFunctionList) && void 0 !== r && r.length && a.push.apply(a, _toConsumableArray(t.customIgnoreFunctionList)),
                            s = 0,
                            c = a;
                        case 7:
                            if (!(s < c.length)) {
                                e.next = 14;
                                break
                            }
                            if (!(0,
                            c[s])(i)) {
                                e.next = 11;
                                break
                            }
                            return e.abrupt("return");
                        case 11:
                            s++,
                            e.next = 7;
                            break;
                        case 14:
                            if (null === (o = t.beforeClickEventList) || void 0 === o || !o.length) {
                                e.next = 34;
                                break
                            }
                            l = _createForOfIteratorHelper(t.beforeClickEventList),
                            e.prev = 16,
                            l.s();
                        case 18:
                            if ((u = l.n()).done) {
                                e.next = 26;
                                break
                            }
                            if (p = u.value,
                            !(d = p(i))) {
                                e.next = 24;
                                break
                            }
                            return n = cloneEvent(n, d),
                            e.abrupt("break", 26);
                        case 24:
                            e.next = 18;
                            break;
                        case 26:
                            e.next = 31;
                            break;
                        case 28:
                            e.prev = 28,
                            e.t0 = e.catch(16),
                            l.e(e.t0);
                        case 31:
                            return e.prev = 31,
                            l.f(),
                            e.finish(31);
                        case 34:
                            (f = t.dataFormat(n)) && t.collect("CLICK", f, "WEBLOGGER_AUTO_TRACK_CLICK");
                        case 36:
                        case "end":
                            return e.stop()
                        }
                }
                ), e, null, [[16, 28, 31, 34]])
            }
            )));
            return function(t) {
                return e.apply(this, arguments)
            }
        }()),
        _defineProperty(this, "scrollEvent", (function() {
            t.timeId && clearTimeout(t.timeId),
            t.timeId = setTimeout((function() {
                var e = window
                  , n = e.innerWidth
                  , r = e.innerHeight
                  , o = e.scrollX
                  , i = e.scrollY
                  , a = document.body.clientWidth
                  , s = Math.min(n + o, a)
                  , c = r + i;
                (s > t.maxScrollX || c > t.maxScrollY) && (t.maxScrollX = s,
                t.maxScrollY = c,
                t.timeId = null)
            }
            ), t.scrollStayTime)
        }
        )),
        _defineProperty(this, "messageEvent", (function(e) {
            var n = e.data
              , r = t.weblog.Utils.cookie.setCookie;
            if (n) {
                var o = n.type
                  , i = n.params;
                if ("visual" === o) {
                    var a = n.data
                      , s = a.status
                      , c = a.visualData;
                    if (s === visualMessageStatus.RECEIVED) {
                        var l = new Date(+Date.now() + 36e5);
                        r("_visual_switch", "true", {
                            expires: l
                        }),
                        r("_visual_username", c.userName, {
                            expires: l
                        }),
                        r("_visual_appName", c.appName, {
                            expires: l
                        });
                        try {
                            sessionStorage.setItem("_weblog_visual_data", JSON.stringify({
                                id: c.id
                            }))
                        } catch (h) {}
                        !t.isInsertToolbar && insertVisualJs("toolbar"),
                        t.isInsertToolbar = !0
                    }
                } else if ("weblogger_auto_track_hot_chart" === o)
                    insertVisualJs("hotChart");
                else if ("weblogger_auto_track_pc_visual_search" === o) {
                    var u, p, d, f;
                    Object.assign(i, {
                        pageCode: t.weblog.currentUrlPackage.page,
                        pageUrl: null === (u = window.location.href.split("?")) || void 0 === u ? void 0 : u[0],
                        product: (null === (p = t.weblog.commonPackage.app_package) || void 0 === p ? void 0 : p.product_name) || (null === (d = t.weblog.commonPackage.app_package) || void 0 === d ? void 0 : d.product),
                        userName: null === (f = t.weblog.commonPackage.identity_package) || void 0 === f ? void 0 : f.user_id
                    }),
                    t.pcEchoParam = i,
                    t.pcEchoOpen = !0,
                    insertPcEchoJs(t.pcEchoParam)
                } else
                    "weblogger_auto_track_pc_visual_close" === o ? (t.pcEchoOpen = !1,
                    window.postMessage({
                        type: "weblogger_auto_track_pc_visual_echo_close"
                    }, "*")) : "weblogger_auto_track_pc_visual_init" === o && t.sendProduct()
            }
            n && "weblogger_auto_track_hot_chart" === n.type && insertVisualJs("hotChart")
        }
        )),
        _defineProperty(this, "collect", function() {
            var e = _asyncToGenerator(_regeneratorRuntime.mark((function e(n, r, o) {
                return _regeneratorRuntime.wrap((function(e) {
                    for (; ; )
                        switch (e.prev = e.next) {
                        case 0:
                            if (t.hiddenContent && (r.innerText = void 0),
                            "function" != typeof t.beforeSend) {
                                e.next = 10;
                                break
                            }
                            return e.prev = 2,
                            e.next = 5,
                            t.beforeSend(n, o, r);
                        case 5:
                            e.next = 10;
                            break;
                        case 7:
                            e.prev = 7,
                            e.t0 = e.catch(2),
                            console.error(e.t0);
                        case 10:
                            t.weblog.collect(n.toUpperCase(), {
                                action: o,
                                params: r,
                                urlPage: getRealUrlPackage(t.weblog.currentUrlPackage)
                            });
                        case 11:
                        case "end":
                            return e.stop()
                        }
                }
                ), e, null, [[2, 7]])
            }
            )));
            return function(t, n, r) {
                return e.apply(this, arguments)
            }
        }()),
        _defineProperty(this, "beforeUnload", (function() {
            t.weblog.sendImmediately("PULL_DOWN", {
                action: "WEBLOGGER_AUTO_TRACK_SCROLL",
                params: {
                    maxScrollX: t.maxScrollX,
                    maxScrollY: t.maxScrollY
                }
            })
        }
        )),
        "object" === _typeof(n) && (Object.assign(this, n),
        this.tags && this.tags.length && (this.tags = this.tags.map((function(e) {
            return e.toLowerCase()
        }
        ))),
        this.monitorShow && ("object" !== _typeof(this.monitorShow) && (this.monitorShow = {}),
        this.monitorShow.root && this.monitorShow.root.nodeType === Node.ELEMENT_NODE || (this.monitorShow.root = void 0)))
    }
    ), [{
        key: "apply",
        value: function(e) {
            this.weblog = e,
            this.init(),
            this.scrollEvent()
        }
    }, {
        key: "init",
        value: function() {
            var e = this;
            if ("true" === (0,
            this.weblog.Utils.cookie.getCookie)("_visual_switch"))
                return !this.isInsertToolbar && insertVisualJs("toolbar"),
                void (this.isInsertToolbar = !0);
            this.startRegisterAutoTrackPlugin(),
            this.applyPluginMessageToParent(),
            window.addEventListener("click", this.clickEvent, !0),
            window.addEventListener("scroll", this.scrollEvent),
            window.addEventListener("message", this.messageEvent, !1),
            this.isMobile() && (window.addEventListener("touchstart", this.touchStartEvent, !0),
            window.addEventListener("touchmove", this.touchMoveEvent, !0),
            window.addEventListener("touchend", this.touchEndEvent, !0)),
            this.monitorShow && (this.weblog.on("event", this.resetObserver),
            this.weblog.plugins.autoPV && (this.initIntersecionObserver(!0),
            this.initMutationObserver()));
            var t = this.sendProduct()
              , n = t.product
              , r = t.userName
              , o = this.weblog.updateCurrentUrlPackage.bind(this.weblog);
            this.weblog.updateCurrentUrlPackage = function(t, i) {
                o(t, i),
                e.pcEchoOpen && e.oldUrl !== t && setTimeout((function() {
                    var o;
                    e.oldUrl = t,
                    Object.assign(e.pcEchoParam, {
                        pageCode: e.weblog.currentUrlPackage.page,
                        pageUrl: null === (o = window.location.href.split("?")) || void 0 === o ? void 0 : o[0],
                        product: n,
                        userName: r
                    }),
                    insertPcEchoJs(e.pcEchoParam)
                }
                ), 0)
            }
        }
    }, {
        key: "isIgnoreElemnt",
        value: function(e) {
            try {
                return e && e !== document.body ? e.getAttribute(IGNORE_ATTRIBUTE_NAME) ? e.getAttribute(IGNORE_ATTRIBUTE_NAME) : this.isIgnoreElemnt(e.parentElement) : null
            } catch (t) {
                return console.log("isIgnoreElemnt -> error", t),
                null
            }
        }
    }, {
        key: "sendProduct",
        value: function() {
            var e, t, n, r = (null === (e = this.weblog.commonPackage.app_package) || void 0 === e ? void 0 : e.product_name) || (null === (t = this.weblog.commonPackage.app_package) || void 0 === t ? void 0 : t.product), o = null === (n = this.weblog.commonPackage.identity_package) || void 0 === n ? void 0 : n.user_id;
            return window.postMessage({
                type: "weblogger_auto_track_pc_visual_product",
                product: r,
                userName: o
            }, "*"),
            {
                product: r,
                userName: o
            }
        }
    }, {
        key: "initIntersecionObserver",
        value: function(e) {
            var t, n = this;
            null === (t = this.intersectionObserver) || void 0 === t || t.disconnect();
            var r = this.monitorShow
              , o = r.root
              , i = void 0 === o ? null : o
              , a = r.rootMargin
              , s = void 0 === a ? "0px" : a
              , c = r.threshold
              , l = void 0 === c ? .3 : c;
            this.intersectionObserver = new IntersectionObserver((function(e) {
                e.forEach((function(e) {
                    e.isIntersecting && (n.collectElementShow(e.target, !1, "intersection"),
                    n.intersectionObserver.unobserve(e.target))
                }
                ))
            }
            ),{
                root: i,
                rootMargin: s,
                threshold: l
            }),
            e && this.autoObserve()
        }
    }, {
        key: "autoObserve",
        value: function() {
            var e = this
              , t = this.monitorShow.mutationDelay
              , n = void 0 === t ? 300 : t;
            setTimeout((function() {
                var t = document.querySelectorAll("[".concat(e.symbol, "show]"));
                t.length && t.forEach((function(t) {
                    var n, r;
                    null === (n = e.intersectionObserver) || void 0 === n || n.unobserve(t),
                    null === (r = e.intersectionObserver) || void 0 === r || r.observe(t)
                }
                ))
            }
            ), Math.max(n, 0))
        }
    }, {
        key: "observe",
        value: function(e) {
            var t;
            this.intersectionObserver || this.initIntersecionObserver(),
            null === (t = this.intersectionObserver) || void 0 === t || t.observe(e)
        }
    }, {
        key: "initMutationObserver",
        value: function() {
            var e = this;
            try {
                var t;
                if (void 0 === window.MutationObserver)
                    return;
                null === (t = this.mutationObserver) || void 0 === t || t.disconnect();
                var n = this.monitorShow
                  , r = n.root
                  , o = void 0 === r ? document.body : r
                  , i = n.mutationDelay
                  , a = void 0 === i ? 300 : i;
                this.mutationObserver = new window.MutationObserver((function(t) {
                    setTimeout((function() {
                        var n = t.pop()
                          , r = n && n.addedNodes;
                        if (r && r.length)
                            for (var o = 0; o < r.length; o++) {
                                var i = r[o];
                                if (i && i.getBoundingClientRect) {
                                    var a = i.getBoundingClientRect()
                                      , s = a.x
                                      , c = a.y
                                      , l = a.width
                                      , u = a.height;
                                    0 === Math.max(l, u) || c > window.innerHeight || s > window.innerWidth ? e.observe(i) : e.collectElementShow(i, !0, "mutation")
                                }
                            }
                    }
                    ))
                }
                )),
                setTimeout((function() {
                    e.mutationObserver && e.mutationObserver.observe(o, {
                        childList: !0,
                        subtree: !0
                    })
                }
                ), Math.max(a, 0))
            } catch (s) {
                console.error(s)
            }
        }
    }, {
        key: "collectElementShow",
        value: function(e, t, n) {
            var r = this;
            if (e.nodeType === Node.ELEMENT_NODE) {
                var o = "".concat(this.symbol, "show")
                  , i = [e];
                t && (i = i.concat(Array.from(e.querySelectorAll("[".concat(o, "]"))))),
                i.forEach((function(t) {
                    if (!r.isIgnoreElemnt(t)) {
                        var o = r.customGetXpath ? r.customGetXpath(t) : getXpathFromNodeMultiClass(t);
                        if (r.trackCodeEvent("show", t, {
                            xpath: o,
                            trackMethod: n
                        }),
                        t === e && "all" === r.mode) {
                            var i = t.nodeName
                              , a = getTextContent(t)
                              , s = r.pickElementAttrs(t);
                            r.collect("SHOW", {
                                xpath: o,
                                innerText: a,
                                nodeName: i,
                                attributesSerialize: s,
                                trackMethod: n
                            }, "WEBLOGGER_AUTO_TRACK_SHOW")
                        }
                    }
                }
                ))
            }
        }
    }, {
        key: "isMobile",
        value: function() {
            var e = navigator.userAgent
              , t = e.indexOf("Android") > -1 || e.indexOf("Adr") > -1
              , n = !!e.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
            return t || n
        }
    }, {
        key: "elementFilter",
        value: function(e, t) {
            if (!e)
                return !1;
            if ("symbol" !== this.mode || e.hasAttribute("".concat(this.symbol, "type"))) {
                var n = e.tagName;
                return -1 === ["html", "body"].indexOf(n.toLowerCase()) && ((!this.tags || !this.tags.length || -1 !== this.tags.indexOf(n)) && !(this.exactMatchElement && e && !this.exactMatchElement(e)))
            }
        }
    }, {
        key: "pickElementAttrs",
        value: function(e) {
            for (var t = e.attributes, n = {}, r = 0; r < t.length; r++) {
                var o = t[r]
                  , i = o.name
                  , a = o.value;
                0 !== i.indexOf(this.symbol) && ((0 === i.indexOf("data-") || this.attributes && -1 !== this.attributes.indexOf(i)) && (n[i] = a))
            }
            return n
        }
    }, {
        key: "trackCodeEvent",
        value: function(e, t, n) {
            var r = this.symbol + e;
            if (t.hasAttribute(r) && !this.isIgnoreElemnt(t)) {
                var o = t.getAttribute(r);
                if (o)
                    try {
                        var i = JSON.parse(o)
                          , a = i.action
                          , s = i.params;
                        a && this.collect(e, _objectSpread(_objectSpread({}, s), n), a)
                    } catch (c) {
                        console.error("".concat(r, " parsed error:"), c)
                    }
            }
        }
    }, {
        key: "dataFormat",
        value: function(e) {
            var t = e
              , n = t.target
              , r = t.clientX
              , o = t.clientY
              , i = t.type;
            if (this.elementFilter(n, i)) {
                var a = n.getBoundingClientRect()
                  , s = r - a.x
                  , c = o - a.y
                  , l = this.customGetXpath ? this.customGetXpath(n) : getXpathFromNodeMultiClass(n)
                  , u = n.nodeName
                  , p = getTextContent(n)
                  , d = this.pickElementAttrs(n);
                return this.trackCodeEvent(i, n, {
                    xpath: l
                }),
                {
                    xpath: l,
                    innerText: p,
                    nodeName: u,
                    attributesSerialize: d,
                    clientX: r,
                    clientY: o,
                    x: s,
                    y: c
                }
            }
        }
    }, {
        key: "startRegisterAutoTrackPlugin",
        value: function() {
            if (window.opener) {
                var e = sessionStorage.getItem("_weblog_visual_data")
                  , t = e && JSON.parse(e);
                sendMessageToOpener({
                    data: {
                        id: t ? t.id : 0,
                        status: visualMessageStatus.START
                    },
                    type: "visual"
                })
            }
        }
    }, {
        key: "applyPluginMessageToParent",
        value: function() {
            sendMessageToParent({
                data: {},
                type: "weblogger_auto_track_finish"
            })
        }
    }, {
        key: "destroy",
        value: function() {
            window.removeEventListener("click", this.clickEvent, !0),
            window.removeEventListener("scroll", this.scrollEvent),
            window.removeEventListener("message", this.messageEvent, !1),
            this.isMobile() && (window.removeEventListener("touchstart", this.touchStartEvent, !0),
            window.removeEventListener("touchmove", this.touchMoveEvent, !0),
            window.removeEventListener("touchend", this.touchEndEvent, !0))
        }
    }])
}();
_defineProperty(AutoTrack, "key", "autoTrack");
const createLoggerUtils = () => initLogger({
    radarId: "5ea22d6e4c",
    baseParamsConfig: {
        product: 30
    },
    initParamsConfig: {
        proto: "v2",
        plugins: [new AutoTrack({
            beforeSend: (e, ...t) => {}
        })]
    },
    pluginsOption: {
        radar: {
            APIHook(e) {
                const {response: t} = e
                  , n = t.data;
                return {
                    response_code: n.result,
                    response_msg: 1 !== n.result ? n.error_msg : "",
                    status: t.status
                }
            }
        }
    }
}, !0)
  , useLogger = createUseLogger()
  , vLog = createLoggerDirective()
  , loggerUtils = createLoggerUtils();
function initLoggerAndRadar(e) {
    return {
        loggerUtils: loggerUtils,
        radar: radar
    }
}
function installLogger(e, t, n) {
    if (n && radar)
        return e.provide("logger", n),
        e.provide("radar", radar),
        useAutoPv(t, n, (e => ({}))),
        {
            loggerUtils: n,
            radar: radar
        }
}
function sendCustomEvent(e, t={}, n={}) {
    null == radar || radar.event({
        name: e,
        event_type: e,
        src: window.location.pathname,
        ...null != t ? t : {}
    }, n)
}
function sendFmp() {
    var e;
    console.info("[INIT FMP]:", null == (e = null == performance ? void 0 : performance.now) ? void 0 : e.call(performance)),
    nextTick(( () => {
        null == radar || radar.fmp()
    }
    ))
}
const {sendClick: sendClick, sendShow: sendShow} = loggerUtils;
function useLog(e) {
    function t(t, ...n) {
        const r = e[t];
        let o;
        return "function" == typeof r ? o = r(...n) : r ? o = r : n.length && (o = n[0]),
        o
    }
    function n(e, ...n) {
        const r = t(e, ...n);
        return r ? {
            action: e,
            params: r
        } : {
            action: e
        }
    }
    return {
        sendShowEvent: function(e, ...n) {
            var r;
            try {
                const o = null != (r = t(e, ...n)) ? r : {};
                sendShow(e, o)
            } catch (e2) {
                console.error(e2)
            }
        },
        sendClickEvent: function(e, ...n) {
            var r;
            try {
                const o = null != (r = t(e, ...n)) ? r : {};
                sendClick(e, o)
            } catch (e2) {
                console.error(e2)
            }
        },
        usePVParams: function(e, n, ...r) {
            const {usePV: o} = useLogger()
              , i = t(e, ...r);
            o().addParamsToPV({
                page: n,
                params: i
            })
        },
        getClickLogParams: function(e, ...t) {
            return {
                type: "click",
                ...n(e, ...t)
            }
        },
        getShowLogParams: function(e, ...t) {
            return {
                type: "show",
                ...n(e, ...t)
            }
        }
    }
}
function getLogoutV3Url({sid: e, env: t, followUrl: n, unionLogout: r}) {
    return url_stringify({
        url: "".concat(getBaseUrl(t), "/rest/infra/n/logout"),
        params: {
            sid: e,
            followUrl: {
                url: "".concat(origin, "/rest/infra/n/logout"),
                params: {
                    sid: e,
                    followUrl: n || ("undefined" != typeof location ? location.href : void 0),
                    unionLogout: r
                }
            },
            unionLogout: r
        }
    })
}
function getPassTokenUrl(e, t="kuaishou") {
    return "bid" === t ? "".concat(getBaseUrl(e), "/pass/bid/web/login/passToken") : "".concat(getBaseUrl(e), "/pass/").concat(t, "/login/passToken")
}
function getStsUrl() {
    return "".concat(origin, "/rest/infra/sts")
}
function getBaseUrl(e) {
    return "staging" === e ? zt_passport_web_api_origin.staging : "undefined" != typeof window && window.SSO_API_ID_PREFIX ? window.SSO_API_ID_PREFIX : "undefined" != typeof location && location.host.endsWith("kuaishou.cn") ? zt_passport_web_api_origin.production.cn : zt_passport_web_api_origin.production.com
}
const zt_passport_web_api_origin = {
    production: {
        com: "undefined" != typeof window && window.SSO_API_ID_PREFIX || "https://id.kuaishou.com",
        cn: "undefined" != typeof window && window.SSO_API_ID_PREFIX || "https://id.kuaishou.cn"
    },
    staging: "https://ksid.staging.kuaishou.com"
};
function url_stringify(e) {
    const t = new URL("string" == typeof e ? e : e.url)
      , n = [];
    for (const [r,o] of Object.entries(e.params || {})) {
        const e = o instanceof Array ? o : [o];
        for (const t of e)
            if (void 0 !== t)
                try {
                    n.push([r, url_stringify(t)])
                } catch (e2) {
                    n.push([r, String(t)])
                }
    }
    return new URLSearchParams(n).forEach(( (e, n) => {
        t.searchParams.append(n, e)
    }
    )),
    t.toString()
}
const ABTestModel = createModel(( () => {
    const {info: e, status: t, refetch: n} = useRestQuery({
        url: "/rest/v/system/startup",
        method: "POST",
        headers: {
            "content-type": "application/json",
            kpn: "KUAISHOU_VISION",
            kpf: "PC_WEB"
        },
        skip: !1
    })
      , r = computed(( () => e.data));
    return {
        info: e,
        data: r,
        refetch: n
    }
}
))
  , useABTestModel = () => useModel(ABTestModel)
  , userModel = createModel(( () => {
    const {info: e, status: t, refetch: n} = useRestQuery({
        url: "/rest/v/profile/get",
        method: "GET",
        headers: {
            "content-type": "application/json"
        },
        skip: !1
    })
      , r = computed(( () => null == e ? void 0 : e.data))
      , o = computed(( () => {
        var n;
        return (null == (n = r.value) ? void 0 : n.userId) && t.value !== StateStatus.RefreshError && !e.error
    }
    ))
      , i = computed(( () => {
        var e, t;
        return (null == (e = r.value) ? void 0 : e.userDefineId) || (null == (t = r.value) ? void 0 : t.eid)
    }
    ))
      , a = reactive({
        likedList: !0,
        privateList: !0,
        historyList: !0,
        followList: !0,
        fanList: !0
    })
      , s = useRestQuery({
        url: "/rest/v/feed/liked",
        method: "POST",
        variables: () => ({
            pcursor: "",
            page: "profile"
        }),
        skip: () => !o.value || a.likedList,
        updateQuery: (e, t) => {
            var n, r, o;
            return {
                ...t,
                pcursor: (null == (n = null == t ? void 0 : t.feeds) ? void 0 : n.length) ? null == t ? void 0 : t.pcursor : "no_more",
                feeds: [...null != (r = null == e ? void 0 : e.feeds) ? r : [], ...null != (o = null == t ? void 0 : t.feeds) ? o : []]
            }
        }
    })
      , c = computed(( () => {
        var e, t;
        return null != (t = null == (e = s.info.data) ? void 0 : e.feeds) ? t : []
    }
    ))
      , l = useRestQuery({
        url: "/rest/v/profile/private/list",
        method: "POST",
        variables: () => ({
            pcursor: "",
            page: "private"
        }),
        skip: () => !o.value || a.privateList,
        updateQuery: (e, t) => {
            var n, r, o;
            return {
                ...t,
                pcursor: (null == (n = null == t ? void 0 : t.feeds) ? void 0 : n.length) ? null == t ? void 0 : t.pcursor : "no_more",
                feeds: [...null != (r = null == e ? void 0 : e.feeds) ? r : [], ...null != (o = null == t ? void 0 : t.feeds) ? o : []]
            }
        }
    })
      , u = computed(( () => {
        var e, t;
        return null != (t = null == (e = l.info.data) ? void 0 : e.feeds) ? t : []
    }
    ))
      , p = useRestQuery({
        url: "/rest/v/profile/history/list",
        method: "POST",
        variables: () => ({
            pcursor: "",
            page: "history"
        }),
        skip: () => !o.value || a.historyList,
        updateQuery: (e, t) => {
            var n, r, o;
            return {
                ...t,
                pcursor: (null == (n = null == t ? void 0 : t.feeds) ? void 0 : n.length) ? null == t ? void 0 : t.pcursor : "no_more",
                feeds: [...null != (r = null == e ? void 0 : e.feeds) ? r : [], ...null != (o = null == t ? void 0 : t.feeds) ? o : []]
            }
        }
    })
      , d = computed(( () => {
        var e, t;
        return null != (t = null == (e = p.info.data) ? void 0 : e.feeds) ? t : []
    }
    ))
      , f = useRestQuery({
        url: "/rest/v/relation/fol",
        method: "POST",
        variables: () => ({
            pcursor: "",
            ftype: 1
        }),
        skip: () => a.followList,
        updateQuery: (e, t) => {
            var n, r, o;
            return {
                ...t,
                pcursor: (null == (n = null == t ? void 0 : t.authors) ? void 0 : n.length) ? null == t ? void 0 : t.pcursor : "no_more",
                authors: [...null != (r = null == e ? void 0 : e.authors) ? r : [], ...null != (o = null == t ? void 0 : t.authors) ? o : []]
            }
        }
    });
    watch(( () => {
        var e;
        return null == (e = f.info.data) ? void 0 : e.authors
    }
    ), (e => {
        null == e || e.forEach((e => {
            var t;
            e.following = null == (t = e.following) || t
        }
        ))
    }
    ));
    const h = computed(( () => {
        var e, t;
        return null != (t = null == (e = f.info.data) ? void 0 : e.authors) ? t : []
    }
    ))
      , m = useRestQuery({
        url: "/rest/v/relation/fol",
        method: "POST",
        variables: () => ({
            pcursor: "",
            ftype: 2
        }),
        skip: () => a.fanList,
        updateQuery: (e, t) => {
            var n, r, o;
            return {
                ...t,
                pcursor: (null == (n = null == t ? void 0 : t.authors) ? void 0 : n.length) ? null == t ? void 0 : t.pcursor : "no_more",
                authors: [...null != (r = null == e ? void 0 : e.authors) ? r : [], ...null != (o = null == t ? void 0 : t.authors) ? o : []]
            }
        }
    })
      , g = computed(( () => {
        var e, t;
        return null != (t = null == (e = m.info.data) ? void 0 : e.authors) ? t : []
    }
    ));
    return {
        userInfo: e,
        status: t,
        user: r,
        userId: i,
        isLogin: o,
        refetch: n,
        restSkips: a,
        likedListRest: s,
        likedFeeds: c,
        addLikedFeeds: async () => {
            var e, t, n, r;
            "no_more" !== (null == (t = null == (e = s.info) ? void 0 : e.data) ? void 0 : t.pcursor) && await s.fetchMore({
                pcursor: null == (r = null == (n = s.info) ? void 0 : n.data) ? void 0 : r.pcursor,
                page: "private"
            })
        }
        ,
        privateListRest: l,
        privateFeeds: u,
        addPrivateFeeds: async () => {
            var e, t, n, r;
            "no_more" !== (null == (t = null == (e = l.info) ? void 0 : e.data) ? void 0 : t.pcursor) && await l.fetchMore({
                pcursor: null == (r = null == (n = l.info) ? void 0 : n.data) ? void 0 : r.pcursor,
                page: "private"
            })
        }
        ,
        historyListRest: p,
        historyFeeds: d,
        addHistoryFeeds: async () => {
            var e, t, n, r;
            "no_more" !== (null == (t = null == (e = p.info) ? void 0 : e.data) ? void 0 : t.pcursor) && await p.fetchMore({
                pcursor: null == (r = null == (n = p.info) ? void 0 : n.data) ? void 0 : r.pcursor,
                page: "history"
            })
        }
        ,
        followListRest: f,
        followUsers: h,
        addFollowList: async () => {
            var e, t, n, r;
            "no_more" !== (null == (t = null == (e = f.info) ? void 0 : e.data) ? void 0 : t.pcursor) && await f.fetchMore({
                pcursor: null == (r = null == (n = f.info) ? void 0 : n.data) ? void 0 : r.pcursor,
                ftype: 1
            })
        }
        ,
        fanListRest: m,
        fanUsers: g,
        addFanList: async () => {
            var e, t, n, r;
            "no_more" !== (null == (t = null == (e = m.info) ? void 0 : e.data) ? void 0 : t.pcursor) && await m.fetchMore({
                pcursor: null == (r = null == (n = m.info) ? void 0 : n.data) ? void 0 : r.pcursor,
                ftype: 2
            })
        }
    }
}
))
  , useUserModel = () => useModel(userModel);
function parseQuery(e, t) {
    if (e) {
        return e.split("&").reduce(( (e, n) => {
            const r = e
              , o = n && n.split("=")[0];
            return n && !t.includes(o) && (r[o] = n.split("=")[1]),
            r
        }
        ), {})
    }
    return {}
}
function updateQuery(e, t) {
    var n;
    const r = parseQuery(e, t);
    let o = "?";
    for (const i in r)
        r && Object.prototype.hasOwnProperty.call(r, i) && (o += "".concat(i, "=").concat(null != (n = r[i]) ? n : "", "&"));
    return o
}
function appendParam(e, t) {
    let n = e;
    const r = n.includes("?") ? "&" : "?"
      , o = [];
    for (const i in t)
        if (t[i]) {
            const e = t[i] || "";
            o.push(encodeURIComponent(i) + "=" + encodeURIComponent(e))
        }
    return o.length && (n += r + o.join("&")),
    e
}
const isSSR = "undefined" == typeof window
  , isProduction = !0;
let ssoModule = null;
isSSR || __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./index.esm-CUInnmRD.js")))), [], "").then((e => {
    ssoModule = e
}
));
const loginModel = createModel(( () => {
    const e = ref("")
      , t = ref(!1)
      , n = ref(!1)
      , r = ref(!1)
      , o = useModel(ABTestModel)
      , {refetch: i, isLogin: a, user: s} = useUserModel()
      , c = () => {
        var e;
        if (isSSR || t.value || !o.data.value || !ssoModule)
            return;
        const n = "production";
        ssoModule.init({
            env: n,
            sid: null == (e = o.data.value) ? void 0 : e.sid,
            useKsCaptcha: !0,
            baseUrl: getBaseUrl(n),
            enableSig4: !0
        }),
        t.value = !0
    }
      , l = async () => {
        var e;
        await i(),
        a.value ? (n.value = !0,
        r.value = !0,
        (null == (e = s.value) ? void 0 : e.eid) && localStorage.setItem("eid", s.value.eid)) : n.value = !1
    }
      , u = async (e=!1) => {
        var t, n;
        if (isSSR || !ssoModule)
            return;
        r.value = !1;
        const i = null == (t = o.data.value) ? void 0 : t.sid;
        if (i)
            try {
                const t = await ssoModule.refreshLoginStatus({
                    sid: i,
                    passTokenUrl: getPassTokenUrl(isProduction ? "production" : "staging"),
                    stsUrl: getStsUrl()
                });
                if (sendCustomEvent("LOGIN", {
                    resultType: i,
                    extInfo: {
                        result: t.result,
                        updatedSid: e
                    }
                }),
                1 !== t.result)
                    throw new Error(null != (n = t.message) ? n : "");
                await l()
            } catch (e2) {
                let n;
                try {
                    n = JSON.stringify(e2)
                } catch (a) {
                    n = ""
                }
                throw sendCustomEvent("LOGIN_ERROR", {
                    resultType: i,
                    extInfo: {
                        errorMsg: n,
                        updatedSid: e
                    }
                }),
                console.error("refreshCurrentLoginStatus error", e2),
                new Error(e2)
            }
    }
      , p = ref({
        qrLoginSignature: "",
        qrLoginToken: "",
        imageData: ""
    })
      , d = ref("scan")
      , f = ref([])
      , h = ref("")
      , m = ref("");
    return {
        loginPlatform: e,
        qrLoginInfo: p,
        qrStatus: d,
        multiUserInfos: f,
        initSSO: c,
        startQRLogin: async () => {
            try {
                c(),
                await (async () => {
                    !isSSR && ssoModule && (p.value = await ssoModule.getQRLoginInfo())
                }
                )(),
                d.value = "scan",
                await (isSSR || !ssoModule ? Promise.resolve() : ssoModule.getUserLoginInfo({
                    qrLoginSignature: p.value.qrLoginSignature,
                    qrLoginToken: p.value.qrLoginToken
                })),
                d.value = "confirm",
                await (async () => isSSR || !ssoModule ? Promise.resolve() : ssoModule.scanQRLoginResult({
                    qrLoginSignature: p.value.qrLoginSignature,
                    qrLoginToken: p.value.qrLoginToken
                }))(),
                await u(),
                e.value = "KWAI"
            } catch (e2) {
                if (console.log("qr error", e2.message),
                2 === e2.result)
                    throw e2;
                if ("from cancel" === e2.message)
                    return;
                d.value = "timeout"
            }
        }
        ,
        cancelQrLogin: () => {
            !isSSR && ssoModule && (d.value = "scan",
            ssoModule.cancelQrLogin())
        }
        ,
        checkLogin: async () => {
            c(),
            await l()
        }
        ,
        verificationLogin: async t => {
            if (!isSSR && ssoModule)
                try {
                    await ssoModule.login(t),
                    await u(),
                    e.value = "PHONE"
                } catch (e2) {
                    if (100110031 === e2.result)
                        return f.value = e2.userInfos,
                        h.value = e2.multiUserToken,
                        m.value = e2.phone,
                        void (e.value = "PHONE");
                    if (e.value = "",
                    2 === e2.ret)
                        return;
                    throw e2
                }
        }
        ,
        chooseUser: async t => {
            if (!isSSR && ssoModule) {
                try {
                    await ssoModule.chooseUser({
                        userId: t,
                        multiUserToken: h.value,
                        phone: m.value
                    }),
                    await u(),
                    e.value = "PHONE"
                } catch (n) {
                    e.value = ""
                }
                f.value = []
            }
        }
        ,
        requestVerification: e => isSSR || !ssoModule ? Promise.resolve() : ssoModule.requestMobileCode(e),
        logout: async () => {
            var t;
            localStorage.removeItem("eid"),
            n.value = !1,
            e.value = "",
            (null == (t = o.data.value) ? void 0 : t.sid) && (window.location.href = getLogoutV3Url({
                sid: o.data.value.sid,
                env: "production"
            }))
        }
    }
}
));
function isUserAgent(e) {
    var t;
    try {
        return null == (t = null == navigator ? void 0 : navigator.userAgent) ? void 0 : t.includes(e)
    } catch (e2) {
        return !1
    }
}
function isSafari() {
    return isUserAgent("Safari") && !isUserAgent("Chrome")
}
function usePageState() {
    const e = ref(!0);
    function t() {
        (null == document ? void 0 : document.visibilityState) && (e.value = "visible" === document.visibilityState)
    }
    return onMounted(( () => {
        document.addEventListener("visibilitychange", t),
        isSafari() && window.addEventListener("pagehide", t)
    }
    )),
    onBeforeUnmount(( () => {
        document.removeEventListener("visibilitychange", t),
        isSafari() && window.removeEventListener("pagehide", t)
    }
    )),
    e
}
const useBroadcastModel = createUseModel(( () => {
    if (isSSR)
        return {
            broadcast: () => {}
            ,
            useBroadCastStream: () => {}
        };
    const e = new EventTarget;
    return {
        broadcast: (t, n) => {
            const r = new CustomEvent(t,{
                detail: n
            });
            e.dispatchEvent(r)
        }
        ,
        useBroadCastStream: function(t, n) {
            const r = e => {
                n(e.detail)
            }
            ;
            onMounted(( () => {
                null == e || e.addEventListener(t, r)
            }
            )),
            onBeforeUnmount(( () => {
                null == e || e.removeEventListener(t, r)
            }
            ))
        }
    }
}
));
function getRightCurrentInstance() {
    const e = getCurrentInstance();
    return (null == e ? void 0 : e.proxy) ? null == e ? void 0 : e.proxy : (console.log(e),
    e)
}
function useRouter() {
    const e = getRightCurrentInstance();
    return toRefs(reactive({
        route: null == e ? void 0 : e.$route,
        router: null == e ? void 0 : e.$router
    }))
}
const KconfModel = createModel(( () => {
    const {info: e, status: t, refetch: n} = useRestQuery({
        url: "/rest/v/kconf/get",
        method: "POST",
        headers: {
            "content-type": "application/json"
        },
        skip: !1
    })
      , r = computed(( () => e.data))
      , o = computed(( () => {
        var e;
        return null == (e = r.value) ? void 0 : e.loginConfig
    }
    ))
      , i = computed(( () => {
        var e;
        return null == (e = r.value) ? void 0 : e.pcNavigationConfig
    }
    ))
      , a = computed(( () => {
        var e;
        return null == (e = r.value) ? void 0 : e.pcMenuConfig
    }
    ))
      , s = computed(( () => {
        var e;
        const t = null == (e = i.value) ? void 0 : e.themes;
        if (!t)
            return;
        const n = Date.now();
        for (const r of t)
            for (let e = 0; e < r.timelimit.length; e += 2) {
                const t = r.timelimit[e]
                  , o = r.timelimit[e + 1];
                if (!t || !o)
                    break;
                if (n >= t && n <= o)
                    return r
            }
    }
    ));
    return watchEffect(( () => {
        var e, t;
        isSSR || (document.documentElement.className = null != (t = null == (e = s.value) ? void 0 : e.key) ? t : "")
    }
    )),
    {
        info: e,
        data: r,
        refetch: n,
        loginConfigV2: o,
        pcNavigationConfig: i,
        pcMenuConfig: a,
        theme: s
    }
}
))
  , useKconfModel = () => useModel(KconfModel)
  , HOME_LEAVE_TIME = "home-leave-time"
  , TRIGGERED_LOGIN_TIME = "triggered-login-time";
function useDomListener(e, t, n, r) {
    let o;
    onMounted(( () => {
        var i;
        o = e(),
        "$el"in o ? o.$el.addEventListener(t, n, r) : isRef(o) ? null == (i = o.value) || i.addEventListener(t, n, r) : o.addEventListener(t, n, r)
    }
    )),
    onBeforeUnmount(( () => {
        var e;
        "$el"in o ? o.$el.removeEventListener(t, n, r) : isRef(o) ? null == (e = o.value) || e.removeEventListener(t, n, r) : o.removeEventListener(t, n, r)
    }
    ))
}
const userCustomBehavior = createUseModel(( () => {
    const e = ref(!1)
      , t = ref(-1);
    function n() {
        clearTimeout(t.value),
        t.value = window.setTimeout(( () => {
            e.value = !1
        }
        ), 500)
    }
    return useDomListener(( () => window), "scroll", ( () => {
        e.value = !0,
        n()
    }
    )),
    useDomListener(( () => window), "mousemove", ( () => {
        e.value = !0,
        n()
    }
    )),
    useDomListener(( () => window), "resize", ( () => {
        e.value = !0,
        n()
    }
    )),
    useDomListener(( () => window), "mousedown", ( () => {
        e.value = !0,
        n()
    }
    )),
    {
        userInteractive: e
    }
}
));
var RouteName = (e => (e.Home = "HOME",
e.Brilliant = "BRILLIANT",
e.Profile = "PROFILE",
e.Hash = "HASH_TAG",
e.Search = "SEARCH",
e.ShortVideo = "DETAIL",
e.Error = "PAGE_404",
e.Like = "FOLLOW",
e.SameCity = "NEARBY",
e.Theater = "Theater",
e.Video = "Video",
e.Reco = "Reco",
e.NewReco = "NewReco",
e))(RouteName || {})
  , SearchParamsName = (e => (e.searchKey = "searchKey",
e.source = "source",
e))(SearchParamsName || {});
const PRT_HOST_MAP = new Map;
function insertToQueue(e, t) {
    let n = t.length;
    for (; n > 0 && t[n - 1].groupPriority < e.groupPriority; )
        n--;
    for (; n > 0 && t[n - 1].priority < e.priority; )
        n--;
    return t.splice(n, 0, e),
    t
}
async function loadComponent(e) {
    const t = "function" == typeof e ? await e() : e;
    return t.default ? t.default : t
}
PRT_HOST_MAP.set("live.kuaishou.com", "kankan.kuaishou.com");
class DialogQueue {
    constructor(e, t) {
        __publicField(this, "queue", []),
        __publicField(this, "currentDialog"),
        __publicField(this, "currentDialogId"),
        __publicField(this, "currentInstance"),
        __publicField(this, "options"),
        __publicField(this, "isLoading", !1),
        this.currentInstance = e,
        this.options = t
    }
    async mountDialog(e, t, {closeDialog: n}) {
        const r = document.createElement("div");
        this.isLoading = !0;
        const o = await loadComponent(e);
        this.isLoading = !1;
        const i = createApp$1({
            provide: () => this.currentInstance.$.appContext.provides,
            render: () => h$5(o, {
                ...t,
                onCloseDialog: n
            })
        });
        i.mount(r),
        this.currentDialog = i,
        document.body.appendChild(r)
    }
    unmountDialog() {
        var e, t;
        this.currentDialogId = void 0,
        this.currentDialog && (this.currentDialog.unmount(),
        this.currentDialog = void 0),
        this.queue.length ? this.tryMountDialog() : null == (t = null == (e = this.options) ? void 0 : e.onQueueEmpty) || t.call(e)
    }
    tryMountDialog() {
        var e, t;
        if (this.currentDialog)
            return;
        if (this.isLoading)
            return;
        if (!this.queue.length)
            return;
        const {loader: n, props: r, resolve: o, id: i} = this.queue.shift();
        this.currentDialogId = i,
        null == (t = null == (e = this.options) ? void 0 : e.onDialogShow) || t.call(e, r),
        this.mountDialog(n, r, {
            closeDialog: e => {
                var t, n;
                o(e),
                null == (n = null == (t = this.options) ? void 0 : t.onDialogClose) || n.call(t, r),
                this.unmountDialog()
            }
        })
    }
    showDialog(e) {
        return new Promise((t => {
            var n, r;
            insertToQueue({
                ...e,
                priority: null != (n = e.priority) ? n : 1,
                groupPriority: null != (r = e.groupPriority) ? r : 1,
                id: e.id,
                resolve: t
            }, this.queue),
            nextTick(( () => {
                this.tryMountDialog()
            }
            ))
        }
        ))
    }
    createShowDialog(e, t, n=1, r=1) {
        return o => this.showDialog({
            loader: e,
            props: o,
            groupPriority: n,
            priority: r,
            id: t
        })
    }
}
const videoLogConfig = {
    PLAYER_MODULE: void 0,
    PLC_USERNAME__BUTTON: void 0,
    PLC_USERNAME_BUTTON: void 0,
    TOOLBAR_PLAY_BUTTON: void 0,
    TOOLBAR_PAUSE_BUTTON: void 0,
    TOOLBAR_CONTINUOUS_PLAY_BUTTON: void 0,
    TOOLBAR_MUTE__BUTTON: void 0,
    TOOLBAR_FULL_SCREEN__BUTTON: void 0,
    INTERACTION_VIDEO_SWITCH_BUTTON: void 0,
    INTERACTION_HEAD_BUTTON: void 0,
    INTERACTION_FOLLOW_BUTTON: void 0,
    INTERACTION_LIKE_BUTTON: void 0,
    INTERACTION_COMMENT_BUTTON: void 0,
    INTERACTION_COLLECT_BUTTON: void 0,
    INTERACTION_SHARE_POPOVER: void 0,
    INTERACTION_SHARE_BUTTON: void 0,
    INTERACTION_MORE_POPOVER: void 0,
    INTERACTION_NOTINTERESTED_BUTTON: void 0,
    INTERACTION_REPORT_BUTTON: void 0,
    INTERACTION_SHORTCUT_KEY_BUTTON: void 0,
    TIGHT_COMMENT_AREA: void 0,
    TIGHT_COMMENT_SEND_BUTTON: void 0,
    TIGHT_COMMENT_LIKE_BUTTON: void 0,
    TIGHT_COMMENT_REPLY_BUTTON: void 0,
    TIGHT_COMMENT_EXPAND_BUTTON: void 0,
    TIGHT_COMMENT_REPORT_BUTTON: void 0,
    MINI_PERSONAL_AUTHOR: void 0,
    MINI_PERSONAL_AUTHOR_NICKNAME: void 0,
    MINI_PERSONAL_FOLLOW_BUTTON: void 0,
    MINI_PERSONAL_VIDEO_CARD: void 0,
    MINI_PERSONAL_ELEVATOR_BUTTON: void 0
}
  , {sendShowEvent: sendShowEvent, sendClickEvent: sendClickEvent, usePVParams: usePVParams, getClickLogParams: getClickLogParams, getShowLogParams: getShowLogParams} = useLog(videoLogConfig)
  , layoutModel = createModel(( () => {
    const {broadcast: e} = useBroadcastModel()
      , t = ref([])
      , n = computed(( () => {
        var e;
        return null == (e = t.value[t.value.length - 1]) ? void 0 : e.value
    }
    ))
      , r = computed(( () => {
        var e;
        return null == (e = n.value) ? void 0 : e.sidebar
    }
    ))
      , o = computed(( () => {
        var e;
        return null == (e = n.value) ? void 0 : e.curFeed
    }
    ))
      , i = computed(( () => {
        var e;
        return !!(null == (e = n.value) ? void 0 : e.isSub)
    }
    ))
      , a = ref(!1)
      , s = (e, t) => {
        r.value.isExpand = null != e ? e : !r.value.isExpand,
        r.value.tabIndex = null != t ? t : r.value.tabIndex
    }
      , c = ref(!0)
      , l = () => {
        c.value = !1
    }
      , u = ref(0)
      , p = ref()
      , d = () => {
        document.fullscreenElement || (a.value = !!(null == document ? void 0 : document.fullscreenElement))
    }
    ;
    onMounted(( () => {
        window.addEventListener("fullscreenchange", d)
    }
    )),
    onUnmounted(( () => {
        p.value && clearInterval(p.value),
        window.removeEventListener("fullscreenchange", d)
    }
    ));
    const f = ref(!1)
      , h = ref(!1)
      , {userInteractive: m} = userCustomBehavior();
    return watch(( () => m.value), (e => {
        !c.value && isSSR || (p.value && e ? clearInterval(p.value) : c.value && !isSSR && (p.value && (clearInterval(p.value),
        u.value = 0),
        p.value = setInterval(( () => {
            u.value += 500,
            u.value >= 1e4 && !c.value && (l(),
            clearInterval(p.value))
        }
        ), 500)))
    }
    ), {
        immediate: !0
    }),
    {
        playouts: t,
        curPlayout: n,
        curSidebar: r,
        curFeed: o,
        curIsSub: i,
        isFullScreen: a,
        switchSidebar: s,
        openCommentSide: e => {
            var t, n;
            e && sendClickEvent("INTERACTION_COMMENT_BUTTON", {
                photo_id: (null == (n = null == (t = o.value) ? void 0 : t.photo) ? void 0 : n.id) || "",
                click_type: e
            }),
            s(0 !== r.value.tabIndex || !r.value.isExpand, 0)
        }
        ,
        openPhotoSide: e => {
            var t, n, i;
            e && sendClickEvent("INTERACTION_HEAD_BUTTON", {
                author_id: (null == (t = o.value) ? void 0 : t.author.id) || "",
                click_type: e,
                is_live: (null == (n = o.value) ? void 0 : n.author.livingInfo.living) ? 1 : 0
            }),
            s(1 !== (null == (i = r.value) ? void 0 : i.tabIndex) || !r.value.isExpand, 1)
        }
        ,
        flipFeedFn: (e, t) => {
            var r;
            return null == (r = n.value) ? void 0 : r.flipFeed(t, e)
        }
        ,
        switchFullScreen: (t="CLICK") => {
            var n, r, i;
            sendClickEvent("TOOLBAR_FULL_SCREEN__BUTTON", {
                click_type: t,
                photo_id: (null == (r = null == (n = o.value) ? void 0 : n.photo) ? void 0 : r.id) || ""
            }),
            a.value = !a.value,
            e("full-change", a.value),
            !(null == document ? void 0 : document.fullscreenElement) && a.value ? null == (i = document.documentElement) || i.requestFullscreen() : (null == document ? void 0 : document.fullscreenElement) && (null == document ? void 0 : document.exitFullscreen) && (null == document || document.exitFullscreen())
        }
        ,
        hideMuteTips: l,
        isVolumeHover: f,
        volumeTipsShow: h,
        showMuteTips: c
    }
}
))
  , useLayoutModel = () => useModel(layoutModel)
  , useVideoModel = createUseModel(( () => {
    const {curIsSub: e, showMuteTips: t, curFeed: n} = useLayoutModel()
      , {broadcast: r} = useBroadcastModel()
      , o = shallowRef(null)
      , i = shallowRef(null)
      , a = computed(( () => e.value ? i.value : o.value))
      , s = ref(!1)
      , c = ref({
        volume: .5,
        muted: !0,
        autoPlay: !0,
        speed: 1
    });
    watch(e, ( () => {
        var t, n, r, a, s, c, l, u, p, d, f, h;
        e.value ? ((null == (n = null == (t = o.value) ? void 0 : t.videoInstance) ? void 0 : n.isPictureInPicture.value) && (null == (a = null == (r = o.value) ? void 0 : r.videoInstance) || a.togglePictureInPicture()),
        null == (c = null == (s = o.value) ? void 0 : s.videoInstance) || c.pause()) : ((null == (u = null == (l = i.value) ? void 0 : l.videoInstance) ? void 0 : u.isPictureInPicture.value) && (null == (d = null == (p = i.value) ? void 0 : p.videoInstance) || d.togglePictureInPicture()),
        null == (h = null == (f = i.value) ? void 0 : f.videoInstance) || h.destroy(),
        i.value = null)
    }
    )),
    watch(o, ( (e, t) => {
        var n, r;
        (null == (n = null == t ? void 0 : t.videoInstance) ? void 0 : n.isPictureInPicture.value) && (null == (r = null == t ? void 0 : t.videoInstance) || r.togglePictureInPicture())
    }
    )),
    watch(a, ( (e, t) => {
        (null == t ? void 0 : t.videoInstance.currentTime.value) && r("video-change", {
            play_duration: null == t ? void 0 : t.videoInstance.currentTime.value
        })
    }
    )),
    watch(( () => [c.value.volume, c.value.muted]), ( () => {
        t.value && !c.value.muted && (t.value = !1)
    }
    ));
    const l = computed(( () => {
        var e;
        return null == (e = a.value) ? void 0 : e.videoInstance
    }
    ));
    computed(( () => {
        var e, t;
        return null != (t = null == (e = l.value) ? void 0 : e.muted.value) && t
    }
    ));
    const u = computed(( () => {
        var e, t;
        return null != (t = null == (e = l.value) ? void 0 : e.volume.value) ? t : 0
    }
    ))
      , p = computed(( () => {
        var e, t;
        return null != (t = null == (e = l.value) ? void 0 : e.state.value) ? t : "INIT"
    }
    ));
    computed(( () => {
        var e, t;
        return null == (t = null == (e = l.value) ? void 0 : e.paused.value) || t
    }
    ));
    const d = computed(( () => {
        var e, t;
        return Math.floor(null != (t = null == (e = l.value) ? void 0 : e.duration.value) ? t : 0)
    }
    ))
      , f = computed(( () => {
        var e, t;
        return Math.floor(null != (t = null == (e = l.value) ? void 0 : e.currentTime.value) ? t : 0)
    }
    ));
    onMounted(( () => {
        window.addEventListener("beforeunload", ( () => {
            var e, t, n, r;
            (null == (t = null == (e = a.value) ? void 0 : e.videoInstance) ? void 0 : t.isPictureInPicture.value) && (null == (r = null == (n = a.value) ? void 0 : n.videoInstance) || r.togglePictureInPicture())
        }
        ))
    }
    )),
    onBeforeUnmount(( () => {
        var e, t, n, r;
        (null == (t = null == (e = a.value) ? void 0 : e.videoInstance) ? void 0 : t.isPictureInPicture.value) && (null == (r = null == (n = a.value) ? void 0 : n.videoInstance) || r.togglePictureInPicture())
    }
    ));
    return {
        defineConfig: c,
        mainPlayerRef: o,
        subPlayerRef: i,
        currentPlayer: a,
        currentTime: f,
        duration: d,
        sharePanelVisible: s,
        state: p,
        handleVideoPlay: e => {
            var t, r, o, i;
            if (e) {
                const o = "PLAYING" === (null == p ? void 0 : p.value) ? "TOOLBAR_PAUSE_BUTTON" : "TOOLBAR_PLAY_BUTTON";
                sendClickEvent(o, {
                    click_type: e,
                    photo_id: (null == (r = null == (t = n.value) ? void 0 : t.photo) ? void 0 : r.id) || ""
                })
            }
            "PLAYING" === (null == p ? void 0 : p.value) ? null == (o = l.value) || o.pause() : null == (i = l.value) || i.play()
        }
        ,
        handleFastForward: () => {
            var e;
            null == (e = l.value) || e.seek(Math.min(f.value + 5, d.value))
        }
        ,
        handleFastBackward: () => {
            var e;
            null == (e = l.value) || e.seek(Math.max(f.value - 5, 0))
        }
        ,
        handleChangeSpeed: e => {
            var t;
            l.value && (null == (t = l.value) ? void 0 : t.speed.value) !== e && (l.value.speed = e)
        }
        ,
        handleAutoPlay: (e="CLICK") => {
            var t, r;
            sendClickEvent("TOOLBAR_CONTINUOUS_PLAY_BUTTON", {
                click_type: e,
                photo_id: (null == (r = null == (t = n.value) ? void 0 : t.photo) ? void 0 : r.id) || "",
                status: c.value.autoPlay ? "CLOSE" : "OPEN"
            }),
            c.value.autoPlay = !c.value.autoPlay
        }
        ,
        handlePictureInPicture: () => {
            var e;
            null == (e = l.value) || e.togglePictureInPicture()
        }
        ,
        handleVolumeChange: e => {
            l.value && (l.value.volume = Math.max(0, Math.min(1, u.value + e)))
        }
    }
}
));
var LoginSource = (e => (e.LIKE = "PC_DETAIL_LIKE",
e.COMMENT_LIKE = "PC_DETAIL_COMMENT_LIKE",
e.FOLLOW = "PC_DETAIL_FOLLOW_AUTHOR",
e.SHARE = "PC_DETAIL_SHARE",
e.COMMENT = "PC_DETAIL_COMMENT_BUTTON",
e.REPLY_COMMENT = "PC_DETAIL_REPLY_COMMENT_BUTTON",
e.TOP_LOGIN = "PC_TOP_LOGIN_BUTTON",
e.HEADER_LOGIN = "PC_HEADER_LOGIN_BUTTON",
e.HOME_LIVE = "PC_GAME_LIVE",
e.HOME_BRILLIANT = "PC_HOME_BRILLIANT",
e.HOME_NEARBY = "PC_HOME_NEARBY",
e.HOME_THEATER = "PC_HOME_THEATER",
e.HOME_AC = "PC_HOME_AC",
e.HOME_MOVIE = "PC_HOME_MOVIE",
e.BANNER = "PC_BANNER",
e.PROFILE = "PROFILE",
e.AVATAR = "PC_AUTHOR_HEAD_BUTTON",
e.SEARCH = "PC_TOP_SEARCH_BUTTON",
e.MYFOLLOW = "PC_TOP_MYFOLLOW_BUTTON",
e.BOTTOM_LOGIN = "PC_BOTTOM_LOGIN_BUTTON",
e.PROFILE_FOLLOW = "PC_PROFILE_FOLLOW_BUTTON",
e.PC_DAMAKU_INPUT_BUTTON = "PC_DAMAKU_INPUT_BUTTON",
e.PC_DAMAKU_LIKE_BUTTON = "PC_DAMAKU_LIKE_BUTTON",
e.PC_LIVE_AVATAR = "PC_LIVE_AVATAR",
e.PC_DETAIL_COMMENT_REPORT = "PC_DETAIL_COMMENT_REPORT",
e.PC_DETAIL_REPORT_BUTTON = "PC_DETAIL_REPORT_BUTTON",
e.NOT_INTERESTED = "NOT_INTERESTED",
e.AUTO_TRIGGER_LOGIN = "AUTO_TRIGGER_LOGIN",
e.DAYLY_GUIDE = "DAYLY_GUIDE",
e.PC_COLLECTION = "PC_COLLECTION",
e.FORCE_LOGIN_2056 = "FORCE_LOGIN_2056",
e))(LoginSource || {});
function isPrt() {
    return "kwai-beta.corp.kuaishou.com" === window.location.hostname
}
const IsPrtEnv = isPrt();
var WindowWidth = (e => (e[e.MINI = 576] = "MINI",
e[e.MD = 860] = "MD",
e[e.XL = 1440] = "XL",
e[e.MAX = 1660] = "MAX",
e))(WindowWidth || {});
const isFeed = e => void 0 !== e.author
  , isComment = e => void 0 !== e.comment_id
  , getReportType = e => {
    if (e)
        return isFeed(e) ? 1 : isComment(e) ? 8 : 2
}
  , reportModel = createModel(( () => {
    const e = useRestMutation({
        url: "/rest/v/report/menu",
        method: "POST"
    })
      , t = useRestMutation({
        url: "/rest/v/report/submit",
        method: "POST"
    });
    return {
        menuRest: e,
        submitRest: t,
        refetchMenu: t => e.mutate({
            page: "reco_detail",
            reportType: getReportType(t)
        }),
        submitReport: async (e, n, r) => {
            const o = getReportType(e);
            if (!o)
                return;
            const i = {
                extraPhotoId: "",
                page: "reco_detail",
                reportDetail: r,
                reportItem: n,
                reportType: o,
                reportedUserId: "",
                targetId: ""
            };
            return isFeed(e) ? (i.reportedUserId = e.author.id,
            i.targetId = e.photo.id) : isComment(e) ? (i.extraPhotoId = e.$photo.id,
            i.reportedUserId = e.author_id,
            i.targetId = e.comment_id) : (i.page = "PROFILE",
            i.reportedUserId = e,
            i.targetId = e),
            await t.mutate(i),
            t.info
        }
    }
}
))
  , useReportModel = () => useModel(reportModel);
var DialogId = (e => (e.Login = "login",
e.Jump = "jump",
e.Keyboard = "keyboard",
e.Report = "report",
e))(DialogId || {});
const useDialogModel = createUseModel(( () => {
    var e;
    const {isLogin: t} = useUserModel()
      , {currentPlayer: n} = useVideoModel()
      , r = null == (e = getCurrentInstance()) ? void 0 : e.proxy
      , o = new DialogQueue(r)
      , i = e => -1 !== o.queue.findIndex((t => t.id === e)) || o.currentDialogId === e
      , a = ({source: e}) => {
        var t;
        if (i("login"))
            return;
        null == (t = n.value) || t.videoInstance.pause();
        return o.createShowDialog(( () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./index-C3cmY9qv.js"))).then((e => e.i))), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), "")), "login")({
            source: e
        })
    }
      , s = (...e) => new Promise((n => {
        t.value ? n() : a(...e)
    }
    ));
    return {
        dialogQueue: o,
        showLoginDialog: a,
        verifyLogin: s,
        showJumpDialog: e => {
            var t;
            if (i("jump"))
                return;
            null == (t = n.value) || t.videoInstance.pause();
            return o.createShowDialog(( () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./jumpDialog-DmU7v4kn.js")))), __vite__mapDeps([10, 1, 2, 3, 4, 5, 6, 11]), "")), "jump")({
                info: e
            })
        }
        ,
        showKeyboardDialog: e => {
            var t;
            if (i("keyboard"))
                return;
            null == (t = n.value) || t.videoInstance.pause();
            return o.createShowDialog(( () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./keyboardDialog-Bs0-erVg.js")))), __vite__mapDeps([12, 1, 2, 3, 4, 5, 6, 13, 14]), "")), "keyboard")({})
        }
        ,
        showReportDialog: async e => {
            var t;
            if (await s({
                source: isFeed(e) ? LoginSource.PC_DETAIL_REPORT_BUTTON : LoginSource.PC_DETAIL_COMMENT_REPORT
            }),
            i("report"))
                return;
            null == (t = n.value) || t.videoInstance.pause();
            return o.createShowDialog(( () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./ReportDialog-HmpFZx9y.js")))), __vite__mapDeps([15, 1, 2, 3, 4, 5, 6, 16, 7, 8, 17, 18, 19, 20, 21]), "")), "report")({
                reportObj: e
            })
        }
    }
}
))
  , TRIGGERED_LOGIN_FREQUENCY = "triggered-login-frequency-A"
  , RECO_STAY_DURATION = "reco-stay-duration-W"
  , VIDEO_PLAY_DURATION = "video-play-duration-E"
  , VIDEO_FINISH_COUNT = "video-finish-count-R";
function sleep(e=0) {
    return new Promise((t => {
        setTimeout(( () => {
            t()
        }
        ), e)
    }
    ))
}
function justifyInPeriod(e) {
    const t = Number(localStorage.getItem(TRIGGERED_LOGIN_TIME))
      , n = Number(localStorage.getItem(TRIGGERED_LOGIN_FREQUENCY));
    if (t) {
        const r = new Date(t).setHours(0, 0, 0, 0)
          , o = new Date(t).setHours(23, 59, 59, 999)
          , i = Date.now();
        return i >= r && i <= o ? !!(e && n < e) : (localStorage.setItem(TRIGGERED_LOGIN_FREQUENCY, "0"),
        localStorage.setItem(VIDEO_FINISH_COUNT, "0"),
        localStorage.setItem(RECO_STAY_DURATION, "0"),
        localStorage.setItem(VIDEO_PLAY_DURATION, "0"),
        !0)
    }
    return !0
}
function loginFrequencyIncrement(e) {
    const t = Number(localStorage.getItem(TRIGGERED_LOGIN_FREQUENCY));
    return t + 1 > e || (localStorage.setItem(TRIGGERED_LOGIN_FREQUENCY, "".concat(t + 1)),
    !1)
}
function initLoginDialogGuide() {
    var e, t, n, r, o, i, a;
    const {useBroadCastStream: s} = useBroadcastModel()
      , {showLoginDialog: c} = useDialogModel()
      , l = ref(!1)
      , {route: u, router: p} = useRouter()
      , {loginConfigV2: d} = useKconfModel()
      , {isLogin: f} = useUserModel()
      , {info: h} = useABTestModel()
      , m = computed(( () => {
        var e;
        return null == (e = h.data) ? void 0 : e.loginGuideStrategy
    }
    ))
      , g = ref(u.value.name)
      , v = computed(( () => {
        var e;
        return (null == (e = d.value) ? void 0 : e.open) && !f.value
    }
    ))
      , y = computed(( () => {
        var e;
        return null == (e = d.value) ? void 0 : e.showTime
    }
    ))
      , _ = computed(( () => {
        var e, t;
        return null != (t = null == (e = d.value) ? void 0 : e.frequencyLimit) ? t : 1
    }
    ))
      , b = ref(!1)
      , E = usePageState()
      , {userInteractive: w} = userCustomBehavior()
      , S = ref(justifyInPeriod(_.value))
      , O = ref(0)
      , T = ref(-1)
      , A = ref(0)
      , R = ref(0)
      , k = ref(0)
      , P = ref(0)
      , $ = ref(0)
      , C = ref(!1)
      , I = ref(!1)
      , N = ref(("string" == typeof (null == (t = null == (e = u.value) ? void 0 : e.query) ? void 0 : t.streamSource) ? null == (r = null == (n = u.value) ? void 0 : n.query) ? void 0 : r.streamSource : null == (a = null == (i = null == (o = u.value) ? void 0 : o.query) ? void 0 : i.streamSource) ? void 0 : a[0]) || "");
    p.value.afterEach(( (e, t, n) => {
        var r, o, i, a;
        g.value = e.name,
        N.value = ("string" == typeof (null == (r = null == e ? void 0 : e.query) ? void 0 : r.streamSource) ? null == (o = null == e ? void 0 : e.query) ? void 0 : o.streamSource : null == (a = null == (i = null == e ? void 0 : e.query) ? void 0 : i.streamSource) ? void 0 : a[0]) || ""
    }
    ));
    const L = computed(( () => {
        var e, t, n, r;
        return 0 === (null == (t = null == (e = m.value) ? void 0 : e.effectPages) ? void 0 : t.length) || (null == (r = null == (n = m.value) ? void 0 : n.effectPages) ? void 0 : r.includes(N.value)) || "" === N.value
    }
    ));
    function x() {
        var e, t, n;
        k.value = null != (e = Number(localStorage.getItem(VIDEO_FINISH_COUNT))) ? e : 0,
        $.value = null != (t = Number(localStorage.getItem(VIDEO_PLAY_DURATION))) ? t : 0,
        g.value === RouteName.NewReco && (A.value = (new Date).getTime() - (null != (n = Number(localStorage.getItem(RECO_STAY_DURATION))) ? n : 0))
    }
    function M() {
        f.value || (T.value && (clearInterval(T.value),
        O.value = y.value),
        T.value = null == window ? void 0 : window.setInterval(( () => {
            O.value -= 500,
            O.value <= 0 && y.value && (b.value = !0,
            S.value = justifyInPeriod(_.value),
            clearInterval(T.value))
        }
        ), 500))
    }
    return watch(( () => w.value), (e => {
        !b.value && S.value && !l.value && g.value === RouteName.Home && v.value && (T.value && e ? clearInterval(T.value) : e || g.value !== RouteName.Home || M())
    }
    )),
    watch(( () => E.value), (e => {
        if (b.value || !S.value || l.value)
            localStorage.removeItem(HOME_LEAVE_TIME);
        else if (g.value === RouteName.Home && v.value)
            if (e) {
                const e = Number(localStorage.getItem(HOME_LEAVE_TIME)) || Date.now();
                O.value -= Date.now() - e,
                O.value <= 0 && y.value ? b.value = !0 : M()
            } else
                clearInterval(T.value),
                localStorage.setItem(HOME_LEAVE_TIME, "".concat(Date.now()))
    }
    )),
    watch(( () => b.value), (e => {
        var t;
        if (!(null != (t = f.value) ? t : g.value !== RouteName.Home) && e && !l.value) {
            if (loginFrequencyIncrement(_.value))
                return;
            localStorage.setItem(TRIGGERED_LOGIN_TIME, "".concat(Date.now())),
            c({
                source: LoginSource.AUTO_TRIGGER_LOGIN
            })
        }
    }
    )),
    s("show-login", (e => {
        g.value === RouteName.Home && (l.value = !!(null == e ? void 0 : e.show),
        l.value ? (b.value = !1,
        T.value && (clearInterval(T.value),
        O.value = y.value)) : v.value && S.value && M())
    }
    )),
    s("full-change", (async e => {
        I.value = !!e
    }
    )),
    s("video-ended", ( () => {
        L.value && (k.value++,
        C.value = !0)
    }
    )),
    s("video-play-change", (e => {
        var t, n, r, o, i, a, s;
        if (void 0 !== e && !(null != (t = f.value) ? t : g.value === RouteName.Home) && (null == (n = m.value) ? void 0 : n.open) && justifyInPeriod(null == (r = m.value) ? void 0 : r.dailyTimesLimit) && L.value && (e ? P.value = (new Date).getTime() : P.value && ($.value += (new Date).getTime() - P.value),
        e && C.value && !I.value)) {
            if (k.value >= (null == (o = m.value) ? void 0 : o.playCountLimit) || (null == (i = m.value) ? void 0 : i.playTimeLimit) <= Math.floor($.value / 6e4) || g.value === RouteName.NewReco && A.value && (null == (a = m.value) ? void 0 : a.stayTimeLimit) <= Math.floor(R.value / 6e4)) {
                if (loginFrequencyIncrement(null == (s = m.value) ? void 0 : s.dailyTimesLimit))
                    return;
                c({
                    source: LoginSource.DAYLY_GUIDE
                }),
                k.value = 0,
                $.value = 0,
                P.value = 0,
                localStorage.setItem(VIDEO_FINISH_COUNT, "0"),
                localStorage.setItem(RECO_STAY_DURATION, "0"),
                localStorage.setItem(VIDEO_PLAY_DURATION, "0"),
                localStorage.setItem(TRIGGERED_LOGIN_TIME, "".concat(Date.now())),
                g.value === RouteName.NewReco && A.value && (A.value = (new Date).getTime())
            }
            C.value = !1
        }
    }
    )),
    s("video-change", (e => {
        var t, n;
        g.value !== RouteName.Home && (null == (t = m.value) ? void 0 : t.open) && justifyInPeriod(null == (n = m.value) ? void 0 : n.dailyTimesLimit) && L.value && (null == e ? void 0 : e.play_duration) && !C.value && ($.value += e.play_duration)
    }
    )),
    watch(( () => E.value), (async e => {
        var t, n;
        (null == (t = m.value) ? void 0 : t.open) && justifyInPeriod(null == (n = m.value) ? void 0 : n.dailyTimesLimit) && L.value && (e ? (await sleep(100),
        !l.value && x()) : (k.value && localStorage.setItem(VIDEO_FINISH_COUNT, "".concat(k.value)),
        A.value && localStorage.setItem(RECO_STAY_DURATION, "".concat((new Date).getTime() - A.value)),
        $.value && localStorage.setItem(VIDEO_PLAY_DURATION, "".concat($.value))))
    }
    )),
    watch(( () => g.value), (e => {
        var t;
        b.value || !S.value || l.value || v.value && (e !== RouteName.Home ? (clearInterval(T.value),
        b.value = !1) : M(),
        e === RouteName.NewReco ? A.value = (new Date).getTime() - (null != (t = Number(localStorage.getItem(RECO_STAY_DURATION))) ? t : 0) : A.value = 0)
    }
    ), {
        immediate: !0
    }),
    onMounted(( () => {
        isSSR || (x(),
        g.value === RouteName.Home && (v.value && S.value ? M() : clearInterval(T.value)))
    }
    )),
    {
        userInteractive: w
    }
}
const base = ""
  , createAppRouter = () => createRouter({
    history: createWebHistory(base),
    routes: [{
        path: "/new-reco",
        name: RouteName.NewReco,
        component: () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./reco-CJplC6mL.js")))), __vite__mapDeps([22, 23, 2, 3, 4, 5, 13, 24, 7, 8, 17, 18, 25, 16, 19, 26, 27, 28, 29]), ""),
        meta: {
            LOG_PAGE: RouteName.NewReco
        }
    }, {
        path: "/profile/:userId",
        name: RouteName.Profile,
        component: () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./profile-DEPE0XXc.js")))), __vite__mapDeps([30, 23, 2, 3, 4, 5, 13, 24, 7, 8, 17, 18, 25, 16, 19, 26, 20, 31, 32, 33]), ""),
        meta: {
            page: "PROFILE",
            LOG_PAGE: RouteName.Profile
        },
        props: !0
    }, {
        path: "/404",
        name: RouteName.Error,
        component: () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./error-QNS3FMl2.js")))), __vite__mapDeps([34, 7, 8, 24, 3, 4, 17, 18, 25, 35]), ""),
        meta: {
            LOG_PAGE: RouteName.Error
        }
    }, {
        path: "/favicon.ico",
        name: "Favicon",
        component: () => __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./favicon-DAbxISKU.js")))), [], "")
    }, {
        path: "/:pathMatch(.*)*",
        redirect: "/404"
    }]
})
  , routeName = ref("");
function isInternalLink(e) {
    return e.startsWith("/")
}
function openUrl(e, t, n) {
    const r = null != t ? t : !isInternalLink(e)
      , o = new URL(e,window.location.href);
    IsPrtEnv && PRT_HOST_MAP.has(o.hostname) && (o.hostname = PRT_HOST_MAP.get(o.hostname)),
    o.searchParams.get(SearchParamsName.source) || o.searchParams.set(SearchParamsName.source, routeName.value),
    n && Object.keys(n).forEach((e => {
        o.searchParams.set(e, n[e])
    }
    )),
    r ? window.open(o.href) : window.location.href = o.href
}
function getQueryParams(e, t, n) {
    var r;
    return null != (r = new URLSearchParams(window.location.search).get(e)) ? r : t
}
function backHome() {
    openUrl("/?isHome=1", !1)
}
const _export_sfc = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r,o] of t)
        n[r] = o;
    return n
}
  , _sfc_main$1 = {}
  , _hoisted_1$1 = {
    class: "global-protect-popup"
};
function _sfc_render(e, t) {
    return openBlock(),
    createElementBlock("div", _hoisted_1$1, t[0] || (t[0] = [createBaseVNode("div", {
        class: "title"
    }, "温馨提示", -1), createBaseVNode("div", {
        class: "content-word"
    }, [createBaseVNode("div", {
        class: "content"
    }, " 当前页面近期异常访问较多，系统已开启保护，请到APP内继续观看 ")], -1)]))
}
const GlobalProtectPopup = _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-2ae3a073"]])
  , _hoisted_1 = {
    class: "Kwai"
}
  , _hoisted_2 = {
    key: 0,
    class: "is-dev"
}
  , _hoisted_3 = {
    key: 1,
    class: "popup-wrapper"
}
  , _sfc_main = defineComponent({
    __name: "App",
    setup(e) {
        const t = useRoute$1()
          , {sendShow: n} = useLogger()
          , {initSSO: r, checkLogin: o} = useModel(loginModel)
          , {showLoginDialog: i} = useDialogModel()
          , a = ref(!1)
          , s = () => {
            a.value = !0
        }
          , c = () => {
            i({
                source: LoginSource.FORCE_LOGIN_2056
            })
        }
        ;
        function l() {
            window.resizeBy(100, 0),
            window.moveBy(100, 0)
        }
        watch(( () => t.name), (e => {
            routeName.value = String(e)
        }
        ), {
            immediate: !0
        }),
        useHead({
            title: "快手"
        }),
        onMounted(( () => {
            var e, o;
            n("ENTER_PC_SOURCE", {
                urlPage: {
                    page: "APP_GENERAL"
                },
                page: null == (e = t.meta) ? void 0 : e.LOG_PAGE,
                source: null == (o = null == t ? void 0 : t.query) ? void 0 : o.source
            }),
            window.addEventListener("appinstalled", l),
            r(),
            sendFmp(),
            window.addEventListener("force-login", c),
            window.addEventListener("global-protect-popup", s)
        }
        )),
        onBeforeUnmount(( () => {
            window.removeEventListener("appinstalled", l),
            window.removeEventListener("force-login", c),
            window.removeEventListener("global-protect-popup", s)
        }
        ));
        const u = usePageState();
        watch(( () => u.value), (e => {
            e && o()
        }
        ));
        return !isSSR && useBroadcastModel(),
        !isSSR && initLoginDialogGuide(),
        (e, t) => (openBlock(),
        createElementBlock("div", _hoisted_1, [createVNode(unref(RouterView)), unref(false) ? (openBlock(),
        createElementBlock("div", _hoisted_2, "dev")) : createCommentVNode("", !0), unref(a) ? (openBlock(),
        createElementBlock("div", _hoisted_3, [createVNode(GlobalProtectPopup)])) : createCommentVNode("", !0)]))
    }
})
  , AppComponent = _export_sfc(_sfc_main, [["__scopeId", "data-v-86c12cba"]]);
function createRequestInterceptors(e, t, {mock: n=!1, mockHost: r="http://localhost:6173"}={
    mock: !1
}) {
    return e => {
        if (!e.url)
            throw new Error("请求缺少url");
        return e
    }
}
var define_process_env_default = {};
function initStore(e, t, n={}, r=!1) {
    var o;
    const i = createStore()
      , a = createClient("REST", {
        method: "get",
        timeout: 1e5,
        ...n,
        headers: {
            ...null != (o = n.headers) ? o : {},
            ...ut$1()
        },
        fetch: t
    });
    a.interceptors.response.use((e => {
        var t, n, r;
        const o = e.data;
        if (!o)
            return;
        console.log("data", o);
        const i = (null == (t = null == o ? void 0 : o.data) ? void 0 : t.result) || (null == o ? void 0 : o.result);
        return 2056 === i && (null == window || window.dispatchEvent(new CustomEvent("force-login",{
            detail: {
                source: LoginSource.FORCE_LOGIN_2056
            }
        }))),
        7935 === i && (null == window || window.dispatchEvent(new CustomEvent("global-protect-popup"))),
        o.error ? Promise.reject(o.error) : e.config.url.includes("/rest/v/kconf/get") ? {
            ...o.data,
            ...null == (n = o.data) ? void 0 : n.data
        } : null != (r = o.data) ? r : o
    }
    ));
    const s = r ? define_process_env_default.SERVER_PC_API : "https://pc-pre.test.gifshow.com"
      , c = r ? define_process_env_default.WEB_LIVE_API : "http://gzone-web-stable.test.gifshow.com";
    a.interceptors.request.use(createRequestInterceptors(( () => ({
        "/pass/kuaishou/profile/get": "https://id.kuaishou.com",
        "/rest/v/system/configs": s,
        "/rest/v/system/startup": s,
        "/rest/v/kconf/get": s,
        "/rest/k/emotion/package/list": c
    })), !1, {
        mock: !1
    })),
    i.registerClient(a),
    e.use(i, r)
}
var zhCn = {
    exports: {}
};
zhCn.exports = function(e) {
    function t(e) {
        return e && "object" == typeof e && "default"in e ? e : {
            default: e
        }
    }
    var n = t(e)
      , r = {
        name: "zh-cn",
        weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
        weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
        weekdaysMin: "日_一_二_三_四_五_六".split("_"),
        months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
        ordinal: function(e, t) {
            return "W" === t ? e + "周" : e + "日"
        },
        weekStart: 1,
        yearStart: 4,
        formats: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYY年M月D日",
            LLL: "YYYY年M月D日Ah点mm分",
            LLLL: "YYYY年M月D日ddddAh点mm分",
            l: "YYYY/M/D",
            ll: "YYYY年M月D日",
            lll: "YYYY年M月D日 HH:mm",
            llll: "YYYY年M月D日dddd HH:mm"
        },
        relativeTime: {
            future: "%s内",
            past: "%s前",
            s: "几秒",
            m: "1 分钟",
            mm: "%d 分钟",
            h: "1 小时",
            hh: "%d 小时",
            d: "1 天",
            dd: "%d 天",
            M: "1 个月",
            MM: "%d 个月",
            y: "1 年",
            yy: "%d 年"
        },
        meridiem: function(e, t) {
            var n = 100 * e + t;
            return n < 600 ? "凌晨" : n < 900 ? "早上" : n < 1100 ? "上午" : n < 1300 ? "中午" : n < 1800 ? "下午" : "晚上"
        }
    };
    return n.default.locale(r, null, !0),
    r
}(dayjs_minExports);
var dist = {};
Object.defineProperty(dist, "__esModule", {
    value: !0
}),
dist.TokenData = void 0,
dist.parse = parse,
dist.compile = compile,
dist.match = match;
var pathToRegexp_1 = dist.pathToRegexp = pathToRegexp;
dist.stringify = stringify;
const DEFAULT_DELIMITER = "/"
  , NOOP_VALUE = e => e
  , ID_START = /^[$_\p{ID_Start}]$/u
  , ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u
  , DEBUG_URL = "https://git.new/pathToRegexpError"
  , SIMPLE_TOKENS = {
    "{": "{",
    "}": "}",
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
};
function escapeText(e) {
    return e.replace(/[{}()\[\]+?!:*]/g, "\\$&")
}
function escape$1(e) {
    return e.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&")
}
function *lexer(e) {
    const t = [...e];
    let n = 0;
    function r() {
        let e = "";
        if (ID_START.test(t[++n]))
            for (e += t[n]; ID_CONTINUE.test(t[++n]); )
                e += t[n];
        else if ('"' === t[n]) {
            let r = n;
            for (; n < t.length; ) {
                if ('"' === t[++n]) {
                    n++,
                    r = 0;
                    break
                }
                e += "\\" === t[n] ? t[++n] : t[n]
            }
            if (r)
                throw new TypeError("Unterminated quote at ".concat(r, ": ").concat(DEBUG_URL))
        }
        if (!e)
            throw new TypeError("Missing parameter name at ".concat(n, ": ").concat(DEBUG_URL));
        return e
    }
    for (; n < t.length; ) {
        const e = t[n]
          , o = SIMPLE_TOKENS[e];
        if (o)
            yield{
                type: o,
                index: n++,
                value: e
            };
        else if ("\\" === e)
            yield{
                type: "ESCAPED",
                index: n++,
                value: t[n++]
            };
        else if (":" === e) {
            const e = r();
            yield{
                type: "PARAM",
                index: n,
                value: e
            }
        } else if ("*" === e) {
            const e = r();
            yield{
                type: "WILDCARD",
                index: n,
                value: e
            }
        } else
            yield{
                type: "CHAR",
                index: n,
                value: t[n++]
            }
    }
    return {
        type: "END",
        index: n,
        value: ""
    }
}
class Iter {
    constructor(e) {
        this.tokens = e
    }
    peek() {
        if (!this._peek) {
            const e = this.tokens.next();
            this._peek = e.value
        }
        return this._peek
    }
    tryConsume(e) {
        const t = this.peek();
        if (t.type === e)
            return this._peek = void 0,
            t.value
    }
    consume(e) {
        const t = this.tryConsume(e);
        if (void 0 !== t)
            return t;
        const {type: n, index: r} = this.peek();
        throw new TypeError("Unexpected ".concat(n, " at ").concat(r, ", expected ").concat(e, ": ").concat(DEBUG_URL))
    }
    text() {
        let e, t = "";
        for (; e = this.tryConsume("CHAR") || this.tryConsume("ESCAPED"); )
            t += e;
        return t
    }
}
class TokenData {
    constructor(e) {
        this.tokens = e
    }
}
function parse(e, t={}) {
    const {encodePath: n=NOOP_VALUE} = t
      , r = new Iter(lexer(e));
    const o = function e(t) {
        const o = [];
        for (; ; ) {
            const i = r.text();
            i && o.push({
                type: "text",
                value: n(i)
            });
            const a = r.tryConsume("PARAM");
            if (a) {
                o.push({
                    type: "param",
                    name: a
                });
                continue
            }
            const s = r.tryConsume("WILDCARD");
            if (s) {
                o.push({
                    type: "wildcard",
                    name: s
                });
                continue
            }
            if (!r.tryConsume("{"))
                return r.consume(t),
                o;
            o.push({
                type: "group",
                tokens: e("}")
            })
        }
    }("END");
    return new TokenData(o)
}
function compile(e, t={}) {
    const {encode: n=encodeURIComponent, delimiter: r=DEFAULT_DELIMITER} = t
      , o = tokensToFunction((e instanceof TokenData ? e : parse(e, t)).tokens, r, n);
    return function(e={}) {
        const [t,...n] = o(e);
        if (n.length)
            throw new TypeError("Missing parameters: ".concat(n.join(", ")));
        return t
    }
}
function tokensToFunction(e, t, n) {
    const r = e.map((e => tokenToFunction(e, t, n)));
    return e => {
        const t = [""];
        for (const n of r) {
            const [r,...o] = n(e);
            t[0] += r,
            t.push(...o)
        }
        return t
    }
}
function tokenToFunction(e, t, n) {
    if ("text" === e.type)
        return () => [e.value];
    if ("group" === e.type) {
        const r = tokensToFunction(e.tokens, t, n);
        return e => {
            const [t,...n] = r(e);
            return n.length ? [""] : [t]
        }
    }
    const r = n || NOOP_VALUE;
    return "wildcard" === e.type && !1 !== n ? n => {
        const o = n[e.name];
        if (null == o)
            return ["", e.name];
        if (!Array.isArray(o) || 0 === o.length)
            throw new TypeError('Expected "'.concat(e.name, '" to be a non-empty array'));
        return [o.map(( (t, n) => {
            if ("string" != typeof t)
                throw new TypeError('Expected "'.concat(e.name, "/").concat(n, '" to be a string'));
            return r(t)
        }
        )).join(t)]
    }
    : t => {
        const n = t[e.name];
        if (null == n)
            return ["", e.name];
        if ("string" != typeof n)
            throw new TypeError('Expected "'.concat(e.name, '" to be a string'));
        return [r(n)]
    }
}
function match(e, t={}) {
    const {decode: n=decodeURIComponent, delimiter: r=DEFAULT_DELIMITER} = t
      , {regexp: o, keys: i} = pathToRegexp(e, t)
      , a = i.map((e => !1 === n ? NOOP_VALUE : "param" === e.type ? n : e => e.split(r).map(n)));
    return function(e) {
        const t = o.exec(e);
        if (!t)
            return !1;
        const n = t[0]
          , r = Object.create(null);
        for (let o = 1; o < t.length; o++) {
            if (void 0 === t[o])
                continue;
            const e = i[o - 1]
              , n = a[o - 1];
            r[e.name] = n(t[o])
        }
        return {
            path: n,
            params: r
        }
    }
}
function pathToRegexp(e, t={}) {
    const {delimiter: n=DEFAULT_DELIMITER, end: r=!0, sensitive: o=!1, trailing: i=!0} = t
      , a = []
      , s = []
      , c = o ? "" : "i"
      , l = (Array.isArray(e) ? e : [e]).map((e => e instanceof TokenData ? e : parse(e, t)));
    for (const {tokens: p} of l)
        for (const e of flatten(p, 0, [])) {
            const t = sequenceToRegExp(e, n, a);
            s.push(t)
        }
    let u = "^(?:".concat(s.join("|"), ")");
    i && (u += "(?:".concat(escape$1(n), "$)?")),
    u += r ? "$" : "(?=".concat(escape$1(n), "|$)");
    return {
        regexp: new RegExp(u,c),
        keys: a
    }
}
function *flatten(e, t, n) {
    if (t === e.length)
        return yield n;
    const r = e[t];
    if ("group" === r.type) {
        const o = n.slice();
        for (const n of flatten(r.tokens, 0, o))
            yield*flatten(e, t + 1, n)
    } else
        n.push(r);
    yield*flatten(e, t + 1, n)
}
function sequenceToRegExp(e, t, n) {
    let r = ""
      , o = ""
      , i = !0;
    for (let a = 0; a < e.length; a++) {
        const s = e[a];
        if ("text" !== s.type)
            if ("param" !== s.type && "wildcard" !== s.type)
                ;
            else {
                if (!i && !o)
                    throw new TypeError('Missing text after "'.concat(s.name, '": ').concat(DEBUG_URL));
                "param" === s.type ? r += "(".concat(negate(t, i ? "" : o), "+)") : r += "([\\s\\S]+)",
                n.push(s),
                o = "",
                i = !1
            }
        else
            r += escape$1(s.value),
            o += s.value,
            i || (i = s.value.includes(t))
    }
    return r
}
function negate(e, t) {
    return t.length < 2 ? e.length < 2 ? "[^".concat(escape$1(e + t), "]") : "(?:(?!".concat(escape$1(e), ")[^").concat(escape$1(t), "])") : e.length < 2 ? "(?:(?!".concat(escape$1(t), ")[^").concat(escape$1(e), "])") : "(?:(?!".concat(escape$1(t), "|").concat(escape$1(e), ")[\\s\\S])")
}
function stringify(e) {
    return e.tokens.map((function e(t, n, r) {
        if ("text" === t.type)
            return escapeText(t.value);
        if ("group" === t.type)
            return "{".concat(t.tokens.map(e).join(""), "}");
        const o = isNameSafe(t.name) && isNextNameSafe(r[n + 1]) ? t.name : JSON.stringify(t.name);
        if ("param" === t.type)
            return ":".concat(o);
        if ("wildcard" === t.type)
            return "*".concat(o);
        throw new TypeError("Unexpected token: ".concat(t))
    }
    )).join("")
}
function isNameSafe(e) {
    const [t,...n] = e;
    return !!ID_START.test(t) && n.every((e => ID_CONTINUE.test(e)))
}
function isNextNameSafe(e) {
    return "text" !== (null == e ? void 0 : e.type) || !ID_CONTINUE.test(e.value[0])
}
dist.TokenData = TokenData;
var LIBVERSION = "2.0.3", UA_MAX_LENGTH = 500, USER_AGENT = "user-agent", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", UA_BROWSER = "browser", UA_CPU = "cpu", UA_DEVICE = "device", UA_ENGINE = "engine", UA_OS = "os", UA_RESULT = "result", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", MAJOR = "major", MODEL = "model", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", XR = "xr", EMBEDDED = "embedded", INAPP = "inapp", BRANDS = "brands", FORMFACTORS = "formFactors", FULLVERLIST = "fullVersionList", PLATFORM = "platform", PLATFORMVER = "platformVersion", BITNESS = "bitness", CH_HEADER = "sec-ch-ua", CH_HEADER_FULL_VER_LIST = CH_HEADER + "-full-version-list", CH_HEADER_ARCH = CH_HEADER + "-arch", CH_HEADER_BITNESS = CH_HEADER + "-" + BITNESS, CH_HEADER_FORM_FACTORS = CH_HEADER + "-form-factors", CH_HEADER_MOBILE = CH_HEADER + "-" + MOBILE, CH_HEADER_MODEL = CH_HEADER + "-" + MODEL, CH_HEADER_PLATFORM = CH_HEADER + "-" + PLATFORM, CH_HEADER_PLATFORM_VER = CH_HEADER_PLATFORM + "-version", CH_ALL_VALUES = [BRANDS, FULLVERLIST, MOBILE, MODEL, PLATFORM, PLATFORMVER, ARCHITECTURE, FORMFACTORS, BITNESS], AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", GOOGLE = "Google", HUAWEI = "Huawei", LENOVO = "Lenovo", HONOR = "Honor", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", NVIDIA = "Nvidia", ONEPLUS = "OnePlus", OPPO = "OPPO", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", CHROME = "Chrome", CHROMIUM = "Chromium", CHROMECAST = "Chromecast", EDGE = "Edge", FIREFOX = "Firefox", OPERA = "Opera", FACEBOOK = "Facebook", SOGOU = "Sogou", PREFIX_MOBILE = "Mobile ", SUFFIX_BROWSER = " Browser", WINDOWS = "Windows", isWindow = typeof window !== UNDEF_TYPE, NAVIGATOR = isWindow && window.navigator ? window.navigator : void 0, NAVIGATOR_UADATA = NAVIGATOR && NAVIGATOR.userAgentData ? NAVIGATOR.userAgentData : void 0, extend = function(e, t) {
    var n = {}
      , r = t;
    if (!isExtensions(t))
        for (var o in r = {},
        t)
            for (var i in t[o])
                r[i] = t[o][i].concat(r[i] ? r[i] : []);
    for (var a in e)
        n[a] = r[a] && r[a].length % 2 == 0 ? r[a].concat(e[a]) : e[a];
    return n
}, enumerize = function(e) {
    for (var t = {}, n = 0; n < e.length; n++)
        t[e[n].toUpperCase()] = e[n];
    return t
}, has = function(e, t) {
    if (typeof e === OBJ_TYPE && e.length > 0) {
        for (var n in e)
            if (lowerize(e[n]) == lowerize(t))
                return !0;
        return !1
    }
    return !!isString(e) && -1 !== lowerize(t).indexOf(lowerize(e))
}, isExtensions = function(e, t) {
    for (var n in e)
        return /^(browser|cpu|device|engine|os)$/.test(n) || !!t && isExtensions(e[n])
}, isString = function(e) {
    return typeof e === STR_TYPE
}, itemListToArray = function(e) {
    if (e) {
        for (var t = [], n = strip(/\\?\"/g, e).split(","), r = 0; r < n.length; r++)
            if (n[r].indexOf(";") > -1) {
                var o = trim(n[r]).split(";v=");
                t[r] = {
                    brand: o[0],
                    version: o[1]
                }
            } else
                t[r] = trim(n[r]);
        return t
    }
}, lowerize = function(e) {
    return isString(e) ? e.toLowerCase() : e
}, majorize = function(e) {
    return isString(e) ? strip(/[^\d\.]/g, e).split(".")[0] : void 0
}, setProps = function(e) {
    for (var t in e) {
        var n = e[t];
        typeof n == OBJ_TYPE && 2 == n.length ? this[n[0]] = n[1] : this[n] = void 0
    }
    return this
}, strip = function(e, t) {
    return isString(t) ? t.replace(e, EMPTY) : t
}, stripQuotes = function(e) {
    return strip(/\\?\"/g, e)
}, trim = function(e, t) {
    if (isString(e))
        return e = strip(/^\s\s*/, e),
        typeof t === UNDEF_TYPE ? e : e.substring(0, UA_MAX_LENGTH)
}, rgxMapper = function(e, t) {
    if (e && t)
        for (var n, r, o, i, a, s, c = 0; c < t.length && !a; ) {
            var l = t[c]
              , u = t[c + 1];
            for (n = r = 0; n < l.length && !a && l[n]; )
                if (a = l[n++].exec(e))
                    for (o = 0; o < u.length; o++)
                        s = a[++r],
                        typeof (i = u[o]) === OBJ_TYPE && i.length > 0 ? 2 === i.length ? typeof i[1] == FUNC_TYPE ? this[i[0]] = i[1].call(this, s) : this[i[0]] = i[1] : 3 === i.length ? typeof i[1] !== FUNC_TYPE || i[1].exec && i[1].test ? this[i[0]] = s ? s.replace(i[1], i[2]) : void 0 : this[i[0]] = s ? i[1].call(this, s, i[2]) : void 0 : 4 === i.length && (this[i[0]] = s ? i[3].call(this, s.replace(i[1], i[2])) : void 0) : this[i] = s || void 0;
            c += 2
        }
}, strMapper = function(e, t) {
    for (var n in t)
        if (typeof t[n] === OBJ_TYPE && t[n].length > 0) {
            for (var r = 0; r < t[n].length; r++)
                if (has(t[n][r], e))
                    return n === UNKNOWN ? void 0 : n
        } else if (has(t[n], e))
            return n === UNKNOWN ? void 0 : n;
    return t.hasOwnProperty("*") ? t["*"] : e
}, windowsVersionMap = {
    ME: "4.90",
    "NT 3.11": "NT3.51",
    "NT 4.0": "NT4.0",
    2e3: "NT 5.0",
    XP: ["NT 5.1", "NT 5.2"],
    Vista: "NT 6.0",
    7: "NT 6.1",
    8: "NT 6.2",
    8.1: "NT 6.3",
    10: ["NT 6.4", "NT 10.0"],
    RT: "ARM"
}, formFactorsMap = {
    embedded: "Automotive",
    mobile: "Mobile",
    tablet: ["Tablet", "EInk"],
    smarttv: "TV",
    wearable: "Watch",
    xr: ["VR", "XR"],
    "?": ["Desktop", "Unknown"],
    "*": void 0
}, defaultRegexes = {
    browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i], [VERSION, [NAME, OPERA + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " GX"]], [/\bopr\/([\w\.]+)/i], [VERSION, [NAME, OPERA]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [VERSION, [NAME, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser)\/([-\w\.]+)/i, /(heytap|ovi|115|surf)browser\/([\d\.]+)/i, /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i], [NAME, VERSION], [/quark(?:pc)?\/([-\w\.]+)/i], [VERSION, [NAME, "Quark"]], [/\bddg\/([\w\.]+)/i], [VERSION, [NAME, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION, [NAME, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [VERSION, [NAME, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [VERSION, [NAME, "Smart " + LENOVO + SUFFIX_BROWSER]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure" + SUFFIX_BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]], [/fxios\/([\w\.-]+)/i], [VERSION, [NAME, PREFIX_MOBILE + FIREFOX]], [/\bqihoobrowser\/?([\w\.]*)/i], [VERSION, [NAME, "360"]], [/\b(qq)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1Browser"], VERSION], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION], [/samsungbrowser\/([\w\.]+)/i], [VERSION, [NAME, SAMSUNG + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [VERSION, [NAME, SOGOU + " Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[NAME, SOGOU + " Mobile"], VERSION], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [NAME, VERSION], [/(lbbrowser|rekonq)/i], [NAME], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [VERSION, NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, FACEBOOK], VERSION, [TYPE, INAPP]], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /(daum)apps[\/ ]([\w\.]+)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(instagram|snapchat)[\/ ]([-\w\.]+)/i], [NAME, VERSION, [TYPE, INAPP]], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION, [NAME, "GSA"], [TYPE, INAPP]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [VERSION, [NAME, "TikTok"], [TYPE, INAPP]], [/\[(linkedin)app\]/i], [NAME, [TYPE, INAPP]], [/(chromium)[\/ ]([-\w\.]+)/i], [NAME, VERSION], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION, [NAME, "Android" + SUFFIX_BROWSER]], [/chrome\/([\w\.]+) mobile/i], [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i], [VERSION, [NAME, PREFIX_MOBILE + "Safari"]], [/iphone .*mobile(?:\/\w+ | ?)safari/i], [[NAME, PREFIX_MOBILE + "Safari"]], [/version\/([\w\.\,]+) .*(safari)/i], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION, "1"]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [/(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i], [[NAME, PREFIX_MOBILE + FIREFOX], VERSION], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION], [/(wolvic|librewolf)\/([\w\.]+)/i], [NAME, VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /\b(links) \(([\w\.]+)/i], [NAME, [VERSION, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [NAME, [VERSION, /[^\d\.]+./, EMPTY]]],
    cpu: [[/\b((amd|x|x86[-_]?|wow|win)64)\b/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i, /\b((i[346]|x)86)(pc)?\b/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?[89]e?l?|_?64))\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i], [[ARCHITECTURE, "arm"]], [/((ppc|powerpc)(64)?)( mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/ sun4\w[;\)]/i], [[ARCHITECTURE, "sparc"]], [/\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]],
    device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [/\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i], [MODEL, [VENDOR, HONOR], [TYPE, TABLET]], [/honor([-\w ]+)[;\)]/i], [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]], [/\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i, /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i, / ([\w ]+) miui\/v?\d/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]], [/\b(opd2(\d{3}a?))(?: bui|\))/i], [MODEL, [VENDOR, strMapper, {
        OnePlus: ["304", "403", "203"],
        "*": OPPO
    }], [TYPE, TABLET]], [/(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i], [MODEL, [VENDOR, "BLU"], [TYPE, MOBILE]], [/; vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch))(\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i, /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i], [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]], [/(nokia) (t[12][01])/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i, /nokia[-_ ]?(([-\w\. ]*))/i], [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]], [/(pixel (c|tablet))\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/tcl (xess p17aa)/i, /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i], [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]], [/droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i], [MODEL, [VENDOR, "TCL"], [TYPE, MOBILE]], [/(itel) ((\w+))/i], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, {
        tablet: ["p10001l", "w7001"],
        "*": "mobile"
    }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]], [/droid.+; (a(?:015|06[35]|142p?))/i], [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]], [/; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i, /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i], [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]], [/archos ([\w ]+)( b|\))/i, /; (ac[3-6]\d\w{2,8})( b|\))/i], [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]], [/(imo) (tab \w+)/i, /(infinix) (x1101b?)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (blu|hmd|imo|tcl)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i, /(hp) ([\w ]+\w)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kobo)\s(ereader|touch)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i], [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/tcast.+(lg)e?. ([-\w]+)/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey.*devicetype\/chromecast/i], [[MODEL, CHROMECAST + " Third Generation"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/crkey.*devicetype\/([^/]*)/i], [[MODEL, /^/, "Chromecast "], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/fuchsia.*crkey/i], [[MODEL, CHROMECAST + " Nest Hub"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROMECAST], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/(portaltv)/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/(shield \w+ tv)/i], [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mi(tv|box)-?\w+) bui/i], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i], [MODEL, [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/(ouya)/i, /(nintendo) (\w+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield)( bui|\))/i], [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]], [/(playstation \w+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [/((pebble))app/i, /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(ow(?:19|20)?we?[1-3]{1,3})/i], [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/(opwwe\d{3})/i], [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]], [/(moto 360)/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]], [/(smartwatch 3)/i], [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]], [/(g watch r)/i], [MODEL, [VENDOR, LG], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, XR]], [/(pico) (4|neo3(?: link|pro)?)/i], [VENDOR, MODEL, [TYPE, XR]], [/(quest( \d| pro)?s?).+vr/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, XR]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [/(homepod).+mac os/i], [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]], [/windows iot/i], [[TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+?(mobile|vr|\d) safari/i], [MODEL, [TYPE, strMapper, {
        mobile: "Mobile",
        xr: "VR",
        "*": TABLET
    }]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/droid .+?; ([\w\. -]+)( bui|\))/i], [MODEL, [VENDOR, "Generic"]]],
    engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION, [NAME, EDGE + "HTML"]], [/(arkweb)\/([\w\.]+)/i], [NAME, VERSION], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [NAME, VERSION], [/ladybird\//i], [[NAME, "LibWeb"]], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION, NAME]],
    os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION], [/(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION, strMapper, windowsVersionMap], [NAME, WINDOWS]], [/[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, "macOS"], [VERSION, /_/g, "."]], [/android ([\d\.]+).*crkey/i], [VERSION, [NAME, CHROMECAST + " Android"]], [/fuchsia.*crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROMECAST + " Fuchsia"]], [/crkey\/([\d\.]+).*devicetype\/smartspeaker/i], [VERSION, [NAME, CHROMECAST + " SmartSpeaker"]], [/linux.*crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROMECAST + " Linux"]], [/crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROMECAST]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [VERSION, NAME], [/(ubuntu) ([\w\.]+) like android/i], [[NAME, /(.+)/, "$1 Touch"], VERSION], [/(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/\.; ]?([\d\.]*)/i], [NAME, VERSION], [/\(bb(10);/i], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION, [NAME, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [VERSION, [NAME, "watchOS"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[NAME, "Chrome OS"], VERSION], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) (\w+)/i, /(xbox); +xbox ([^\);]+)/i, /(pico) .+os([\w\.]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION]]
}, defaultProps = (props = {
    init: {},
    isIgnore: {},
    isIgnoreRgx: {},
    toString: {}
},
setProps.call(props.init, [[UA_BROWSER, [NAME, VERSION, MAJOR, TYPE]], [UA_CPU, [ARCHITECTURE]], [UA_DEVICE, [TYPE, MODEL, VENDOR]], [UA_ENGINE, [NAME, VERSION]], [UA_OS, [NAME, VERSION]]]),
setProps.call(props.isIgnore, [[UA_BROWSER, [VERSION, MAJOR]], [UA_ENGINE, [VERSION]], [UA_OS, [VERSION]]]),
setProps.call(props.isIgnoreRgx, [[UA_BROWSER, / ?browser$/i], [UA_OS, / ?os$/i]]),
setProps.call(props.toString, [[UA_BROWSER, [NAME, VERSION]], [UA_CPU, [ARCHITECTURE]], [UA_DEVICE, [VENDOR, MODEL]], [UA_ENGINE, [NAME, VERSION]], [UA_OS, [NAME, VERSION]]]),
props), props, createIData = function(e, t) {
    var n = defaultProps.init[t]
      , r = defaultProps.isIgnore[t] || 0
      , o = defaultProps.isIgnoreRgx[t] || 0
      , i = defaultProps.toString[t] || 0;
    function a() {
        setProps.call(this, n)
    }
    return a.prototype.getItem = function() {
        return e
    }
    ,
    a.prototype.withClientHints = function() {
        return NAVIGATOR_UADATA ? NAVIGATOR_UADATA.getHighEntropyValues(CH_ALL_VALUES).then((function(t) {
            return e.setCH(new UACHData(t,!1)).parseCH().get()
        }
        )) : e.parseCH().get()
    }
    ,
    a.prototype.withFeatureCheck = function() {
        return e.detectFeature().get()
    }
    ,
    t != UA_RESULT && (a.prototype.is = function(e) {
        var t = !1;
        for (var n in this)
            if (this.hasOwnProperty(n) && !has(r, n) && lowerize(o ? strip(o, this[n]) : this[n]) == lowerize(o ? strip(o, e) : e)) {
                if (t = !0,
                e != UNDEF_TYPE)
                    break
            } else if (e == UNDEF_TYPE && t) {
                t = !t;
                break
            }
        return t
    }
    ,
    a.prototype.toString = function() {
        var e = EMPTY;
        for (var t in i)
            typeof this[i[t]] !== UNDEF_TYPE && (e += (e ? " " : EMPTY) + this[i[t]]);
        return e || UNDEF_TYPE
    }
    ),
    NAVIGATOR_UADATA || (a.prototype.then = function(e) {
        var t = this
          , n = function() {
            for (var e in t)
                t.hasOwnProperty(e) && (this[e] = t[e])
        };
        n.prototype = {
            is: a.prototype.is,
            toString: a.prototype.toString
        };
        var r = new n;
        return e(r),
        r
    }
    ),
    new a
};
function UACHData(e, t) {
    if (e = e || {},
    setProps.call(this, CH_ALL_VALUES),
    t)
        setProps.call(this, [[BRANDS, itemListToArray(e[CH_HEADER])], [FULLVERLIST, itemListToArray(e[CH_HEADER_FULL_VER_LIST])], [MOBILE, /\?1/.test(e[CH_HEADER_MOBILE])], [MODEL, stripQuotes(e[CH_HEADER_MODEL])], [PLATFORM, stripQuotes(e[CH_HEADER_PLATFORM])], [PLATFORMVER, stripQuotes(e[CH_HEADER_PLATFORM_VER])], [ARCHITECTURE, stripQuotes(e[CH_HEADER_ARCH])], [FORMFACTORS, itemListToArray(e[CH_HEADER_FORM_FACTORS])], [BITNESS, stripQuotes(e[CH_HEADER_BITNESS])]]);
    else
        for (var n in e)
            this.hasOwnProperty(n) && typeof e[n] !== UNDEF_TYPE && (this[n] = e[n])
}
function UAItem(e, t, n, r) {
    return this.get = function(e) {
        return e ? this.data.hasOwnProperty(e) ? this.data[e] : void 0 : this.data
    }
    ,
    this.set = function(e, t) {
        return this.data[e] = t,
        this
    }
    ,
    this.setCH = function(e) {
        return this.uaCH = e,
        this
    }
    ,
    this.detectFeature = function() {
        if (NAVIGATOR && NAVIGATOR.userAgent == this.ua)
            switch (this.itemType) {
            case UA_BROWSER:
                NAVIGATOR.brave && typeof NAVIGATOR.brave.isBrave == FUNC_TYPE && this.set(NAME, "Brave");
                break;
            case UA_DEVICE:
                !this.get(TYPE) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[MOBILE] && this.set(TYPE, MOBILE),
                "Macintosh" == this.get(MODEL) && NAVIGATOR && typeof NAVIGATOR.standalone !== UNDEF_TYPE && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 2 && this.set(MODEL, "iPad").set(TYPE, TABLET);
                break;
            case UA_OS:
                !this.get(NAME) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[PLATFORM] && this.set(NAME, NAVIGATOR_UADATA[PLATFORM]);
                break;
            case UA_RESULT:
                var e = this.data
                  , t = function(t) {
                    return e[t].getItem().detectFeature().get()
                };
                this.set(UA_BROWSER, t(UA_BROWSER)).set(UA_CPU, t(UA_CPU)).set(UA_DEVICE, t(UA_DEVICE)).set(UA_ENGINE, t(UA_ENGINE)).set(UA_OS, t(UA_OS))
            }
        return this
    }
    ,
    this.parseUA = function() {
        return this.itemType != UA_RESULT && rgxMapper.call(this.data, this.ua, this.rgxMap),
        this.itemType == UA_BROWSER && this.set(MAJOR, majorize(this.get(VERSION))),
        this
    }
    ,
    this.parseCH = function() {
        var e = this.uaCH
          , t = this.rgxMap;
        switch (this.itemType) {
        case UA_BROWSER:
        case UA_ENGINE:
            var n, r = e[FULLVERLIST] || e[BRANDS];
            if (r)
                for (var o in r) {
                    var i = r[o].brand || r[o]
                      , a = r[o].version;
                    this.itemType != UA_BROWSER || /not.a.brand/i.test(i) || n && (!/chrom/i.test(n) || i == CHROMIUM) || (i = strMapper(i, {
                        Chrome: "Google Chrome",
                        Edge: "Microsoft Edge",
                        "Chrome WebView": "Android WebView",
                        "Chrome Headless": "HeadlessChrome",
                        "Huawei Browser": "HuaweiBrowser",
                        "MIUI Browser": "Miui Browser",
                        "Opera Mobi": "OperaMobile",
                        Yandex: "YaBrowser"
                    }),
                    this.set(NAME, i).set(VERSION, a).set(MAJOR, majorize(a)),
                    n = i),
                    this.itemType == UA_ENGINE && i == CHROMIUM && this.set(VERSION, a)
                }
            break;
        case UA_CPU:
            var s = e[ARCHITECTURE];
            s && (s && "64" == e[BITNESS] && (s += "64"),
            rgxMapper.call(this.data, s + ";", t));
            break;
        case UA_DEVICE:
            if (e[MOBILE] && this.set(TYPE, MOBILE),
            e[MODEL] && (this.set(MODEL, e[MODEL]),
            !this.get(TYPE) || !this.get(VENDOR))) {
                var c = {};
                rgxMapper.call(c, "droid 9; " + e[MODEL] + ")", t),
                !this.get(TYPE) && c.type && this.set(TYPE, c.type),
                !this.get(VENDOR) && c.vendor && this.set(VENDOR, c.vendor)
            }
            if (e[FORMFACTORS]) {
                var l;
                if ("string" != typeof e[FORMFACTORS])
                    for (var u = 0; !l && u < e[FORMFACTORS].length; )
                        l = strMapper(e[FORMFACTORS][u++], formFactorsMap);
                else
                    l = strMapper(e[FORMFACTORS], formFactorsMap);
                this.set(TYPE, l)
            }
            break;
        case UA_OS:
            var p = e[PLATFORM];
            if (p) {
                var d = e[PLATFORMVER];
                p == WINDOWS && (d = parseInt(majorize(d), 10) >= 13 ? "11" : "10"),
                this.set(NAME, p).set(VERSION, d)
            }
            this.get(NAME) == WINDOWS && "Xbox" == e[MODEL] && this.set(NAME, "Xbox").set(VERSION, void 0);
            break;
        case UA_RESULT:
            var f = this.data
              , h = function(t) {
                return f[t].getItem().setCH(e).parseCH().get()
            };
            this.set(UA_BROWSER, h(UA_BROWSER)).set(UA_CPU, h(UA_CPU)).set(UA_DEVICE, h(UA_DEVICE)).set(UA_ENGINE, h(UA_ENGINE)).set(UA_OS, h(UA_OS))
        }
        return this
    }
    ,
    setProps.call(this, [["itemType", e], ["ua", t], ["uaCH", r], ["rgxMap", n], ["data", createIData(this, e)]]),
    this
}
function UAParser(e, t, n) {
    if (typeof e === OBJ_TYPE ? (isExtensions(e, !0) ? (typeof t === OBJ_TYPE && (n = t),
    t = e) : (n = e,
    t = void 0),
    e = void 0) : typeof e !== STR_TYPE || isExtensions(t, !0) || (n = t,
    t = void 0),
    n && typeof n.append === FUNC_TYPE) {
        var r = {};
        n.forEach((function(e, t) {
            r[t] = e
        }
        )),
        n = r
    }
    if (!(this instanceof UAParser))
        return new UAParser(e,t,n).getResult();
    var o = typeof e === STR_TYPE ? e : n && n[USER_AGENT] ? n[USER_AGENT] : NAVIGATOR && NAVIGATOR.userAgent ? NAVIGATOR.userAgent : EMPTY
      , i = new UACHData(n,!0)
      , a = t ? extend(defaultRegexes, t) : defaultRegexes
      , s = function(e) {
        return e == UA_RESULT ? function() {
            return new UAItem(e,o,a,i).set("ua", o).set(UA_BROWSER, this.getBrowser()).set(UA_CPU, this.getCPU()).set(UA_DEVICE, this.getDevice()).set(UA_ENGINE, this.getEngine()).set(UA_OS, this.getOS()).get()
        }
        : function() {
            return new UAItem(e,o,a[e],i).parseUA().get()
        }
    };
    return setProps.call(this, [["getBrowser", s(UA_BROWSER)], ["getCPU", s(UA_CPU)], ["getDevice", s(UA_DEVICE)], ["getEngine", s(UA_ENGINE)], ["getOS", s(UA_OS)], ["getResult", s(UA_RESULT)], ["getUA", function() {
        return o
    }
    ], ["setUA", function(e) {
        return isString(e) && (o = e.length > UA_MAX_LENGTH ? trim(e, UA_MAX_LENGTH) : e),
        this
    }
    ]]).setUA(o),
    this
}
UAParser.VERSION = LIBVERSION,
UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR, TYPE]),
UAParser.CPU = enumerize([ARCHITECTURE]),
UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]),
UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
const noRedirectWhiteList = ["/activity/guide", "/ott", "/tesla"];
function getH5Host(e) {
    var t;
    return (null != (t = e.req.headers["user-agent"]) ? t : "").toLowerCase().includes("micromessenger") ? "https://chenzhongtech.com" : "https://m.gifshow.com"
}
const rules = [{
    match(e) {
        var t, n;
        if (e.uaInfo.device.type && pathToRegexp_1("/video/:photoId").regexp.test(e.path)) {
            const r = null != (t = e.path.match(pathToRegexp_1("/video/:photoId").regexp)) ? t : [];
            return r && "".concat(getH5Host(e), "/fw/photo/").concat(null != (n = r[1]) ? n : "").concat(e.querystring ? "?" + e.querystring : "")
        }
        return ""
    }
}, {
    match(e) {
        var t, n;
        if (e.uaInfo.device.type && pathToRegexp_1("/movie/video/:photoId").regexp.test(e.path)) {
            const r = null != (t = e.path.match(pathToRegexp_1("/movie/video/:photoId").regexp)) ? t : [];
            return r && "".concat(getH5Host(e), "/fw/photo/").concat(null != (n = r[1]) ? n : "").concat(e.querystring ? "?" + e.querystring : "")
        }
        return ""
    }
}, {
    match(e) {
        var t, n;
        if (e.uaInfo.device.type && pathToRegexp_1("/short-video/:photoId").regexp.test(e.path)) {
            const r = null != (t = e.path.match(pathToRegexp_1("/short-video/:photoId").regexp)) ? t : [];
            return r && "".concat(getH5Host(e), "/fw/photo/").concat(null != (n = r[1]) ? n : "").concat(e.querystring ? "?" + e.querystring : "")
        }
        return ""
    }
}, {
    match(e) {
        var t, n;
        if (e.uaInfo.device.type && pathToRegexp_1("/featured/:photoId").regexp.test(e.path)) {
            const r = null != (t = e.path.match(pathToRegexp_1("/featured/:photoId").regexp)) ? t : [];
            return r && "".concat(getH5Host(e), "/fw/photo/").concat(null != (n = r[1]) ? n : "").concat(e.querystring ? "?" + e.querystring : "")
        }
        return ""
    }
}];
function complexRedirectRules(e) {
    var t, n, r;
    const o = {
        url: useUrl(),
        path: window.location.pathname,
        cookies: useCookies(),
        cookie: document.cookie,
        headers: {
            "user-agent": window.navigator.userAgent
        },
        kconf: useKconf(),
        abtest: useAbtest(),
        env: useEnv(),
        uaInfo: window.navigator.userAgent
    };
    if (o.url) {
        const e = o;
        if (e.uaInfo = new UAParser(o.headers["user-agent"]).getResult(),
        noRedirectWhiteList.some((t => {
            var n, r;
            return null == (r = null == (n = e.url) ? void 0 : n.pathname) ? void 0 : r.includes(t)
        }
        )))
            return;
        if ("mobile" !== e.uaInfo.device.type)
            return;
        for (const t of rules) {
            const n = t.match(e);
            if (n)
                return void (window.location.href = n)
        }
        if (null != (r = null == (n = null == (t = e.url) ? void 0 : t.href) ? void 0 : n.endsWith(".html")) && r)
            return;
        window.location.href = "https://m.kuaishou.com/"
    }
}
const byteToHex = [];
for (let dt = 0; dt < 256; ++dt)
    byteToHex.push((dt + 256).toString(16).slice(1));
function unsafeStringify(e, t=0) {
    return (byteToHex[e[t + 0]] + byteToHex[e[t + 1]] + byteToHex[e[t + 2]] + byteToHex[e[t + 3]] + "-" + byteToHex[e[t + 4]] + byteToHex[e[t + 5]] + "-" + byteToHex[e[t + 6]] + byteToHex[e[t + 7]] + "-" + byteToHex[e[t + 8]] + byteToHex[e[t + 9]] + "-" + byteToHex[e[t + 10]] + byteToHex[e[t + 11]] + byteToHex[e[t + 12]] + byteToHex[e[t + 13]] + byteToHex[e[t + 14]] + byteToHex[e[t + 15]]).toLowerCase()
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if ("undefined" == typeof crypto || !crypto.getRandomValues)
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        getRandomValues = crypto.getRandomValues.bind(crypto)
    }
    return getRandomValues(rnds8)
}
const randomUUID = "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  , native = {
    randomUUID: randomUUID
};
function v4(e, t, n) {
    var r, o, i;
    if (native.randomUUID && !t && !e)
        return native.randomUUID();
    const a = null != (i = null != (o = (e = e || {}).random) ? o : null == (r = e.rng) ? void 0 : r.call(e)) ? i : rng();
    if (a.length < 16)
        throw new Error("Random bytes length must be >= 16");
    return a[6] = 15 & a[6] | 64,
    a[8] = 63 & a[8] | 128,
    unsafeStringify(a)
}
var sparkMd5 = {
    exports: {}
};
sparkMd5.exports = function(e) {
    var t = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function n(e, t) {
        var n = e[0]
          , r = e[1]
          , o = e[2]
          , i = e[3];
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & o | ~r & i) + t[0] - 680876936 | 0) << 7 | n >>> 25) + r | 0) & r | ~n & o) + t[1] - 389564586 | 0) << 12 | i >>> 20) + n | 0) & n | ~i & r) + t[2] + 606105819 | 0) << 17 | o >>> 15) + i | 0) & i | ~o & n) + t[3] - 1044525330 | 0) << 22 | r >>> 10) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & o | ~r & i) + t[4] - 176418897 | 0) << 7 | n >>> 25) + r | 0) & r | ~n & o) + t[5] + 1200080426 | 0) << 12 | i >>> 20) + n | 0) & n | ~i & r) + t[6] - 1473231341 | 0) << 17 | o >>> 15) + i | 0) & i | ~o & n) + t[7] - 45705983 | 0) << 22 | r >>> 10) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & o | ~r & i) + t[8] + 1770035416 | 0) << 7 | n >>> 25) + r | 0) & r | ~n & o) + t[9] - 1958414417 | 0) << 12 | i >>> 20) + n | 0) & n | ~i & r) + t[10] - 42063 | 0) << 17 | o >>> 15) + i | 0) & i | ~o & n) + t[11] - 1990404162 | 0) << 22 | r >>> 10) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & o | ~r & i) + t[12] + 1804603682 | 0) << 7 | n >>> 25) + r | 0) & r | ~n & o) + t[13] - 40341101 | 0) << 12 | i >>> 20) + n | 0) & n | ~i & r) + t[14] - 1502002290 | 0) << 17 | o >>> 15) + i | 0) & i | ~o & n) + t[15] + 1236535329 | 0) << 22 | r >>> 10) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & i | o & ~i) + t[1] - 165796510 | 0) << 5 | n >>> 27) + r | 0) & o | r & ~o) + t[6] - 1069501632 | 0) << 9 | i >>> 23) + n | 0) & r | n & ~r) + t[11] + 643717713 | 0) << 14 | o >>> 18) + i | 0) & n | i & ~n) + t[0] - 373897302 | 0) << 20 | r >>> 12) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & i | o & ~i) + t[5] - 701558691 | 0) << 5 | n >>> 27) + r | 0) & o | r & ~o) + t[10] + 38016083 | 0) << 9 | i >>> 23) + n | 0) & r | n & ~r) + t[15] - 660478335 | 0) << 14 | o >>> 18) + i | 0) & n | i & ~n) + t[4] - 405537848 | 0) << 20 | r >>> 12) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & i | o & ~i) + t[9] + 568446438 | 0) << 5 | n >>> 27) + r | 0) & o | r & ~o) + t[14] - 1019803690 | 0) << 9 | i >>> 23) + n | 0) & r | n & ~r) + t[3] - 187363961 | 0) << 14 | o >>> 18) + i | 0) & n | i & ~n) + t[8] + 1163531501 | 0) << 20 | r >>> 12) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r & i | o & ~i) + t[13] - 1444681467 | 0) << 5 | n >>> 27) + r | 0) & o | r & ~o) + t[2] - 51403784 | 0) << 9 | i >>> 23) + n | 0) & r | n & ~r) + t[7] + 1735328473 | 0) << 14 | o >>> 18) + i | 0) & n | i & ~n) + t[12] - 1926607734 | 0) << 20 | r >>> 12) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r ^ o ^ i) + t[5] - 378558 | 0) << 4 | n >>> 28) + r | 0) ^ r ^ o) + t[8] - 2022574463 | 0) << 11 | i >>> 21) + n | 0) ^ n ^ r) + t[11] + 1839030562 | 0) << 16 | o >>> 16) + i | 0) ^ i ^ n) + t[14] - 35309556 | 0) << 23 | r >>> 9) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r ^ o ^ i) + t[1] - 1530992060 | 0) << 4 | n >>> 28) + r | 0) ^ r ^ o) + t[4] + 1272893353 | 0) << 11 | i >>> 21) + n | 0) ^ n ^ r) + t[7] - 155497632 | 0) << 16 | o >>> 16) + i | 0) ^ i ^ n) + t[10] - 1094730640 | 0) << 23 | r >>> 9) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r ^ o ^ i) + t[13] + 681279174 | 0) << 4 | n >>> 28) + r | 0) ^ r ^ o) + t[0] - 358537222 | 0) << 11 | i >>> 21) + n | 0) ^ n ^ r) + t[3] - 722521979 | 0) << 16 | o >>> 16) + i | 0) ^ i ^ n) + t[6] + 76029189 | 0) << 23 | r >>> 9) + o | 0,
        r = ((r += ((o = ((o += ((i = ((i += ((n = ((n += (r ^ o ^ i) + t[9] - 640364487 | 0) << 4 | n >>> 28) + r | 0) ^ r ^ o) + t[12] - 421815835 | 0) << 11 | i >>> 21) + n | 0) ^ n ^ r) + t[15] + 530742520 | 0) << 16 | o >>> 16) + i | 0) ^ i ^ n) + t[2] - 995338651 | 0) << 23 | r >>> 9) + o | 0,
        r = ((r += ((i = ((i += (r ^ ((n = ((n += (o ^ (r | ~i)) + t[0] - 198630844 | 0) << 6 | n >>> 26) + r | 0) | ~o)) + t[7] + 1126891415 | 0) << 10 | i >>> 22) + n | 0) ^ ((o = ((o += (n ^ (i | ~r)) + t[14] - 1416354905 | 0) << 15 | o >>> 17) + i | 0) | ~n)) + t[5] - 57434055 | 0) << 21 | r >>> 11) + o | 0,
        r = ((r += ((i = ((i += (r ^ ((n = ((n += (o ^ (r | ~i)) + t[12] + 1700485571 | 0) << 6 | n >>> 26) + r | 0) | ~o)) + t[3] - 1894986606 | 0) << 10 | i >>> 22) + n | 0) ^ ((o = ((o += (n ^ (i | ~r)) + t[10] - 1051523 | 0) << 15 | o >>> 17) + i | 0) | ~n)) + t[1] - 2054922799 | 0) << 21 | r >>> 11) + o | 0,
        r = ((r += ((i = ((i += (r ^ ((n = ((n += (o ^ (r | ~i)) + t[8] + 1873313359 | 0) << 6 | n >>> 26) + r | 0) | ~o)) + t[15] - 30611744 | 0) << 10 | i >>> 22) + n | 0) ^ ((o = ((o += (n ^ (i | ~r)) + t[6] - 1560198380 | 0) << 15 | o >>> 17) + i | 0) | ~n)) + t[13] + 1309151649 | 0) << 21 | r >>> 11) + o | 0,
        r = ((r += ((i = ((i += (r ^ ((n = ((n += (o ^ (r | ~i)) + t[4] - 145523070 | 0) << 6 | n >>> 26) + r | 0) | ~o)) + t[11] - 1120210379 | 0) << 10 | i >>> 22) + n | 0) ^ ((o = ((o += (n ^ (i | ~r)) + t[2] + 718787259 | 0) << 15 | o >>> 17) + i | 0) | ~n)) + t[9] - 343485551 | 0) << 21 | r >>> 11) + o | 0,
        e[0] = n + e[0] | 0,
        e[1] = r + e[1] | 0,
        e[2] = o + e[2] | 0,
        e[3] = i + e[3] | 0
    }
    function r(e) {
        var t, n = [];
        for (t = 0; t < 64; t += 4)
            n[t >> 2] = e.charCodeAt(t) + (e.charCodeAt(t + 1) << 8) + (e.charCodeAt(t + 2) << 16) + (e.charCodeAt(t + 3) << 24);
        return n
    }
    function o(e) {
        var t, n = [];
        for (t = 0; t < 64; t += 4)
            n[t >> 2] = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24);
        return n
    }
    function i(e) {
        var t, o, i, a, s, c, l = e.length, u = [1732584193, -271733879, -1732584194, 271733878];
        for (t = 64; t <= l; t += 64)
            n(u, r(e.substring(t - 64, t)));
        for (o = (e = e.substring(t - 64)).length,
        i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        t = 0; t < o; t += 1)
            i[t >> 2] |= e.charCodeAt(t) << (t % 4 << 3);
        if (i[t >> 2] |= 128 << (t % 4 << 3),
        t > 55)
            for (n(u, i),
            t = 0; t < 16; t += 1)
                i[t] = 0;
        return a = (a = 8 * l).toString(16).match(/(.*?)(.{0,8})$/),
        s = parseInt(a[2], 16),
        c = parseInt(a[1], 16) || 0,
        i[14] = s,
        i[15] = c,
        n(u, i),
        u
    }
    function a(e) {
        var t, r, i, a, s, c, l = e.length, u = [1732584193, -271733879, -1732584194, 271733878];
        for (t = 64; t <= l; t += 64)
            n(u, o(e.subarray(t - 64, t)));
        for (r = (e = t - 64 < l ? e.subarray(t - 64) : new Uint8Array(0)).length,
        i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        t = 0; t < r; t += 1)
            i[t >> 2] |= e[t] << (t % 4 << 3);
        if (i[t >> 2] |= 128 << (t % 4 << 3),
        t > 55)
            for (n(u, i),
            t = 0; t < 16; t += 1)
                i[t] = 0;
        return a = (a = 8 * l).toString(16).match(/(.*?)(.{0,8})$/),
        s = parseInt(a[2], 16),
        c = parseInt(a[1], 16) || 0,
        i[14] = s,
        i[15] = c,
        n(u, i),
        u
    }
    function s(e) {
        var n, r = "";
        for (n = 0; n < 4; n += 1)
            r += t[e >> 8 * n + 4 & 15] + t[e >> 8 * n & 15];
        return r
    }
    function c(e) {
        var t;
        for (t = 0; t < e.length; t += 1)
            e[t] = s(e[t]);
        return e.join("")
    }
    function l(e) {
        return /[\u0080-\uFFFF]/.test(e) && (e = unescape(encodeURIComponent(e))),
        e
    }
    function u(e, t) {
        var n, r = e.length, o = new ArrayBuffer(r), i = new Uint8Array(o);
        for (n = 0; n < r; n += 1)
            i[n] = e.charCodeAt(n);
        return t ? i : o
    }
    function p(e) {
        return String.fromCharCode.apply(null, new Uint8Array(e))
    }
    function d(e, t, n) {
        var r = new Uint8Array(e.byteLength + t.byteLength);
        return r.set(new Uint8Array(e)),
        r.set(new Uint8Array(t), e.byteLength),
        r
    }
    function f(e) {
        var t, n = [], r = e.length;
        for (t = 0; t < r - 1; t += 2)
            n.push(parseInt(e.substr(t, 2), 16));
        return String.fromCharCode.apply(String, n)
    }
    function h() {
        this.reset()
    }
    return c(i("hello")),
    "undefined" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || function() {
        function t(e, t) {
            return (e = 0 | e || 0) < 0 ? Math.max(e + t, 0) : Math.min(e, t)
        }
        ArrayBuffer.prototype.slice = function(n, r) {
            var o, i, a, s, c = this.byteLength, l = t(n, c), u = c;
            return r !== e && (u = t(r, c)),
            l > u ? new ArrayBuffer(0) : (o = u - l,
            i = new ArrayBuffer(o),
            a = new Uint8Array(i),
            s = new Uint8Array(this,l,o),
            a.set(s),
            i)
        }
    }(),
    h.prototype.append = function(e) {
        return this.appendBinary(l(e)),
        this
    }
    ,
    h.prototype.appendBinary = function(e) {
        this._buff += e,
        this._length += e.length;
        var t, o = this._buff.length;
        for (t = 64; t <= o; t += 64)
            n(this._hash, r(this._buff.substring(t - 64, t)));
        return this._buff = this._buff.substring(t - 64),
        this
    }
    ,
    h.prototype.end = function(e) {
        var t, n, r = this._buff, o = r.length, i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (t = 0; t < o; t += 1)
            i[t >> 2] |= r.charCodeAt(t) << (t % 4 << 3);
        return this._finish(i, o),
        n = c(this._hash),
        e && (n = f(n)),
        this.reset(),
        n
    }
    ,
    h.prototype.reset = function() {
        return this._buff = "",
        this._length = 0,
        this._hash = [1732584193, -271733879, -1732584194, 271733878],
        this
    }
    ,
    h.prototype.getState = function() {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
        }
    }
    ,
    h.prototype.setState = function(e) {
        return this._buff = e.buff,
        this._length = e.length,
        this._hash = e.hash,
        this
    }
    ,
    h.prototype.destroy = function() {
        delete this._hash,
        delete this._buff,
        delete this._length
    }
    ,
    h.prototype._finish = function(e, t) {
        var r, o, i, a = t;
        if (e[a >> 2] |= 128 << (a % 4 << 3),
        a > 55)
            for (n(this._hash, e),
            a = 0; a < 16; a += 1)
                e[a] = 0;
        r = (r = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/),
        o = parseInt(r[2], 16),
        i = parseInt(r[1], 16) || 0,
        e[14] = o,
        e[15] = i,
        n(this._hash, e)
    }
    ,
    h.hash = function(e, t) {
        return h.hashBinary(l(e), t)
    }
    ,
    h.hashBinary = function(e, t) {
        var n = c(i(e));
        return t ? f(n) : n
    }
    ,
    h.ArrayBuffer = function() {
        this.reset()
    }
    ,
    h.ArrayBuffer.prototype.append = function(e) {
        var t, r = d(this._buff.buffer, e), i = r.length;
        for (this._length += e.byteLength,
        t = 64; t <= i; t += 64)
            n(this._hash, o(r.subarray(t - 64, t)));
        return this._buff = t - 64 < i ? new Uint8Array(r.buffer.slice(t - 64)) : new Uint8Array(0),
        this
    }
    ,
    h.ArrayBuffer.prototype.end = function(e) {
        var t, n, r = this._buff, o = r.length, i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (t = 0; t < o; t += 1)
            i[t >> 2] |= r[t] << (t % 4 << 3);
        return this._finish(i, o),
        n = c(this._hash),
        e && (n = f(n)),
        this.reset(),
        n
    }
    ,
    h.ArrayBuffer.prototype.reset = function() {
        return this._buff = new Uint8Array(0),
        this._length = 0,
        this._hash = [1732584193, -271733879, -1732584194, 271733878],
        this
    }
    ,
    h.ArrayBuffer.prototype.getState = function() {
        var e = h.prototype.getState.call(this);
        return e.buff = p(e.buff),
        e
    }
    ,
    h.ArrayBuffer.prototype.setState = function(e) {
        return e.buff = u(e.buff, !0),
        h.prototype.setState.call(this, e)
    }
    ,
    h.ArrayBuffer.prototype.destroy = h.prototype.destroy,
    h.ArrayBuffer.prototype._finish = h.prototype._finish,
    h.ArrayBuffer.hash = function(e, t) {
        var n = c(a(new Uint8Array(e)));
        return t ? f(n) : n
    }
    ,
    h
}();
var sparkMd5Exports = sparkMd5.exports;
const SparkMD5 = getDefaultExportFromCjs(sparkMd5Exports)
  , defaultMaxAge = 31536e6
  , deleteCookie = (e, t, n) => {
    var r, o, i, a, s;
    const c = null == (a = null == (i = null == (o = null == (r = null == e ? void 0 : e.url) ? void 0 : r.hostname) ? void 0 : o.split(".")) ? void 0 : i.slice(-2)) ? void 0 : a.join(".");
    null == (s = null == e ? void 0 : e.cookies) || s.set(t, n, {
        httpOnly: !0,
        domain: c,
        expires: new Date(0)
    })
}
;
async function defaultCookie(e) {
    var t, n, r, o, i, a, s, c, l, u, p, d, f, h, m;
    const g = {
        url: useUrl(),
        path: window.location.pathname,
        cookies: useCookies(),
        cookie: document.cookie,
        headers: {
            "user-agent": window.navigator.userAgent
        }
    };
    null == (n = null == g ? void 0 : g.cookies) || n.set("kpf", "PC_WEB", {
        domain: null == (t = null == g ? void 0 : g.url) ? void 0 : t.hostname,
        maxAge: defaultMaxAge
    });
    const v = "KUAISHOU_VISION";
    (null == (r = null == g ? void 0 : g.cookies) ? void 0 : r.get("kpn")) === v && (deleteCookie(g, "kpn", v),
    null == (i = null == g ? void 0 : g.cookies) || i.set("kpn", v, {
        domain: null == (o = null == g ? void 0 : g.url) ? void 0 : o.hostname,
        expires: new Date
    })),
    null == (s = null == g ? void 0 : g.cookies) || s.set("kpn", v, {
        domain: null == (a = null == g ? void 0 : g.url) ? void 0 : a.hostname,
        maxAge: defaultMaxAge
    }),
    null == (l = null == g ? void 0 : g.cookies) || l.set("clientid", "3", {
        httpOnly: !0,
        domain: null == (c = null == g ? void 0 : g.url) ? void 0 : c.hostname,
        maxAge: defaultMaxAge
    });
    const y = null == (u = null == g ? void 0 : g.cookies) ? void 0 : u.get("did");
    if (/ (Kwai|kswv)\//.test(null == g ? void 0 : g.headers["user-agent"]))
        return;
    const _ = (null == y ? void 0 : y.startsWith("web_")) && 36 === y.length ? y : "web_" + SparkMD5.hash(v4());
    if (null == (m = null == g ? void 0 : g.cookies) || m.set("did", _, {
        domain: null == (h = null == (f = null == (d = null == (p = null == g ? void 0 : g.url) ? void 0 : p.hostname) ? void 0 : d.split(".")) ? void 0 : f.slice(-2)) ? void 0 : h.join("."),
        httpOnly: !1,
        maxAge: defaultMaxAge
    }),
    null == g ? void 0 : g.headers) {
        const e = g.headers.cookie || ""
          , t = y ? e.replace(y, _) : "".concat(e).concat(e ? "; " : "", "did=").concat(_);
        (null == g ? void 0 : g.headers) && (g.headers.cookie = t)
    }
}
function createApp(e, t, n, r) {
    console.log("createApp");
    const {radar: o, loggerUtils: i} = initLoggerAndRadar()
      , a = e(AppComponent)
      , s = createAppRouter();
    installLogger(a, s, i),
    a.directive("log", vLog);
    const c = createCache();
    return init$1({}),
    initStore(a, t, {
        cache: c
    }, !1),
    a.use(s),
    dayjs.locale("zh-cn"),
    dayjs.extend(relativeTime),
    dayjs.prototype.fromNowBackup = dayjs.prototype.fromNow,
    dayjs.prototype.fromNow = function(...e) {
        const t = this.fromNowBackup(...e);
        return "几秒内" === t ? "刚刚" : t
    }
    ,
    provideHead(a),
    provideUserAgent(a, r),
    provideCookies(a, r),
    provideRedirect(a, r, s, (e => s.replace(e))),
    provideUrl(a, r),
    provideKconf(a, r),
    provideAbtest(a, r),
    provideEnv(a, r),
    defaultCookie(),
    complexRedirectRules(),
    addAdapter(PrefetchAdapter()),
    collectPerf(null == o ? void 0 : o.core),
    {
        app: a,
        router: s,
        cache: c,
        radar: o
    }
}
// "undefined" != typeof window && __vitePreload(( () => ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./Element.prototype.getAttributeNames-CJPXYS7e.js")))), [], "");
const customFetch = (e, t) => request({
    url: e,
    method: null == t ? void 0 : t.method,
    data: null == t ? void 0 : t.body,
    headers: null == t ? void 0 : t.headers,
    withCredentials: "omit" !== (null == t ? void 0 : t.credentials) && void 0
}).then((e => (e.status >= 200 && e.status < 400 && (e.ok = !0,
e.json = async () => ({
    data: e.data
})),
e))).catch((e => ({
    ok: !0,
    status: 200,
    headers: {
        get(e) {
            if ("Content-Type" === e)
                return "application/json"
        }
    },
    statusText: "ok",
    json: async () => ({
        error: e
    })
})));
function main$1() {
    const {app: e, router: t, cache: n, radar: r} = createApp(createSSRApp, customFetch);
    n.restore(window.INIT_STATE),
    t.isReady().then(( () => {
        e.mount("#app"),
        console.log("hydrated"),
        null == r || r.fmp()
    }
    ))
}
async function main() {
    if (window.__USE_SSR__)
        main$1();
    else {
        const {main: e} = await __vitePreload((async () => {
            // const {main: e} = await ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => import("./main-csr-DR97lJ6g.js")));
            // const {main: e} = await ("undefined" != typeof window && window.__cdn_import__ ? window.__cdn_import__ : e => e())(( () => ({main: () => {}})));
            const {main: e} = {main: () => {}};
            return {
                main: e
            }
        }
        ), [], "");
        e()
    }
}
lt$1({
    env: "production",
    productName: "kuaishou-vision"
}),
main();
// console.log("Main function skipped.");
// export {createModelFamily as $, vShow as A, createCommentVNode as B, isRef as C, sendClickEvent as D, renderSlot as E, inject as F, createBaseVNode as G, normalizeClass as H, withModifiers as I, normalizeStyle as J, openUrl as K, Fragment as L, createStaticVNode as M, renderList as N, dayjs as O, useUserModel as P, useDialogModel as Q, useLogger as R, useTemplateRef as S, Teleport as T, normalizeProps as U, mergeProps as V, useSlots as W, nextTick as X, mergeModels as Y, useModel$1 as Z, _export_sfc as _, customFetch as a, onUnmounted as a0, useRestMutation as a1, LoginSource as a2, vModelText as a3, resolveDirective as a4, getShowLogParams as a5, resolveDynamicComponent as a6, defineAsyncComponent as a7, __vitePreload as a8, createUseModel as a9, vModelRadio as aA, addListener$1 as aB, removeListener$1 as aC, RouterLink as aD, KeepAlive as aE, toRefs as aF, ABTestModel as aG, useRouter$1 as aH, useBroadcastModel as aI, StateStatus as aJ, useReportModel as aK, isFeed as aL, isComment as aM, api as aN, readonly as aO, toRaw as aP, Transition as aQ, effectScope as aR, pushScopeId as aS, popScopeId as aT, appendParam as aU, updateQuery as aV, getClickLogParams as aW, sendShowEvent as aX, getDefaultExportFromCjs as aY, invoke as aZ, useRoute$1 as aa, RouteName as ab, useVideoModel as ac, DialogId as ad, onUpdated as ae, h$5 as af, onBeforeUpdate as ag, useLog as ah, getQueryParams as ai, SearchParamsName as aj, backHome as ak, shallowRef as al, getCurrentScope as am, onScopeDispose as an, shallowReadonly as ao, getCurrentInstance as ap, commonjsGlobal as aq, loginModel as ar, useRouter as as, resolveComponent as at, render as au, useKconfModel as av, markRaw as aw, WindowWidth as ax, routeName as ay, withKeys as az, createApp$1 as b, createApp as c, createModel as d, useRestQuery as e, computed as f, defineComponent as g, useHead as h, isSSR as i, useLayoutModel as j, ref as k, onBeforeUnmount as l, createBlock as m, unref as n, onMounted as o, withCtx as p, provide as q, reactive as r, openBlock as s, createVNode as t, useModel as u, createElementBlock as v, watch as w, createTextVNode as x, toDisplayString as y, withDirectives as z};
